{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/csv-parse/lib/ResizeableBuffer.js","webpack:///./node_modules/csv-parse/lib/index.js","webpack:///./node_modules/csv-parse/lib/sync.js","webpack:///./src sync","webpack:///./src/addon-manager.js","webpack:///./src/addon-utils.js","webpack:///./src/app.js","webpack:///./src/certificate-manager.js","webpack:///./src/constants.js","webpack:///./src/controllers/actions_controller.js","webpack:///./src/controllers/adapters_controller.js","webpack:///./src/controllers/addons_controller.js","webpack:///./src/controllers/debug_controller.js","webpack:///./src/controllers/events_controller.js","webpack:///./src/controllers/extensions_controller.js","webpack:///./src/controllers/internal_logs_controller.js","webpack:///./src/controllers/log_out_controller.js","webpack:///./src/controllers/login_controller.js","webpack:///./src/controllers/logs_controller.js","webpack:///./src/controllers/new_things_controller.js","webpack:///./src/controllers/notifiers_controller.js","webpack:///./src/controllers/oauth_controller.ts","webpack:///./src/controllers/oauthclients_controller.ts","webpack:///./src/controllers/ping_controller.js","webpack:///./src/controllers/proxy_controller.js","webpack:///./src/controllers/push_controller.js","webpack:///./src/controllers/root_controller.js","webpack:///./src/controllers/settings_controller.js","webpack:///./src/controllers/things_controller.js","webpack:///./src/controllers/updates_controller.js","webpack:///./src/controllers/uploads_controller.js","webpack:///./src/controllers/users_controller.js","webpack:///./src/db.js","webpack:///./src/deferred.js","webpack:///./src/dynamic-require.js","webpack:///./src/ec-crypto.ts","webpack:///./src/iso-639/index.js","webpack:///./src/jwt-middleware.js","webpack:///./src/log-timestamps.js","webpack:///./src/mdns-server.js","webpack:///./src/models/action.js","webpack:///./src/models/actions.js","webpack:///./src/models/event.js","webpack:///./src/models/events.js","webpack:///./src/models/jsonwebtoken.js","webpack:///./src/models/logs.js","webpack:///./src/models/oauthclients.ts","webpack:///./src/models/settings.js","webpack:///./src/models/thing.js","webpack:///./src/models/things.js","webpack:///./src/models/user.js","webpack:///./src/models/users.js","webpack:///./src/oauth-types.ts","webpack:///./src/passwords.js","webpack:///./src/platform.js","webpack:///./src/plugin/adapter-proxy.js","webpack:///./src/plugin/api-handler-proxy.js","webpack:///./src/plugin/device-proxy.js","webpack:///./src/plugin/notifier-proxy.js","webpack:///./src/plugin/outlet-proxy.js","webpack:///./src/plugin/plugin-server.js","webpack:///./src/plugin/plugin.js","webpack:///./src/plugin/property-proxy.js","webpack:///./src/push-service.js","webpack:///./src/router-setup.js","webpack:///./src/router.js","webpack:///./src/rules-engine/APIError.js","webpack:///./src/rules-engine/Database.js","webpack:///./src/rules-engine/DatabaseMigrate.js","webpack:///./src/rules-engine/Engine.js","webpack:///./src/rules-engine/Events.js","webpack:///./src/rules-engine/Property.js","webpack:///./src/rules-engine/Rule.js","webpack:///./src/rules-engine/effects/ActionEffect.js","webpack:///./src/rules-engine/effects/Effect.js","webpack:///./src/rules-engine/effects/MultiEffect.js","webpack:///./src/rules-engine/effects/NotificationEffect.js","webpack:///./src/rules-engine/effects/NotifierOutletEffect.js","webpack:///./src/rules-engine/effects/PropertyEffect.js","webpack:///./src/rules-engine/effects/PulseEffect.js","webpack:///./src/rules-engine/effects/SetEffect.js","webpack:///./src/rules-engine/effects/index.js","webpack:///./src/rules-engine/index.js","webpack:///./src/rules-engine/triggers/BooleanTrigger.js","webpack:///./src/rules-engine/triggers/EqualityTrigger.js","webpack:///./src/rules-engine/triggers/EventTrigger.js","webpack:///./src/rules-engine/triggers/LevelTrigger.js","webpack:///./src/rules-engine/triggers/MultiTrigger.js","webpack:///./src/rules-engine/triggers/PropertyTrigger.js","webpack:///./src/rules-engine/triggers/TimeTrigger.js","webpack:///./src/rules-engine/triggers/Trigger.js","webpack:///./src/rules-engine/triggers/index.js","webpack:///./src/sleep.js","webpack:///./src/ssltunnel.js","webpack:///./src/user-profile.js","webpack:///./src/utils.js","webpack:///./src/wifi-setup.js","webpack:///external \"acme-client\"","webpack:///external \"ajv\"","webpack:///external \"archiver\"","webpack:///external \"asn1.js\"","webpack:///external \"assert\"","webpack:///external \"bcryptjs\"","webpack:///external \"body-parser\"","webpack:///external \"callsites\"","webpack:///external \"child_process\"","webpack:///external \"compression\"","webpack:///external \"config\"","webpack:///external \"country-list\"","webpack:///external \"crypto\"","webpack:///external \"events\"","webpack:///external \"express\"","webpack:///external \"express-fileupload\"","webpack:///external \"express-handlebars\"","webpack:///external \"express-promise-router\"","webpack:///external \"express-rate-limit\"","webpack:///external \"express-ws\"","webpack:///external \"find\"","webpack:///external \"fs\"","webpack:///external \"gateway-addon\"","webpack:///external \"glob-to-regexp\"","webpack:///external \"http\"","webpack:///external \"http-proxy\"","webpack:///external \"https\"","webpack:///external \"ip-regex\"","webpack:///external \"jsonwebtoken\"","webpack:///external \"mkdirp\"","webpack:///external \"ncp\"","webpack:///external \"nocache\"","webpack:///external \"node-fetch\"","webpack:///external \"node-getopt\"","webpack:///external \"os\"","webpack:///external \"path\"","webpack:///external \"process\"","webpack:///external \"promisepipe\"","webpack:///external \"readline\"","webpack:///external \"rimraf\"","webpack:///external \"segfault-handler\"","webpack:///external \"semver\"","webpack:///external \"speakeasy\"","webpack:///external \"sqlite3\"","webpack:///external \"stream\"","webpack:///external \"string-format\"","webpack:///external \"tar\"","webpack:///external \"tmp\"","webpack:///external \"url\"","webpack:///external \"util\"","webpack:///external \"uuid\"","webpack:///external \"web-push\"","webpack:///external \"winston\"","webpack:///external \"winston-daily-rotate-file\"","webpack:///external \"ws\""],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC5CA;AACA;;AAEA;AACA;AACA;;AAEA,OAAO,YAAY,GAAG,mBAAO,CAAC,sBAAQ;AACtC,yBAAyB,mBAAO,CAAC,4EAAoB;;AAErD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB,WAAW,IAAI,yBAAyB,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,oDAAoD;AACnE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gCAAgC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+FAA+F,+BAA+B;AAC9H,OAAO;AACP,oFAAoF,sBAAsB;AAC1G,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kFAAkF,0BAA0B;AAC5G;AACA,OAAO;AACP,wEAAwE,6BAA6B;AACrG;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sGAAsG,+BAA+B;AACrI;AACA,OAAO;AACP,6EAA6E,+BAA+B;AAC5G;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gEAAgE,6BAA6B;AAC7F;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL,yFAAyF,wCAAwC;AACjI;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,mFAAmF,gBAAgB;AACnG;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,mFAAmF,8BAA8B;AACjH,OAAO;AACP,mFAAmF,qBAAqB;AACxG,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,+DAA+D,4BAA4B;AAC3F;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,sEAAsE,8BAA8B;AACpG;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,mFAAmF,2CAA2C;AAC9H;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,wFAAwF,gDAAgD;AACxI;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,wFAAwF,gDAAgD;AACxI;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,iFAAiF,yCAAyC;AAC1H;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,6FAA6F,qDAAqD;AAClJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,sFAAsF,8CAA8C;AACpI;AACA;AACA;AACA;AACA,KAAK;AACL,sEAAsE,8BAA8B;AACpG;AACA;AACA;AACA;AACA,KAAK;AACL,sEAAsE,8BAA8B;AACpG;AACA;AACA;AACA;AACA,KAAK;AACL,qEAAqE,6BAA6B;AAClG;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,+FAA+F,wBAAwB;AACvH;AACA,OAAO;AACP,sEAAsE,wBAAwB;AAC9F;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oGAAoG,6BAA6B;AACjI;AACA,OAAO;AACP,2EAA2E,6BAA6B;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uHAAuH;AAClI,SAAS,iBAAiB;AAC1B,WAAW,kDAAkD;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,0BAA0B,6BAA6B;AACvD,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,gBAAgB;AAC/E;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,gBAAgB;AACrF;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0JAA0J;AACrK,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD,qBAAqB,aAAa,WAAW,gBAAgB;AAC7D;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD,qBAAqB,aAAa,WAAW,gBAAgB;AAC7D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,eAAe,YAAY;AAC3B,+BAA+B,qCAAqC,IAAI;AACxE,gCAAgC,sBAAsB,IAAI;AAC1D;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,4BAA4B;AAC3C,8BAA8B,qCAAqC,IAAI;AACvE,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,aAAa,eAAe;AAC5B,4BAA4B,qCAAqC,IAAI;AACrE,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC,WAAW,oBAAoB;AAC/B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,kCAAkC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,yBAAyB,sBAAsB;AAC/C;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,eAAe,yBAAyB,YAAY,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA,8BAA8B;AAC9B,KAAK;AACL,8BAA8B;AAC9B,KAAK;AACL;AACA;AACA;AACA,qDAAqD,EAAE;AACvD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,uBAAuB,eAAe,EAAE;AACvD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACloCA,cAAc,mBAAO,CAAC,gDAAG;;AAEzB,0CAA0C;AAC1C;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,gD;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,mBAAmB,mBAAO,CAAC,2CAAe;AAC1C,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,kBAAkB,mBAAO,CAAC,uCAAa;AACvC,iBAAiB,mBAAO,CAAC,qCAAY;AACrC,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,iBAAiB,mBAAO,CAAC,qCAAY;AACrC,iBAAiB,mBAAO,CAAC,mDAAmB;AAC5C,oBAAoB,mBAAO,CAAC,6CAAgB;AAC5C,cAAc,mBAAO,CAAC,+BAAS;AAC/B,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,YAAY,mBAAO,CAAC,gBAAK;AACzB,WAAW,mBAAO,CAAC,cAAI;AACvB,oBAAoB,mBAAO,CAAC,gCAAa;AACzC,cAAc,mBAAO,CAAC,8BAAY;AAClC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,OAAO,gBAAgB,GAAG,mBAAO,CAAC,gBAAK;AACvC,OAAO,IAAI,GAAG,mBAAO,CAAC,gBAAK;;AAE3B,YAAY,mBAAO,CAAC,uCAAiB;;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,QAAQ;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,QAAQ;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,QAAQ;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,QAAQ;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,UAAU;AACpC,uCAAuC,UAAU;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,YAAY;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8DAA8D,SAAS;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,YAAY;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAO,CAAC,6DAAwB;;AAEnD,gDAAgD,eAAe;;AAE/D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,QAAQ;AACzD,SAAS;AACT;AACA,KAAK;;AAEL,QAAQ,IAA+B;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;AACA,mEAAmE;AACnE,uCAAuC,YAAY,EAAE,SAAS;AAC9D,4CAA4C,GAAG;;AAE/C,mCAAmC,IAAI,MAAM,SAAS;;AAEtD;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;;AAEA;AACA;AACA,KAAK;AACL,wBAAwB,YAAY;AACpC;AACA,0DAA0D,SAAS,IAAI,EAAE;AACzE;AACA,OAAO;AACP,oDAAoD,GAAG,IAAI,EAAE;AAC7D;;AAEA;AACA,wBAAwB,YAAY;AACpC;AACA,0DAA0D,SAAS,IAAI,EAAE;AACzE;AACA,OAAO;AACP,4DAA4D,GAAG;AAC/D;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,sBAAsB,YAAY;AAClC;AACA,wDAAwD,SAAS,IAAI,EAAE;AACvE;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD,YAAY;AAClE;;AAEA,oCAAoC,YAAY;;AAEhD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,oDAAoD,EAAE;AACtD;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,gBAAgB;AACzB;AACA;AACA,8CAA8C,IAAI;AAClD,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,iDAAiD,UAAU,IAAI,EAAE;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,wCAAwC,UAAU,aAAa,EAAE;AACjE;AACA;;AAEA;;AAEA;AACA,gBAAgB,qBAAa;AAC7B;AACA,eAAe,qBAAa;AAC5B;AACA,KAAK;;AAEL;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA,qCAAqC,UAAU,IAAI,EAAE;AACrD,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,wCAAwC,IAAI,GAAG,kBAAkB;AACjE;AACA;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,gDAAgD,QAAQ,IAAI,EAAE;AAC9D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,0DAA0D,YAAY,IAAI,EAAE;AAC5E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA,+CAA+C,aAAa,IAAI,EAAE;AAClE;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,8CAA8C,QAAQ,IAAI,EAAE;AAC5D;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;;ACn3CA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,cAAI;AACvB,YAAY,mBAAO,CAAC,uCAAiB;AACrC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,oBAAoB,mBAAO,CAAC,6CAAgB;AAC5C,cAAc,mBAAO,CAAC,+BAAS;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,OAAO,EAAE,IAAI;AACzC,6BAA6B,WAAW,iBAAiB;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO,EAAE,IAAI;AAC/D,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,SAAS;AACT;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qCAAqC,OAAO,EAAE,IAAI;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iDAAiD,UAAU,IAAI,EAAE;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,mDAAmD,UAAU,IAAI,EAAE;AACnE;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,0BAA0B,cAAc;AAClE,OAAO,mCAAmC,iBAAiB;AAC3D;AACA;;AAEA;AACA;AACA,2CAA2C,YAAY;AACvD,gDAAgD,UAAU;AAC1D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,SAAS,sBAAsB,UAAU;AAC/D;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,kDAAkD,UAAU,IAAI,EAAE;AAClE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,MAAM,aAAa,UAAU;AACzE;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,MAAM,aAAa,UAAU;AACrE;AACA;AACA,OAAO;AACP,KAAK,UAAU,IAA+B;AAC9C,4DAA4D,UAAU;AACtE;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C,UAAU,IAAI,IAAI;AAC9D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,YAAY,iCAAiC;AACxE,SAAS,uBAAuB,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY,kCAAkC;AACzE,SAAS,uBAAuB,UAAU;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD,UAAU;AAC5D;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA,oBAAoB,mBAAO,CAAC,6CAAgB;AAC5C;AACA;;AAEA;AACA,mBAAO,CAAC,iDAAkB;;AAE1B;AACA,cAAc,mBAAO,CAAC,oBAAO;AAC7B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,cAAI;AACvB,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,kBAAkB,mBAAO,CAAC,8BAAY;AACtC,mBAAmB,mBAAO,CAAC,8CAAoB;AAC/C,mBAAmB,mBAAO,CAAC,gCAAa;AACxC,eAAe,mBAAO,CAAC,gCAAa;AACpC,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,0BAA0B,mBAAO,CAAC,8CAAoB;AACtD,gBAAgB,mBAAO,CAAC,0BAAU;AAClC,wBAAwB,mBAAO,CAAC,0CAAkB;;AAElD;AACA,qBAAqB,mBAAO,CAAC,+CAAiB;AAC9C,kBAAkB,mBAAO,CAAC,uCAAa;AACvC,WAAW,mBAAO,CAAC,yBAAM;AACzB,mBAAmB,mBAAO,CAAC,2CAAe;AAC1C,aAAa,mBAAO,CAAC,2CAAe;AACpC,iBAAiB,mBAAO,CAAC,qCAAY;AACrC,eAAe,mBAAO,CAAC,iCAAU;AACjC,cAAc,mBAAO,CAAC,+BAAS;AAC/B,eAAe,mBAAO,CAAC,+CAAiB;AACxC,sBAAsB,mBAAO,CAAC,uCAAa;AAC3C,OAAO,mCAAmC,GAAG,mBAAO,CAAC,6CAAgB;AACrE,OAAO,+BAA+B,GAAG,mBAAO,CAAC,yCAAc;;AAE/D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,mBAAO,CAAC,yDAAsB;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B,iBAAiB;;AAE/C;AACA;AACA,sBAAsB,KAAK;AAC3B;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH,2BAA2B,aAAa;;AAExC;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,yBAAyB;AACpC,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClbA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,gCAAa;AAClC,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,cAAc,mBAAO,CAAC,8BAAY;AAClC,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,iBAAiB,mBAAO,CAAC,mDAAmB;AAC5C,cAAc,mBAAO,CAAC,+BAAS;AAC/B,OAAO,gBAAgB,GAAG,mBAAO,CAAC,gBAAK;AACvC,oBAAoB,mBAAO,CAAC,6CAAgB;;AAE5C,cAAc,MAAK,KAAK,aAAoB;;AAE5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,SAAS,aAAa,kBAAkB;AACpE;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,SAAS,YAAY,kBAAkB;AAC5D;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,SAAS,aAAa,kBAAkB;AAC5E;AACA,4DAA4D,gBAAgB;AAC5E;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,GAAG;AACxB,qBAAqB,EAAE;;AAEvB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,SAAS,aAAa,kBAAkB;AAC5E;AACA,4DAA4D,gBAAgB;AAC5E;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;;AAEA,oBAAoB,iBAAiB,GAAG,+BAA+B;;AAEvE;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,GAAG;AACxB,qBAAqB,EAAE;;AAEvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC7VA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,eAAe,mBAAO,CAAC,gDAAkB;AACzC,gBAAgB,mBAAO,CAAC,kDAAmB;AAC3C,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,eAAe,mBAAO,CAAC,gDAAkB;;AAEzC,yCAAyC,kBAAkB;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,sCAAsC;AACrE,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,sCAAsC;AACrE,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uCAAuC;AACtE,GAAG;AACH,6BAA6B,SAAS;AACtC;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;;;;;;;;;;;;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,qBAAqB,mBAAO,CAAC,gDAAkB;;AAE/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,0CAA0C,UAAU;AACpD;AACA,CAAC;;AAED;;;;;;;;;;;;;ACzCa;;AAEb,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,iBAAiB,mBAAO,CAAC,oDAAoB;AAC7C,oBAAoB,mBAAO,CAAC,8CAAiB;AAC7C,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,iBAAiB;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,+BAA+B,QAAQ;AACvC,GAAG;AACH,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,+BAA+B,QAAQ;;AAEvC;AACA;AACA,0CAA0C;AAC1C,GAAG;AACH,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,QAAQ;;AAEvC;AACA;AACA,GAAG;AACH,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,OAAO;AACtC,GAAG;AACH,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,GAAG;AAC7B;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,GAAG;AAC7B;AACA;AACA,GAAG;AACH,8CAA8C,GAAG,IAAI,EAAE;AACvD;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,iDAAiD,QAAQ,IAAI,EAAE;AAC/D;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,qBAAqB,mBAAO,CAAC,gDAAkB;;AAE/C;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,yCAAyC,SAAS;AAClD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,6BAA6B,SAAS;AACtC;AACA,2CAA2C,SAAS,EAAE,MAAM;AAC5D,KAAK;AACL,GAAG;AACH,yCAAyC,SAAS;AAClD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,yCAAyC,SAAS;AAClD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,+BAA+B,SAAS;AACxC;AACA,6CAA6C,SAAS,IAAI,MAAM;AAChE,OAAO;AACP,KAAK;AACL,2CAA2C;AAC3C,OAAO,cAAc;AACrB,OAAO;AACP;AACA,GAAG;AACH,yCAAyC,SAAS;AAClD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,wCAAwC,QAAQ;AAChD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,0CAA0C,QAAQ,GAAG,MAAM;AAC3D,KAAK;AACL,GAAG;AACH,wCAAwC,QAAQ;AAChD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,8BAA8B,QAAQ;AACtC;AACA,4CAA4C,QAAQ,GAAG,MAAM;AAC7D,OAAO;AACP,KAAK;AACL,0CAA0C;AAC1C,OAAO,cAAc;AACrB,OAAO;AACP;AACA,GAAG;AACH,wCAAwC,QAAQ;AAChD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD,GAAG;AACH;AACA,2CAA2C,QAAQ,WAAW,IAAI;AAClE,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;ACtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,eAAe,mBAAO,CAAC,gDAAkB;;AAEzC,yCAAyC,kBAAkB;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;AC1Ca;;AAEb,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,OAAO,WAAW,GAAG,mBAAO,CAAC,oCAAe;AAC5C,oBAAoB,mBAAO,CAAC,8CAAiB;AAC7C,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,WAAW,mBAAO,CAAC,cAAI;AACvB,qBAAqB,mBAAO,CAAC,sCAAgB;AAC7C,sBAAsB,mBAAO,CAAC,kDAAmB;AACjD,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA;;AAEA;AACA;AACA,gBAAgB,2CAA2C;AAC3D,gCAAgC;AAChC,8BAA8B;AAC9B,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,iBAAiB,mBAAO,CAAC,0BAAU;AACnC,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,kBAAkB,mBAAO,CAAC,cAAI;;AAE9B,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,sBAAsB,mBAAO,CAAC,kDAAmB;AACjD,oBAAoB,mBAAO,CAAC,8CAAiB;AAC7C,cAAc,mBAAO,CAAC,gCAAU;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,oBAAoB,6BAA6B,SAAS,yBAAyB,OAAO,IAAI,IAAI;AAClG;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2BAA2B;AACzD;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sDAAwB;;AAE/C,qBAAqB,mBAAO,CAAC,4DAAwB;;AAErD;;AAEA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA,8BAA8B;AAC9B,CAAC;;AAED;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,eAAe,mBAAO,CAAC,sDAAwB;AAC/C,cAAc,mBAAO,CAAC,8CAAiB;AACvC,qBAAqB,mBAAO,CAAC,4DAAwB;AACrD,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,kBAAkB,mBAAO,CAAC,8CAAoB;;AAE9C;;AAEA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD,CAAC;;AAED;AACA;AACA;AACA;AACA,SAAS,KAAK;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,IAAI;AACjC,CAAC;;AAED;;;;;;;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,kBAAkB,mBAAO,CAAC,cAAI;;AAE9B,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,aAAa,mBAAO,CAAC,4CAAgB;;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,oDAAoD,UAAU;AAC9D;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA,iDAAiD,EAAE;AACnD;AACA,CAAC;;AAED;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA,GAAG;AACH,0DAA0D,GAAG;AAC7D,4BAA4B,MAAM;AAClC;AACA;AACA,CAAC;;AAED;AACA,KAAK,sBAAsB,WAAW,0BAA0B;AAChE;AACA,KAAK,sBAAsB,WAAW,0BAA0B;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,mDAAmD,EAAE;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,cAAc,mBAAO,CAAC,8BAAY;AAClC,kBAAkB,mBAAO,CAAC,cAAI;AAC9B,eAAe,mBAAO,CAAC,gDAAkB;;AAEzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,sEAAsE,MAAM;AAC5E;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,sEAAsE,MAAM;AAC5E,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,UAAU,4BAA4B;;AAExE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;AC5Fa;;AAEb,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,OAAO,kBAAkB,GAAG,mBAAO,CAAC,oCAAe;AACnD,sBAAsB,mBAAO,CAAC,sDAAwB;;AAEtD;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,2CAA2C,WAAW;AACtD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA,yCAAyC,SAAS,iBAAiB,WAAW;AAC9E;AACA;AACA,SAAS,sBAAsB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,uBAAuB;AAC7E;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;;AC9EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmC;AACT;AAE1B,MAAM,YAAY,GAAG,mBAAO,CAAC,4DAAwB,CAAC,CAAC;AACvD,MAAM,MAAM,GAAG,mBAAO,CAAC,sBAAQ,CAAC,CAAC;AAIT;AAE0B;AACC;AACT;AAE1C,MAAM,IAAI,GAAG,0DAAwB,EAAE,CAAC;AAExC,MAAM,eAAe,GAAG,8CAAc,EAAE,CAAC;AA4EzC,SAAS,QAAQ,CAAC,QAA0B,EAAE,OAAY,EAAE,MAA4B;IACtF,IAAI,GAAG,GAAG,IAAI,uCAAG,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC;IACtC,KAAK,IAAI,GAAG,IAAI,MAAM,EAAE;QACtB,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;YAC/B,SAAS;SACV;QACD,IAAI,OAAO,MAAM,CAAC,GAAG,CAAC,KAAK,WAAW,EAAE;YACtC,GAAG,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;SACnD;KACF;IACD,IAAI,GAAG,CAAC,QAAQ,KAAK,mBAAmB,EAAE;QACxC,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,+BAA+B,EAAE,EAAE,CAAC,CAAC,CAAC;QAC/E,OAAO;KACR;IACD,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC;AACpC,CAAC;AAED,SAAS,YAAY,CAAC,OAAqB,EAAE,QAA0B;IAErE,IAAI,MAAM,GAAG,4DAAY,CAAC,GAAG,CAAC,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,YAAY,CAAC,CAAC;IACvE,IAAI,CAAC,MAAM,EAAE;QACX,IAAI,GAAG,GAAsC;YAC3C,KAAK,EAAE,qBAAqB;YAC5B,iBAAiB,EAAE,mBAAmB;YACtC,KAAK,EAAE,OAAO,CAAC,KAAK;SACrB,CAAC;QAEF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO,IAAI,CAAC;KACb;IAED,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE;QACzB,OAAO,CAAC,YAAY,GAAG,MAAM,CAAC,YAAY,CAAC;KAC5C;IAED,IAAI,OAAO,CAAC,YAAa,CAAC,QAAQ,EAAE,KAAK,MAAM,CAAC,YAAY,CAAC,QAAQ,EAAE,EAAE;QACvE,IAAI,GAAG,GAAkC;YACvC,KAAK,EAAE,iBAAiB;YACxB,iBAAiB,EAAE,yBAAyB;YAC5C,KAAK,EAAE,OAAO,CAAC,KAAK;SACrB,CAAC;QAEF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO,IAAI,CAAC;KACb;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,SAAS,iBAAiB,CAAC,OAAwB,EAAE,QAA0B;IAE7E,IAAI,aAAa,GAAG,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC;IAClD,IAAI,CAAC,aAAa,EAAE;QAClB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,EAAE;YAC3B,OAAO;SACR;QACD,OAAO;YACL,QAAQ,EAAE,OAAO,CAAC,IAAI,CAAC,SAAS;YAChC,YAAY,EAAE,OAAO,CAAC,IAAI,CAAC,aAAa;SACzC,CAAC;KACH;IAED,IAAI,OAAO,aAAa,KAAK,QAAQ,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;QAC5E,IAAI,GAAG,GAAsC;YAC3C,KAAK,EAAE,qBAAqB;YAC5B,iBAAiB,EAAE,2CAA2C;SAC/D,CAAC;QAEF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO;KACR;IAED,IAAI,WAAW,GAAG,aAAa,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;IAC3D,IAAI,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC,QAAQ,EAAE,CAAC;IAE7D,IAAI,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAChC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;QACtB,IAAI,GAAG,GAAsC;YAC3C,KAAK,EAAE,qBAAqB;YAC5B,iBAAiB,EAAE,2CAA2C;SAC/D,CAAC;QAEF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO;KACR;IAED,OAAO;QACL,QAAQ,EAAE,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QAC5D,YAAY,EAAE,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;KACjE,CAAC;AACJ,CAAC;AAED,SAAS,0BAA0B,CAAC,WAAiC,EACjC,QAA0B;IAE5D,IAAI,MAAM,GAAG,YAAY,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;IACjD,IAAI,CAAC,MAAM,EAAE;QACX,OAAO;KACR;IAED,IAAI,WAAW,CAAC,aAAa,KAAK,MAAM,EAAE;QACxC,IAAI,GAAG,GAA+B;YACpC,KAAK,EAAE,2BAA2B;YAClC,KAAK,EAAE,WAAW,CAAC,KAAK;SACzB,CAAC;QACF,QAAQ,CACN,QAAQ,EACR,MAAM,CAAC,YAAY,EACnB,GAAG,CACJ,CAAC;QACF,OAAO;KACR;IAED,IAAI,CAAC,qEAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,WAAW,CAAC,KAAK,CAAC,EAAE;QACtD,IAAI,GAAG,GAA+B;YACpC,KAAK,EAAE,eAAe;YACtB,iBAAiB,EAAE,6CAA6C;YAChE,KAAK,EAAE,WAAW,CAAC,KAAK;SACzB,CAAC;QACF,QAAQ,CACN,QAAQ,EACR,MAAM,CAAC,YAAY,EACnB,GAAG,CACJ,CAAC;QACF,OAAO;KACR;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,eAAe,CAAC,GAAG,CAAC,YAAY,EAAE,KAAK,EAAE,OAAwB,EAAE,QAA0B,EAAE,EAAE;IAC/F,IAAI,YAAY,CAAC;IACjB,IAAI,OAAO,CAAC,KAAK,CAAC,YAAY,EAAE;QAC9B,YAAY,GAAG,IAAI,uCAAG,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC;KACzD;IAGD,IAAI,WAAW,GAAyB;QACtC,aAAa,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC,aAAa,EAAE;QAC/C,SAAS,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC,SAAS,EAAE;QACvC,YAAY,EAAE,YAAY;QAC1B,KAAK,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE;QAC/B,KAAK,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE;KAChC,CAAC;IAEF,IAAI,MAAM,GAAG,0BAA0B,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;IAC/D,IAAI,CAAC,MAAM,EAAE;QACX,OAAO;KACR;IAED,QAAQ,CAAC,MAAM,CAAC,WAAW,EAAE;QAC3B,IAAI,EAAE,MAAM,CAAC,IAAI;QACjB,MAAM,EAAE,MAAM,CAAC,YAAY,CAAC,IAAI;QAChC,OAAO,EAAE,WAAW;KACrB,CAAC,CAAC;AACL,CAAC,CAAC,CAAC;AAEH,eAAe,CAAC,GAAG,CAAC,sBAAsB,EAAE,KAAK,EAAE,OAAwB,EAAE,QAA0B,EAAE,EAAE;IACzG,IAAI,WAAW,GAAmB,4DAAY,CAAC,GAAG,CAAC,aAAa,EAAE,SAAS,CAAE,CAAC;IAC9E,IAAI,YAAY,GAAuB;QACrC,UAAU,EAAE,oBAAoB;QAChC,IAAI,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE;QAC7B,YAAY,EAAE,WAAW,CAAC,YAAY;QACtC,SAAS,EAAE,WAAW,CAAC,EAAE;KAC1B,CAAC;IACF,OAAO,CAAC,IAAI,GAAG,YAAY,CAAC;IAC5B,OAAO,CAAC,OAAO,CAAC,aAAa,GAAG,QAAQ;QACtC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,GAAG,GAAG,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAC5E,IAAI,KAAK,GAAG,MAAM,wBAAwB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IAC9D,IAAI,KAAK,EAAE;QACT,QAAQ,CAAC,MAAM,CAAC,qBAAqB,EAAE;YACrC,cAAc,EAAE,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC;YAC5C,KAAK,EAAE,KAAK,CAAC,YAAY;SAC1B,CAAC,CAAC;KACJ;AACH,CAAC,CAAC,CAAC;AAEH,eAAe,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,OAAwB,EAAE,QAA0B,EAAE,EAAE;IACjG,IAAI,YAAY,CAAC;IACjB,IAAI,OAAO,CAAC,KAAK,CAAC,YAAY,EAAE;QAC9B,YAAY,GAAG,IAAI,uCAAG,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC;KACzD;IAED,IAAI,WAAW,GAAyB;QACtC,aAAa,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC,aAAa,EAAE;QAC/C,SAAS,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC,SAAS,EAAE;QACvC,YAAY,EAAE,YAAY;QAC1B,KAAK,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE;QAC/B,KAAK,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE;KAChC,CAAC;IAEF,IAAI,MAAM,GAAG,0BAA0B,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;IAC/D,IAAI,CAAC,MAAM,EAAE;QACX,OAAO;KACR;IAED,IAAI,GAAG,GAAI,OAAe,CAAC,GAAG,CAAC;IAC/B,IAAI,CAAC,GAAG,EAAE;QACR,OAAO;KACR;IAED,IAAI,CAAC,GAAG,CAAC,OAAO,IAAI,GAAG,CAAC,OAAO,CAAC,IAAI,KAAK,YAAY,EAAE;QACrD,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,mCAAmC,CAAC,CAAC;QAC/D,OAAO;KACR;IAGD,IAAI,IAAI,GAAG,MAAM,YAAY,CAAC,eAAe,CAAC,MAAM,EAAE,GAAG,CAAC,IAAI,EAAE;QAC9D,IAAI,EAAE,oBAAoB;QAC1B,KAAK,EAAE,WAAW,CAAC,KAAK;KACzB,CAAC,CAAC;IAEH,IAAI,OAAO,GAAiC;QAC1C,IAAI,EAAE,IAAI;QACV,KAAK,EAAE,WAAW,CAAC,KAAK;KACzB,CAAC;IAEF,QAAQ,CACN,QAAQ,EACR,MAAM,CAAC,YAAY,EACnB,OAAO,CACR,CAAC;AACJ,CAAC,CAAC,CAAC;AAEH,eAAe,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,OAAwB,EAAE,QAA0B,EAAE,EAAE;IAC5F,MAAM,WAAW,GAAG,OAAO,CAAC,IAAI,CAAC;IACjC,IAAI,WAAW,CAAC,UAAU,KAAK,oBAAoB,EAAE;QACnD,IAAI,KAAK,GAAG,MAAM,wBAAwB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;QAC9D,IAAI,KAAK,EAAE;YACT,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACtB;QACD,OAAO;KACR;IAID,IAAI,GAAG,GAA6B;QAClC,KAAK,EAAE,wBAAwB;QAC/B,KAAK,EAAE,WAAW,CAAC,KAAK;KACzB,CAAC;IACF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC;AAMH,KAAK,UAAU,wBAAwB,CAAC,OAAwB,EAAE,QAA0B;IAE1F,MAAM,WAAW,GAAG,OAAO,CAAC,IAAI,CAAC;IACjC,IAAI,aAAa,GAAG,iBAAiB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IACzD,IAAI,CAAC,aAAa,EAAE;QAClB,IAAI,GAAG,GAAsC;YAC3C,KAAK,EAAE,qBAAqB;YAC5B,iBAAiB,EAAE,kCAAkC;SACtD,CAAC;QAEF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO;KACR;IAED,IAAI,YAAY,GAAuB;QACrC,UAAU,EAAE,WAAW,CAAC,UAAU;QAClC,IAAI,EAAE,WAAW,CAAC,IAAI;QACtB,YAAY,EAAE,WAAW,CAAC,YAAY,IAAI,IAAI,uCAAG,CAAC,WAAW,CAAC,YAAY,CAAC;QAC3E,SAAS,EAAE,aAAa,CAAC,QAAQ;KAClC,CAAC;IAEF,IAAI,MAAM,GAAG,YAAY,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAC;IAClD,IAAI,CAAC,MAAM,EAAE;QACX,OAAO;KACR;IAED,IAAI,MAAM,CAAC,EAAE,KAAK,aAAa,CAAC,QAAQ;QACpC,MAAM,CAAC,MAAM,KAAK,aAAa,CAAC,YAAY,EAAE;QAChD,IAAI,GAAG,GAAsC;YAC3C,KAAK,EAAE,qBAAqB;YAC5B,iBAAiB,EAAE,sBAAsB;SAC1C,CAAC;QAEF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO;KACR;IAED,IAAI,SAAS,GAAG,MAAM,YAAY,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;IAChE,IAAI,CAAC,SAAS,EAAE;QACd,IAAI,GAAG,GAA6B;YAClC,KAAK,EAAE,eAAe;YACtB,iBAAiB,EAAE,yBAAyB;YAC5C,KAAK,EAAE,OAAO,CAAC,IAAI,CAAC,KAAK;SAC1B,CAAC;QAEF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO;KACR;IAED,IAAI,OAAO,GAAG,SAAS,CAAC,OAAO,CAAC;IAChC,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,IAAI,KAAK,oBAAoB,IAAI,OAAO,CAAC,SAAS,KAAK,MAAM,CAAC,EAAE,EAAE;QACxF,IAAI,GAAG,GAA6B;YAClC,KAAK,EAAE,eAAe;YACtB,KAAK,EAAE,OAAO,CAAC,IAAI,CAAC,KAAK;SAC1B,CAAC;QAEF,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO;KACR;IAED,IAAI,WAAW,GAAG,MAAM,YAAY,CAAC,eAAe,CAAC,MAAM,EAAE,SAAS,CAAC,IAAI,EAAE;QAC3E,IAAI,EAAE,uDAAsB;QAC5B,KAAK,EAAE,SAAS,CAAC,OAAO,CAAC,KAAK;KAC/B,CAAC,CAAC;IAIH,IAAI,GAAG,GAA+B;QACpC,YAAY,EAAE,WAAW;QACzB,UAAU,EAAE,QAAQ;QAEpB,KAAK,EAAE,MAAM,CAAC,KAAK;KACpB,CAAC;IAEF,OAAO,GAAG,CAAC;AACb,CAAC;AAEc,8EAAe,EAAC;;;;;;;;;;;;;ACha/B;AAAA;AAAa;AAIb,MAAM,aAAa,GAAG,mBAAO,CAAC,sDAAwB,CAAC,CAAC;AACN;AAGlD,MAAM,sBAAsB,GAAG,aAAa,EAAE,CAAC;AAK/C,sBAAsB,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,EAAE,OAAwB,EAAE,QAA0B,EAAE,EAAE;IAC7F,IAAI,IAAI,GAAI,OAAe,CAAC,GAAG,CAAC,IAAI,CAAC;IACrC,IAAI,OAAO,GAAG,MAAM,4DAAY,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAErD,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAsB,EAAE,EAAE;QACnD,OAAO,MAAM,CAAC,cAAc,EAAE,CAAC;IACjC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC,CAAC;AAEH,sBAAsB,CAAC,MAAM,CAAC,YAAY,EAAE,KAAK,EAAE,OAAwB,EAAE,QAA0B,EAAE,EAAE;IACzG,IAAI,QAAQ,GAAG,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC;IACvC,IAAI,CAAC,4DAAY,CAAC,GAAG,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE;QAC1C,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;QAC9C,OAAO;KACR;IACD,IAAI,IAAI,GAAI,OAAe,CAAC,GAAG,CAAC,IAAI,CAAC;IAErC,MAAM,4DAAY,CAAC,yBAAyB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAC7D,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AAC3B,CAAC,CAAC,CAAC;AAEY,qFAAsB,EAAC;;;;;;;;;;;;;AC5CtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,wBAAS;;AAEjC;;AAEA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,kBAAkB,mBAAO,CAAC,8BAAY;AACtC,eAAe,mBAAO,CAAC,sDAAwB;;AAE/C;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,6BAA6B;AAC7D,CAAC;;AAED;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,oBAAoB,mBAAO,CAAC,8CAAiB;;AAE7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8BAA8B;AAChE;AACA;AACA,6BAA6B,2BAA2B;AACxD,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH,wDAAwD,aAAa;AACrE,+BAA+B,yBAAyB;AACxD;AACA;AACA,8BAA8B;AAC9B,CAAC;;AAED;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,sBAAsB,mBAAO,CAAC,wCAAc;;AAE5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,2BAA2B,mBAAO,CAAC,4DAAwB;AAC3D,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,cAAc,mBAAO,CAAC,8BAAY;AAClC,WAAW,mBAAO,CAAC,cAAI;AACvB,kBAAkB,mBAAO,CAAC,gDAAkB;AAC5C,sBAAsB,mBAAO,CAAC,kDAAmB;AACjD,mBAAmB,mBAAO,CAAC,4CAAgB;AAC3C,aAAa,mBAAO,CAAC,kBAAM;AAC3B,YAAY,mBAAO,CAAC,0CAAoB;AACxC,iBAAiB,mBAAO,CAAC,sCAAa;AACtC,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,iBAAiB,mBAAO,CAAC,oDAAoB;AAC7C,sBAAsB,mBAAO,CAAC,wCAAc;;AAE5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA,iCAAiC,gBAAgB;AACjD,KAAK;AACL,yDAAyD,eAAe;AACxE;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA;AACA,OAAO;AACP,mCAAmC,gBAAgB;AACnD;AACA,KAAK;AACL,yDAAyD,eAAe;AACxE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB;AACnB,KAAK,gBAAgB,UAAU;AAC/B,gCAAgC;AAChC,GAAG;AACH;AACA,0DAA0D,EAAE;AAC5D;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,wBAAwB,UAAU,GAAG,+BAA+B;AACpE;;AAEA;AACA;AACA,8DAA8D,IAAI;AAClE;AACA,KAAK;AACL;AACA,wBAAwB,UAAU,GAAG,+BAA+B;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,gCAAgC;AAChC,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,SAAS,KAAK,OAAO,SAAS,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,iDAAiD,IAAI;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA,kCAAkC;AAClC,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA,mBAAmB,wCAAwC;AAC3D,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kCAAkC;AAClC,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,+BAA+B;AAChD,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,+BAA+B;AAChD,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,eAAe;AACpC,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,IAAI;AACrD,OAAO;AACP;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;;AAEA;;;;;;;;;;;;;ACvoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,gDAAkB;AACzC,gBAAgB,mBAAO,CAAC,kDAAmB;AAC3C,0BAA0B,mBAAO,CAAC,qEAAsB;AACxD,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,yBAAyB,mBAAO,CAAC,mEAAqB;AACtD,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,iBAAiB,mBAAO,CAAC,oDAAoB;AAC7C,eAAe,mBAAO,CAAC,gDAAkB;AACzC,kBAAkB,mBAAO,CAAC,cAAI;;AAE9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO;AACP;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,6CAA6C,QAAQ,IAAI,EAAE;AAC3D;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qDAAqD,QAAQ,IAAI,EAAE;AACnE;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,6DAA6D,GAAG;AAChE;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8CAA8C,KAAK;AACnD;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,iCAAiC,uBAAuB;;AAExD;AACA;AACA;AACA,iCAAiC,sBAAsB;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,GAAG;AACH,wDAAwD,QAAQ,IAAI,EAAE;AACtE;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,0DAA0D,QAAQ,IAAI,EAAE;AACxE;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,0DAA0D,QAAQ,IAAI,EAAE;AACxE;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,0DAA0D,QAAQ,IAAI,EAAE;AACxE;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,wDAAwD,QAAQ,IAAI,EAAE;AACtE;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA,KAAK;AACL,0DAA0D,QAAQ,IAAI,EAAE;AACxE,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,IAAI;AAC3D;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,kBAAkB;AAClB,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,gDAAgD,KAAK;AACrD,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC,SAAS;AACT,OAAO;AACP;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,GAAG;AAC/B;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oBAAoB;AACjE;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;AC/rBa;;AAEb,qBAAqB,mBAAO,CAAC,oCAAe;AAC5C,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,WAAW,mBAAO,CAAC,cAAI;AACvB,cAAc,mBAAO,CAAC,8BAAY;AAClC,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,iBAAiB,mBAAO,CAAC,sCAAa;AACtC,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,cAAc,mBAAO,CAAC,gCAAU;;AAEhC,YAAY,mBAAO,CAAC,0CAAoB;;AAExC;;AAEA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sDAAsD,gBAAgB;AACtE;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,UAAU,cAAc;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK,UAAU;AACf;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;;AAEA,kBAAkB;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,8BAA8B;AAC7D,GAAG;AACH;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,oBAAoB,mBAAO,CAAC,8CAAiB;;AAE7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,+CAA+C,IAAI;AACnD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,wEAAwE,IAAI;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,mDAAmD,IAAI;AACvD;;AAEA;AACA,yCAAyC,MAAM;AAC/C;;AAEA;AACA,GAAG;AACH,CAAC;;AAED;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,sBAAsB,mBAAO,CAAC,sDAAwB;AACtD,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,cAAc,mBAAO,CAAC,8CAAiB;AACvC,qBAAqB,mBAAO,CAAC,4DAAwB;AACrD,sBAAsB,mBAAO,CAAC,kDAAmB;AACjD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,MAAM;AAC1C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B;AAC9B,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,oBAAoB,mBAAO,CAAC,6CAAgB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,MAAK,KAAK,aAAoB;;AAE5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,MAAM;AACN,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA,4EAA4E;AAC5E,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,QAAQ,GAAG,IAAI;AACrC,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,WAAW;AACX,yCAAyC,WAAW;AACpD,yBAAyB;AACzB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA,WAAW,MAAM;AACjB;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW,MAAM;AACjB;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,KAAK;AAClB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,aAAa;AAC1B,cAAc,gBAAgB;AAC9B;AACA;AACA,WAAW,0CAA0C;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,KAAK;AACL,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,cAAc,gBAAgB;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,qCAAqC,EAAE;AACvC,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,aAAa,WAAW;AACxB,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;;;;;;;;;;;;;AChnBA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA,aAAa,OAAuB;AACpC;AACA,WAAW,OAAuB;AAClC;AACA,SAAS,2CAAO;AAChB,CAAC;;;;;;;;;;;;;ACJD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAa;AAEmB;AACC;AASjC,MAAM,KAAK,GAAG,YAAY,CAAC;AAG3B,MAAM,eAAe,GAAG,8CAAW,CAAC,cAAc,EAAE;IAClD,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,CACZ,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,GAAG,EAAE,EACzB,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,MAAM,EAAE,EAC/B,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,EACrD,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,CACtD,CAAC;AACJ,CAAC,CAAC,CAAC;AAGH,MAAM,uBAAuB,GAAG,8CAAW,CAAC,sBAAsB,EAAE;IAClE,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,CACZ,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAC7B,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EACtB,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,KAAK,EAAE,CAC/B,EACD,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,MAAM,EAAE,CACzB;AACH,CAAC,CAAC,CAAC;AAIH,MAAM,yBAAyB,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAE3D,MAAM,eAAe,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAS7C,SAAS,eAAe;IAC7B,MAAM,GAAG,GAAG,iDAAiB,CAAC,KAAK,CAAC,CAAC;IACrC,GAAG,CAAC,YAAY,EAAE,CAAC;IAEnB,MAAM,IAAI,GAAG,eAAe,CAAC,MAAM,CAAC;QAClC,OAAO,EAAE,CAAC;QACV,UAAU,EAAE,GAAG,CAAC,aAAa,EAAE;QAC/B,UAAU,EAAE,eAAe;KAC5B,EAAE,KAAK,EAAE;QAER,KAAK,EAAE,gBAAgB;KACxB,CAAC,CAAC;IAEH,MAAM,GAAG,GAAG,uBAAuB,CAAC,MAAM,CAAC;QACzC,GAAG,EAAE;YACH,MAAM,EAAE,CAAC;YACT,IAAI,EAAE,GAAG,CAAC,YAAY,EAAE;SACzB;QACD,SAAS,EAAE;YACT,EAAE,EAAE,yBAAyB;YAC7B,UAAU,EAAE,eAAe;SAC5B;KACF,EAAE,KAAK,EAAE;QACR,KAAK,EAAE,YAAY;KACpB,CAAC,CAAC;IAEH,OAAO,EAAE,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;AACxC,CAAC;AAEM,MAAM,aAAa,GAAG,OAAO,CAAC;;;;;;;;;;;;;ACxFrC;AACA;AACA;;AAEa;;AAEb,WAAW,mBAAO,CAAC,cAAI;AACvB,OAAO,QAAQ,GAAG,mBAAO,CAAC,kCAAc;AACxC,cAAc,mBAAO,CAAC,gEAAoB;AAC1C,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,2CAA2C;AAC1E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,cAAc,KAAK,IAAI,YAAY;AACnC;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,kBAAkB,mBAAO,CAAC,uCAAa;AACvC,qBAAqB,mBAAO,CAAC,2DAAuB;;AAEpD;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,aAAa;AACzB;AACA;AACA,SAAS,cAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB,GAAG,oBAAoB;AACjE;AACA;AACA;AACA,6BAA6B,iBAAiB,sBAAsB,MAAM;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,wBAAwB,mBAAO,CAAC,4DAA2B;AAC3D,oBAAoB,mBAAO,CAAC,6CAAgB;AAC5C,eAAe,mBAAO,CAAC,kBAAM;;AAE7B;AACA;AACA;AACA,sBAAsB,eAAe,GAAG,MAAM,IAAI,aAAa;AAC/D;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;;AAED;AACA;AACA,YAAY,uBAAuB;AACnC,SAAS,wBAAwB,aAAa;AAC9C,SAAS,mBAAmB,aAAa;AACzC,SAAS,oBAAoB,aAAa;AAC1C,SAAS,sBAAsB,aAAa;AAC5C,SAAS,sBAAsB,aAAa;AAC5C,UAAU,2BAA2B,aAAa;AAClD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAO,CAAC,4BAAW;;AAEzC;AACA;AACA,wBAAwB,mBAAmB,GAAG,qBAAqB;AACnE,mBAAmB,6CAA6C;AAChE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,iBAAiB,mBAAO,CAAC,mDAAmB;;AAE5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,kDAAmB;AAC3C,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,OAAO,MAAM,GAAG,mBAAO,CAAC,oCAAe;;AAEvC;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,WAAW,EAAE,uBAAuB,GAAG,KAAK,GAAG,QAAQ;AAC5E;AACA,KAAK;AACL,qBAAqB,uBAAuB,GAAG,KAAK,GAAG,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,gDAAkB;AACzC,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,qBAAqB,mBAAO,CAAC,sBAAQ;;AAErC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,cAAc,cAAc;AAC5B;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL,cAAc;AACd,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL,cAAc;AACd,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD,YAAY;AACrE;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,GAAG;AACrC;;AAEA;AACA;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D;AACA,SAAS;AACT;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,OAAO,MAAM,GAAG,mBAAO,CAAC,oCAAe;;AAEvC;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,gDAAkB;;AAEzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL,cAAc;AACd,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL,cAAc;AACd,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,OAAO,WAAW,GAAG,mBAAO,CAAC,kBAAM;AACnC,YAAY,mBAAO,CAAC,kCAAc;AAClC,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B,WAAW,mBAAO,CAAC,wCAAc;AACjC,iBAAiB,mBAAO,CAAC,0BAAO;AAChC,iBAAiB,mBAAO,CAAC,4CAAY;;AAErC;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,WAAW,IAAI;;AAEf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,cAAc,OAAO;AACrB;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,cAAc,6BAA6B;AAC3C,cAAc,OAAO;AACrB;AACA;AACA,WAAW,WAAW;AACtB;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA,uCAAuC,sBAAsB;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA,WAAW,iCAAiC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACpKA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,gBAAgB,mBAAO,CAAC,wBAAS;;AAEjC,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,oBAAoB,mBAAO,CAAC,8CAAiB;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,MAAM;AAC3C,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,MAAM;AACxD;AACA;AACA,cAAc;AACd,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,MAAM;AAC3C;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,MAAM;AACrD;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,cAAc;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,MAAM;AAC7C;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,WAAW;AACxB,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;;;ACnbA;AAAA;AAAA;AAAA;AAAa;AAEa;AACqC;AAC/D,MAAM,MAAM,GAAG,mBAAO,CAAC,sBAAQ,CAAC,CAAC;AACjC,MAAM,QAAQ,GAAG,mBAAO,CAAC,0BAAO,CAAC,CAAC;AAGlC,MAAM,YAAY;IAEhB;QADQ,YAAO,GAAuC,IAAI,GAAG,EAAE,CAAC;IAEhE,CAAC;IAED,QAAQ,CAAC,MAAsB;QAC7B,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE;YAC/B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SAC3C;aAAM;YACL,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;SACvC;IACH,CAAC;IAED,GAAG,CAAC,EAAU,EAAE,WAA0B;QACxC,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACrC,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO;SACR;QACD,IAAI,CAAC,WAAW,EAAE;YAChB,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC;SACnB;QACD,KAAK,IAAI,MAAM,IAAI,OAAO,EAAE;YAC1B,IAAI,MAAM,CAAC,YAAY,CAAC,IAAI,KAAK,WAAW,CAAC,IAAI,EAAE;gBACjD,OAAO,MAAM,CAAC;aACf;SACF;QACD,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC;IACpB,CAAC;IAED,KAAK,CAAC,aAAa,CAAC,MAAc;QAChC,IAAI,IAAI,GAAG,MAAM,QAAQ,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;QACzD,IAAI,UAAU,GAAG,IAAI,GAAG,EAAE,CAAC;QAE3B,KAAK,IAAI,GAAG,IAAI,IAAI,EAAE;YACpB,IAAI,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YACtC,IAAI,OAAO,CAAC,IAAI,KAAK,cAAc,EAAE;gBACnC,SAAS;aACV;YACD,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;gBACxC,OAAO,CAAC,IAAI,CAAC,uBAAuB,EAAE,GAAG,CAAC,CAAC;gBAC3C,MAAM,QAAQ,CAAC,yBAAyB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBACpD,SAAS;aACV;YACD,MAAM,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,SAAS,CAAE,CAAC,CAAC,CAAC,CAAC;YAC9D,IAAI,CAAC,aAAa,EAAE;gBAClB,SAAS;aACV;YACD,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;SAClD;QAED,OAAO,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,CAAC;IACzC,CAAC;IAED,KAAK,CAAC,yBAAyB,CAAC,MAAc,EAAE,QAAgB;QAC9D,IAAI,IAAI,GAAG,MAAM,QAAQ,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;QAEzD,KAAK,IAAI,GAAG,IAAI,IAAI,EAAE;YACpB,IAAI,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YACtC,IAAI,OAAO,CAAC,SAAS,KAAK,QAAQ,EAAE;gBAClC,MAAM,QAAQ,CAAC,yBAAyB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;aACrD;SACF;IACH,CAAC;CACF;AAED,IAAI,YAAY,GAAG,IAAI,YAAY,EAAE,CAAC;AAEtC,IAAI,MAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,EAAE;IAClC,YAAY,CAAC,QAAQ,CACnB,IAAI,2DAAc,CAAC,IAAI,uCAAG,CAAC,iCAAiC,CAAC,EAAE,MAAM,EAClD,mBAAmB,EAAE,cAAc,EAAE,mBAAmB,CAAC,CAC7E,CAAC;IAEF,YAAY,CAAC,QAAQ,CACnB,IAAI,2DAAc,CAAC,IAAI,uCAAG,CAAC,oCAAoC,CAAC,EAAE,MAAM,EACrD,mBAAmB,EAAE,cAAc,EAAE,mBAAmB,CAAC,CAC7E,CAAC;IAEF,YAAY,CAAC,QAAQ,CACnB,IAAI,2DAAc,CAAC,IAAI,uCAAG,CAAC,gCAAgC,CAAC,EAAE,SAAS,EACpD,SAAS,EAAE,6BAA6B,EAAE,mBAAmB,CAAC,CAClF,CAAC;CACH;AAED,YAAY,CAAC,QAAQ,CACnB,IAAI,2DAAc,CAAC,IAAI,uCAAG,CAAC,qDAAqD,CAAC,EAAE,aAAa,EAC7E,qBAAqB,EAAE,cAAc,EACrC,mBAAmB,CAAC,CACxC,CAAC;AAEF,YAAY,CAAC,QAAQ,CACnB,IAAI,2DAAc,CAAC,IAAI,uCAAG,CAAC,yCAAyC,CAAC,EAAE,SAAS,EAC7D,SAAS,EAAE,6BAA6B,EAAE,mBAAmB,CAAC,CAClF,CAAC;AAEF,YAAY,CAAC,QAAQ,CACnB,IAAI,2DAAc,CAAC,IAAI,uCAAG,CAAC,8CAA8C,CAAC,EAAE,SAAS,EAClE,SAAS,EAAE,6BAA6B,EAAE,mBAAmB,CAAC,CAClF,CAAC;AAEa,2EAAY,EAAC;;;;;;;;;;;;;AC5G5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,iBAAiB,mBAAO,CAAC,0BAAO;AAChC,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,cAAc,MAAK,KAAK,aAAoB;;AAE5C;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA,GAAG;AACH;AACA,uCAAuC,sBAAsB;AAC7D;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,YAAY;AACtE,uCAAuC,+BAA+B;AACtE;AACA,mBAAmB,YAAY,GAAG,+BAA+B;AACjE,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yEAAyE,IAAI;AAC7E;AACA;;AAEA,0CAA0C,eAAe;AACzD,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,iBAAiB,mBAAO,CAAC,0BAAO;AAChC,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,eAAe,mBAAO,CAAC,kCAAW;AAClC,oBAAoB,mBAAO,CAAC,8CAAiB;AAC7C,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,YAAY,mBAAO,CAAC,gBAAK;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB,GAAG,4BAA4B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B,qBAAqB,GAAG,4BAA4B,EAAE,UAAU;AAC7F;;AAEA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,UAAU,EAAE,0BAA0B,GAAG,iCAAiC;AAC7F,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B,OAAO;AACP;AACA;AACA,iBAAiB,UAAU;AAC3B,OAAO;AACP;AACA;AACA,iBAAiB,UAAU;AAC3B,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,qBAAqB,GAAG,4BAA4B,EAAE,UAAU;AAC7F,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,qBAAqB,GAAG,4BAA4B,EAAE,UAAU;AAC3F;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,qBAAqB,GAAG,4BAA4B,EAAE,UAAU;AAC3F;;AAEA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,UAAU,EAAE,uBAAuB,GAAG,+BAA+B;AACtF,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,qBAAqB,GAAG,4BAA4B,EAAE,UAAU;AAC3F;;AAEA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,UAAU,EAAE,sBAAsB,GAAG,8BAA8B;AACpF,OAAO;AACP;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6DAA6D,UAAU;AACvE;AACA;AACA,OAAO;;AAEP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,yBAAyB,KAAK,QAAQ,EAAE,UAAU;AACnE;;AAEA;;AAEA,mBAAmB,6BAA6B,KAAK,QAAQ,EAAE,UAAU;AACzE,qBAAqB,6BAA6B,KAAK,QAAQ;AAC/D;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B,KAAK,QAAQ,EAAE,qBAAqB;AAC7F,oBAAoB,6BAA6B,KAAK,QAAQ,EAAE,qBAAqB;AACrF;AACA,eAAe,UAAU;AACzB;AACA,eAAe,sBAAsB;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B,qBAAqB,GAAG,4BAA4B,EAAE,UAAU;AAC7F;;AAEA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,UAAU,EAAE,0BAA0B,GAAG,iCAAiC;AAC7F,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,qBAAqB,GAAG,4BAA4B,EAAE,UAAU;AAC3F;;AAEA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,UAAU,EAAE,uBAAuB,GAAG,+BAA+B;AACtF,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,qBAAqB,GAAG,4BAA4B,EAAE,UAAU;AAC3F;;AAEA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,UAAU,EAAE,sBAAsB,GAAG,8BAA8B;AACpF,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,qBAAqB,GAAG,4BAA4B,EAAE,UAAU;AAC7F,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,qBAAqB,GAAG,4BAA4B,EAAE,UAAU;AAC3F;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACprBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,YAAY,mBAAO,CAAC,gBAAK;AACzB,qBAAqB,mBAAO,CAAC,sBAAQ;;AAErC,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,iBAAiB,mBAAO,CAAC,0BAAO;AAChC,eAAe,mBAAO,CAAC,kCAAW;AAClC,cAAc,mBAAO,CAAC,sCAAS;AAC/B,kBAAkB,mBAAO,CAAC,wCAAc;;AAExC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,MAAM,MAAM;AACZ,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB,GAAG,sCAAsC;AAC7E;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD,sDAAsD;AACtD,0CAA0C;AAC1C,iDAAiD;AACjD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,KAAK,gBAAgB;AACrB,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,KAAK,gBAAgB;AACrB,GAAG;;AAEH;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,yDAAyD,GAAG;AAC5D;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,eAAe;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0DAA0D,MAAM;AAChE,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED,uCAAuC,kBAAkB;AACzD;AACA,CAAC;;AAED;;;;;;;;;;;;;ACpbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,iBAAiB,mBAAO,CAAC,0BAAO;AAChC,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,kBAAkB,mBAAO,CAAC,4BAAW;;AAErC;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,oCAAQ;AAC7B,iBAAiB,mBAAO,CAAC,0BAAO;;AAEhC;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,KAAK;AAClB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;AC/HA;AAAA;AAAA;AAAA;AAAA;AAAa;AAG4B;AAUlC,MAAM,cAAc;IACzB,YAAmB,YAAiB,EAAS,EAAY,EAAS,IAAY,EAC3D,MAAc,EAAS,KAAe;QADtC,iBAAY,GAAZ,YAAY,CAAK;QAAS,OAAE,GAAF,EAAE,CAAU;QAAS,SAAI,GAAJ,IAAI,CAAQ;QAC3D,WAAM,GAAN,MAAM,CAAQ;QAAS,UAAK,GAAL,KAAK,CAAU;IACzD,CAAC;IAED,cAAc;QACZ,OAAO;YACL,EAAE,EAAE,IAAI,CAAC,EAAE;YACX,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,YAAY,EAAE,IAAI,CAAC,YAAY;YAC/B,KAAK,EAAE,IAAI,CAAC,KAAK;SAClB,CAAC;IACJ,CAAC;CACF;AAED,SAAS,aAAa,CAAC,QAAkB;IACvC,IAAI,KAAK,GAAU,EAAE,CAAC;IACtB,IAAI,UAAU,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACrC,KAAK,IAAI,SAAS,IAAI,UAAU,EAAE;QAChC,IAAI,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACjC,IAAI,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACpB,IAAI,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACzB,IAAI,SAAS,KAAK,MAAM,IAAI,SAAS,KAAK,WAAW,EAAE;YACrD,SAAS,GAAG,MAAM,CAAC;SACpB;QACD,KAAK,CAAC,IAAI,CAAC,GAAG,SAA+B,CAAC;KAC/C;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAEM,SAAS,gBAAgB,CAAC,cAAwB,EAAE,eAAyB;IAClF,IAAI,cAAc,KAAK,eAAe,EAAE;QACtC,OAAO,IAAI,CAAC;KACb;IACD,IAAI,WAAW,GAAG,aAAa,CAAC,cAAc,CAAC,CAAC;IAChD,IAAI,YAAY,GAAG,aAAa,CAAC,eAAe,CAAC,CAAC;IAElD,IAAI,CAAC,WAAW,IAAI,CAAC,YAAY,EAAE;QACjC,OAAO,KAAK,CAAC;KACd;IAED,KAAK,IAAI,WAAW,IAAI,YAAY,EAAE;QACpC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,sDAAqB,CAAC,EAAE;YAClD,OAAO,CAAC,IAAI,CAAC,yCAAyC,EAAE,eAAe,CAAC,CAAC;YACzE,OAAO,KAAK,CAAC;SACd;QACD,IAAI,aAAa,GAAG,YAAY,CAAC,WAAW,CAAC,CAAC;QAC9C,IAAI,MAA6B,CAAC;QAClC,IAAI,WAAW,CAAC,WAAW,CAAC,EAAE;YAC5B,MAAM,GAAG,WAAW,CAAC,WAAW,CAAC,CAAC;SACnC;aAAM;YACL,MAAM,GAAG,WAAW,CAAC,sDAAqB,CAAC,CAAC;SAC7C;QAED,IAAI,CAAC,MAAM,EAAE;YACX,OAAO,KAAK,CAAC;SACd;QAED,IAAI,aAAa,KAAK,WAAW,EAAE;YACjC,IAAI,MAAM,KAAK,WAAW,EAAE;gBAC1B,OAAO,KAAK,CAAC;aACd;SACF;KACF;IACD,OAAO,IAAI,CAAC;AACd,CAAC;;;;;;;;;;;;;AC/ED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,0BAAU;AACjC,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,kBAAkB,mBAAO,CAAC,4BAAW;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,gBAAgB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,iBAAiB;AAC/B;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,GAAG;AACH;;;;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,sBAAsB,mBAAO,CAAC,oCAAe;AAC7C,uBAAuB,mBAAO,CAAC,mDAAmB;AAClD,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,gBAAgB,mBAAO,CAAC,wBAAS;;AAEjC;AACA;AACA;AACA;AACA;AACA,kDAAkD,GAAG;AACrD;AACA;;AAEA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB,GAAG,aAAa;AAClE;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,OAAO,QAAQ,GAAG,mBAAO,CAAC,oCAAe;AACzC,iBAAiB,mBAAO,CAAC,sCAAa;AACtC,oBAAoB,mBAAO,CAAC,oDAAgB;AAC5C,OAAO,YAAY,GAAG,mBAAO,CAAC,oCAAe;;AAE7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+DAA+D;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,OAAO,WAAW,GAAG,mBAAO,CAAC,oCAAe;AAC5C,iBAAiB,mBAAO,CAAC,sCAAa;AACtC,OAAO,YAAY,GAAG,mBAAO,CAAC,oCAAe;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;;AAEA;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,kDAAmB;AAC3C,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,OAAO,iBAAiB,GAAG,mBAAO,CAAC,oCAAe;AAClD,cAAc,mBAAO,CAAC,8CAAiB;AACvC,eAAe,mBAAO,CAAC,gDAAkB;AACzC,OAAO,YAAY,GAAG,mBAAO,CAAC,oCAAe;AAC7C,sBAAsB,mBAAO,CAAC,wDAAkB;;AAEhD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,wBAAwB;AAC5E;AACA;;AAEA;;;;;;;;;;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,iBAAiB,mBAAO,CAAC,sCAAa;AACtC,OAAO,YAAY,GAAG,mBAAO,CAAC,oCAAe;AAC7C,OAAO,SAAS,GAAG,mBAAO,CAAC,oCAAe;AAC1C,oBAAoB,mBAAO,CAAC,oDAAgB;;AAE5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,OAAO,YAAY,GAAG,mBAAO,CAAC,oCAAe;AAC7C,OAAO,iBAAiB,GAAG,mBAAO,CAAC,oCAAe;;AAElD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,OAAO,UAAU,GAAG,mBAAO,CAAC,oCAAe;AAC3C,OAAO,YAAY,GAAG,mBAAO,CAAC,oCAAe;AAC7C,eAAe,mBAAO,CAAC,wCAAU;AACjC,YAAY,mBAAO,CAAC,0CAAoB;AACxC,iBAAiB,mBAAO,CAAC,oDAAoB;AAC7C,oBAAoB,mBAAO,CAAC,8CAAiB;;AAE7C;AACA,6BAA6B,QAAQ,KAAK;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,qBAAqB,mBAAO,CAAC,sDAAiB;AAC9C,wBAAwB,mBAAO,CAAC,8DAAqB;AACrD,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,WAAW,mBAAO,CAAC,0BAAO;AAC1B,iBAAiB,mBAAO,CAAC,sCAAa;AACtC,oBAAoB,mBAAO,CAAC,oDAAgB;AAC5C,eAAe,mBAAO,CAAC,oCAAe;AACtC,OAAO,YAAY,GAAG,mBAAO,CAAC,wCAAc;AAC5C,sBAAsB,mBAAO,CAAC,wDAAkB;AAChD,oBAAoB,mBAAO,CAAC,oDAAgB;AAC5C,aAAa,mBAAO,CAAC,kBAAM;AAC3B,iBAAiB,mBAAO,CAAC,0BAAU;AACnC,iBAAiB,mBAAO,CAAC,oDAAoB;AAC7C,cAAc,mBAAO,CAAC,oCAAe;AACrC,eAAe,mBAAO,CAAC,gDAAkB;AACzC,oBAAoB,mBAAO,CAAC,8CAAiB;AAC7C;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,oCAAe;;AAE3B;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA,yBAAyB,aAAa;AACtC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA,0BAA0B,aAAa;AACvC;;AAEA,wBAAwB,gBAAgB;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,0BAA0B,cAAc;;AAExC;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA,yDAAyD;AACzD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA,uBAAuB,eAAe,IAAI,KAAK;AAC/C,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA,yBAAyB,eAAe,IAAI,KAAK;AACjD,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;;AAEA;;;;;;;;;;;;;ACpuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,iBAAiB,mBAAO,CAAC,sCAAa;AACtC,OAAO,SAAS,GAAG,mBAAO,CAAC,oCAAe;AAC1C,OAAO,YAAY,GAAG,mBAAO,CAAC,oCAAe;;AAE7C;AACA;AACA;;AAEA;;AAEA;AACA,wCAAwC;AACxC;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,0BAAU;AAClC,iBAAiB,mBAAO,CAAC,mDAAmB;AAC5C,iBAAiB,mBAAO,CAAC,yBAAM;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;;AAEjC;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;AChEa;;AAEb,mBAAmB,mBAAO,CAAC,gCAAa;AACxC,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,kBAAkB,mBAAO,CAAC,uCAAa;AACvC,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,0BAA0B,mBAAO,CAAC,8CAAoB;AACtD,mBAAmB,mBAAO,CAAC,2CAAe;AAC1C,iBAAiB,mBAAO,CAAC,qCAAY;AACrC,iBAAiB,mBAAO,CAAC,mDAAmB;AAC5C,cAAc,mBAAO,CAAC,+BAAS;;AAE/B;;AAEA;AACA;AACA,8BAA8B,IAAI;AAClC,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,gBAAgB;;AAE/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,KAAK;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,GAAG;AACH;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qEAAqE,KAAK,GAAG,GAAG;AAChF,YAAY,KAAK,GAAG,GAAG;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sCAAsC,wBAAwB;AAC9D;AACA;AACA;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA,6CAA6C,iBAAiB;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,uDAAuD,cAAc;AACrE;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC9XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,oBAAoB,mBAAO,CAAC,gCAAa;AACzC,kBAAkB,mBAAO,CAAC,uCAAa;AACvC,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,sBAAsB,mBAAO,CAAC,iDAAkB;AAChD,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,oBAAoB,mBAAO,CAAC,6CAAgB;;AAE5C;;AAEA,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAO,CAAC,6EAAgC;;AAEnE;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,YAAY,mBAAO,CAAC,uFAAqC;AACzD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,YAAY,mBAAO,CAAC,6EAAgC;;AAEpD;AACA;AACA;AACA;;AAEA;AACA,eAAe,WAAW,KAAK,mBAAO,CAAC,2EAA+B;;AAEtE;AACA;AACA,YAAY,mBAAO,CAAC,6EAAgC;AACpD;AACA,YAAY,mBAAO,CAAC,mFAAmC;AACvD;AACA,YAAY,mBAAO,CAAC,6EAAgC;AACpD;AACA,YAAY,mBAAO,CAAC,2EAA+B;AACnD;AACA;AACA,cAAc,mBAAO,CAAC,6EAAgC;AACtD;;AAEA;AACA;AACA,YAAY,mBAAO,CAAC,+EAAiC;AACrD;AACA,YAAY,mBAAO,CAAC,uFAAqC;AACzD;AACA,YAAY,mBAAO,CAAC,mFAAmC;AACvD;AACA,YAAY,mBAAO,CAAC,iFAAkC;AACtD;AACA,YAAY,mBAAO,CAAC,+EAAiC;AACrD;AACA,YAAY,mBAAO,CAAC,iFAAkC;AACtD;AACA,YAAY,mBAAO,CAAC,iFAAkC;AACtD;AACA,YAAY,mBAAO,CAAC,iFAAkC;AACtD;AACA,YAAY,mBAAO,CAAC,+EAAiC;AACrD;AACA,YAAY,mBAAO,CAAC,yDAAsB;AAC1C;AACA,YAAY,mBAAO,CAAC,6FAAwC;AAC5D;AACA,YAAY,mBAAO,CAAC,2EAA+B;AACnD;AACA,YAAY,mBAAO,CAAC,2EAA+B;AACnD;AACA,YAAY,mBAAO,CAAC,qFAAoC;;AAExD;AACA,YAAY,mBAAO,CAAC,6EAAgC;AACpD;AACA,YAAY,mBAAO,CAAC,2FAAuC;AAC3D,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA,oCAAoC,aAAa;AACjD;;AAEA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;;AAEA;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,WAAW,mBAAO,CAAC,0BAAO;AAC1B,wBAAwB,mBAAO,CAAC,gEAAmB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,cAAc,sCAAsC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,gBAAgB;AAC7B,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACrGa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,MAAM,GAAG,QAAQ;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACnIA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,iBAAiB,mBAAO,CAAC,kDAAY;AACrC,aAAa,mBAAO,CAAC,0CAAQ;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA,8CAA8C,GAAG;AACjD;AACA;AACA;;AAEA;AACA;AACA,aAAa,KAAK;AAClB,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,KAAK;AAClB,cAAc;AACd;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,kBAAkB,mBAAO,CAAC,wCAAc;AACxC,eAAe,mBAAO,CAAC,gDAAkB;AACzC,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,eAAe,mBAAO,CAAC,8CAAU;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,aAAa,IAAI;AACjB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACxIA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,sDAAW;AACnC,iBAAiB,mBAAO,CAAC,wDAAY;AACrC,eAAe,mBAAO,CAAC,8CAAU;;AAEjC,cAAc,MAAK,KAAK,aAAoB;;AAE5C;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACtGA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B,eAAe,mBAAO,CAAC,mDAAqB;AAC5C,gBAAgB,mBAAO,CAAC,qDAAsB;AAC9C,qBAAqB,mBAAO,CAAC,mDAAqB;AAClD,eAAe,mBAAO,CAAC,sDAAU;AACjC,eAAe,mBAAO,CAAC,mDAAqB;;AAE5C;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sDAAU;;AAEjC;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA,4BAA4B,mBAAO,CAAC,oDAAS;;AAE7C;AACA;AACA,KAAK;AACL;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,sDAAU;AACjC,oBAAoB,mBAAO,CAAC,iDAAoB;;AAEhD;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,sDAAU;AACjC,qBAAqB,mBAAO,CAAC,mDAAqB;;AAElD;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA,8BAA8B,YAAY,iBAAiB,cAAc;AACzE;AACA;;AAEA;AACA,8BAA8B,YAAY,iBAAiB,cAAc;AACzE,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,iBAAiB,mBAAO,CAAC,mDAAa;AACtC,eAAe,mBAAO,CAAC,sDAAU;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,uBAAuB,mBAAO,CAAC,sEAAkB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,uBAAuB,mBAAO,CAAC,sEAAkB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA,UAAU,mBAAO,CAAC,sDAAU;AAC5B,gBAAgB,mBAAO,CAAC,kEAAgB;AACxC,eAAe,mBAAO,CAAC,gEAAe;AACtC,sBAAsB,mBAAO,CAAC,8EAAsB;AACpD,wBAAwB,mBAAO,CAAC,kFAAwB;AACxD,aAAa,mBAAO,CAAC,4DAAa;AAClC,eAAe,mBAAO,CAAC,gEAAe;AACtC;;AAEA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,YAAY;AACZ;AACA;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,sBAAsB,mBAAO,CAAC,sDAAwB;;AAEtD,iBAAiB,mBAAO,CAAC,kDAAY;AACrC,iBAAiB,mBAAO,CAAC,kDAAY;AACrC,eAAe,mBAAO,CAAC,8CAAU;AACjC,aAAa,mBAAO,CAAC,0CAAQ;;AAE7B;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,iBAAiB;AAC5B,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,YAAY,WAAW;AACvB,CAAC;;AAED;AACA;AACA;AACA,eAAe;AACf,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,eAAe;AACf,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,+CAAW;AAClC,wBAAwB,mBAAO,CAAC,yEAAmB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA,uCAAuC,2BAA2B;AAClE,KAAK;AACL,uCAAuC,4BAA4B;AACnE;AACA;AACA;;AAEA;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,+CAAW;AAClC,wBAAwB,mBAAO,CAAC,yEAAmB;;AAEnD;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;;AAEA,qCAAqC,yBAAyB;AAC9D;AACA;;AAEA;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,+CAAW;AAClC,eAAe,mBAAO,CAAC,mDAAqB;AAC5C,gBAAgB,mBAAO,CAAC,yDAAW;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,4BAA4B;AACjE,qCAAqC,6BAA6B;AAClE;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,+CAAW;AAClC,wBAAwB,mBAAO,CAAC,yEAAmB;;AAEnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,yBAAyB;AAC9D;AACA;;AAEA;;AAEA;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,+CAAW;AAClC,gBAAgB,mBAAO,CAAC,yDAAW;;AAEnC,cAAc,MAAK,KAAK,aAAoB;;AAE5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAO,CAAC,qDAAS;;AAE7C;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ,mBAAmB,aAAa,IAAI,MAAM,OAAO,YAAY;AAC7F;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;;AAEA;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,+CAAW;AAClC,gBAAgB,mBAAO,CAAC,yDAAW;AACnC,iBAAiB,mBAAO,CAAC,mDAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,+CAAW;AAClC,gBAAgB,mBAAO,CAAC,yDAAW;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,4BAA4B;AACjE;AACA;;AAEA;AACA,qCAAqC,6BAA6B;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,qBAAqB,mBAAO,CAAC,sBAAQ;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA,kBAAkB,mBAAO,CAAC,uEAAkB;AAC5C,mBAAmB,mBAAO,CAAC,yEAAmB;AAC9C,gBAAgB,mBAAO,CAAC,mEAAgB;AACxC,gBAAgB,mBAAO,CAAC,mEAAgB;AACxC,gBAAgB,mBAAO,CAAC,mEAAgB;AACxC,mBAAmB,mBAAO,CAAC,yEAAmB;AAC9C,eAAe,mBAAO,CAAC,iEAAe;AACtC,WAAW,mBAAO,CAAC,yDAAW;AAC9B;;AAEA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,YAAY;AACZ;AACA;AACA;AACA;AACA,2DAA2D,UAAU;AACrE;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCa;;AAEb;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,WAAW,mBAAO,CAAC,cAAI;AACvB,2BAA2B,mBAAO,CAAC,2DAAuB;AAC1D,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,iBAAiB,mBAAO,CAAC,qCAAY;AACrC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,8BAAY;AAClC,kBAAkB,mBAAO,CAAC,oCAAe;AACzC,iBAAiB,mBAAO,CAAC,mDAAmB;AAC5C,oBAAoB,mBAAO,CAAC,6CAAgB;AAC5C,oBAAoB,mBAAO,CAAC,6CAAgB;;AAE5C,cAAc,MAAK,KAAK,aAAoB;;AAE5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,uCAAuC;AAC9D;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,yCAAyC;AACzC;AACA;AACA,8CAA8C,SAAS;AACvD,mDAAmD;AACnD,2CAA2C;AAC3C,sBAAsB;AACtB,iDAAiD;AACjD,8CAA8C;AAC9C,qBAAqB,YAAY;;AAEjC;AACA;AACA,8CAA8C,KAAK;AACnD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,4CAA4C,KAAK;AACjD,SAAS;AACT;AACA,6DAA6D,KAAK;AAClE,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,SAAS;;AAE/C;AACA,uEAAuE;AACvE;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS,gBAAgB;AACzB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,mBAAmB,8CAA8C;AACjE,qBAAqB,uBAAuB;AAC5C;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;;;;;;;;;;;;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,cAAI;AACvB,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,OAAO,IAAI,GAAG,mBAAO,CAAC,gBAAK;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,KAA+B,EAAE,EAEpC;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,yBAAM;AAC7B,qBAAqB,mBAAO,CAAC,mDAAmB;AAChD,kBAAkB,mBAAO,CAAC,6CAAgB;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,2CAA2C,GAAG;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,IAA+B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;;AC5SA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,WAAW,mBAAO,CAAC,cAAI;AACvB,iBAAiB,mBAAO,CAAC,qCAAY;AACrC,YAAY,mBAAO,CAAC,uCAAiB;;AAErC;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;;AAEA;AACA,2BAA2B;AAC3B,0BAA0B;AAC1B,0BAA0B;AAC1B,4BAA4B;AAC5B,4BAA4B;AAC5B,GAAG;;AAEH;AACA,2CAA2C,YAAY;AACvD,0BAA0B,4BAA4B,GAAG,iBAAiB;AAC1E;;AAEA,cAAc,QAAQ,GAAG,UAAU,EAAE,SAAS;AAC9C,GAAG;AACH;;;;;;;;;;;;;ACzEa;;AAEb,mBAAmB,mBAAO,CAAC,gCAAa;AACxC,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,kBAAkB,mBAAO,CAAC,uCAAa;AACvC,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,0BAA0B,mBAAO,CAAC,8CAAoB;AACtD,mBAAmB,mBAAO,CAAC,2CAAe;AAC1C,WAAW,mBAAO,CAAC,cAAI;AACvB,iBAAiB,mBAAO,CAAC,qCAAY;AACrC,iBAAiB,mBAAO,CAAC,mDAAmB;AAC5C,cAAc,mBAAO,CAAC,+BAAS;;AAE/B;AACA;AACA,8BAA8B,IAAI;AAClC,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,gBAAgB;;AAE/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,GAAG;AACH;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA,OAAO;AACP;;AAEA,mCAAmC,SAAS;AAC5C,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,GAAG;AACH;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,YAAY,KAAK,GAAG,GAAG;AACvB;;AAEA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA,gDAAgD,oBAAoB;AACpE;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AC3cA,wC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,wC;;;;;;;;;;;ACAA,sC;;;;;;;;;;;ACAA,0C;;;;;;;;;;;ACAA,wC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,yC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,+C;;;;;;;;;;;ACAA,+C;;;;;;;;;;;ACAA,mD;;;;;;;;;;;ACAA,+C;;;;;;;;;;;ACAA,uC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,0C;;;;;;;;;;;ACAA,2C;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,uC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,yC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,uC;;;;;;;;;;;ACAA,wC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,wC;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,6C;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,sC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,0C;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,sD;;;;;;;;;;;ACAA,+B","file":"gateway.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/app.js\");\n","\n\nclass ResizeableBuffer{\n  constructor(size=100){\n    this.size = size\n    this.length = 0\n    this.buf = Buffer.alloc(size)\n  }\n  prepend(val){\n    const length = this.length++\n    if(length === this.size){\n      this.resize()\n    }\n    const buf = this.clone()\n    this.buf[0] = val\n    buf.copy(this.buf,1, 0, length)\n  }\n  append(val){\n    const length = this.length++\n    if(length === this.size){\n      this.resize()\n    }\n    this.buf[length] = val\n  }\n  clone(){\n    return Buffer.from(this.buf.slice(0, this.length))\n  }\n  resize(){\n    const length = this.length\n    this.size = this.size * 2\n    const buf = Buffer.alloc(this.size)\n    this.buf.copy(buf,0, 0, length)\n    this.buf = buf\n  }\n  toString(){\n    return this.buf.slice(0, this.length).toString()\n  }\n  toJSON(){\n    return this.toString()\n  }\n  reset(){\n    this.length = 0\n  }\n}\n\nmodule.exports = ResizeableBuffer\n","\n/*\nCSV Parse\n\nPlease look at the [project documentation](https://csv.js.org/parse/) for\nadditional information.\n*/\n\nconst { Transform } = require('stream')\nconst ResizeableBuffer = require('./ResizeableBuffer')\n\nconst tab = 9\nconst nl = 10\nconst np = 12\nconst cr = 13\nconst space = 32\nconst bom_utf8 = Buffer.from([239, 187, 191])\n\nclass Parser extends Transform {\n  constructor(opts = {}){\n    super({...{readableObjectMode: true}, ...opts})\n    const options = {}\n    // Merge with user options\n    for(let opt in opts){\n      options[underscore(opt)] = opts[opt]\n    }\n    // Normalize option `bom`\n    if(options.bom === undefined || options.bom === null || options.bom === false){\n      options.bom = false\n    }else if(options.bom !== true){\n      throw new CsvError('CSV_INVALID_OPTION_BOM', [\n        'Invalid option bom:', 'bom must be true,',\n        `got ${JSON.stringify(options.bom)}`\n      ])\n    }\n    // Normalize option `cast`\n    let fnCastField = null\n    if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){\n      options.cast = undefined\n    }else if(typeof options.cast === 'function'){\n      fnCastField = options.cast\n      options.cast = true\n    }else if(options.cast !== true){\n      throw new CsvError('CSV_INVALID_OPTION_CAST', [\n        'Invalid option cast:', 'cast must be true or a function,',\n        `got ${JSON.stringify(options.cast)}`\n      ])\n    }\n    // Normalize option `cast_date`\n    if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){\n      options.cast_date = false\n    }else if(options.cast_date === true){\n      options.cast_date = function(value){\n        const date = Date.parse(value)\n        return !isNaN(date) ? new Date(date) : value\n      }\n    }else if(typeof options.cast_date !== 'function'){\n      throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', [\n        'Invalid option cast_date:', 'cast_date must be true or a function,',\n        `got ${JSON.stringify(options.cast_date)}`\n      ])\n    }\n    // Normalize option `columns`\n    let fnFirstLineToHeaders = null\n    if(options.columns === true){\n      // Fields in the first line are converted as-is to columns\n      fnFirstLineToHeaders = undefined\n    }else if(typeof options.columns === 'function'){\n      fnFirstLineToHeaders = options.columns\n      options.columns = true\n    }else if(Array.isArray(options.columns)){\n      options.columns = normalizeColumnsArray(options.columns)\n    }else if(options.columns === undefined || options.columns === null || options.columns === false){\n      options.columns = false\n    }else{\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS', [\n        'Invalid option columns:',\n        'expect an object, a function or true,',\n        `got ${JSON.stringify(options.columns)}`\n      ])\n    }\n    // Normalize option `columns_duplicates_to_array`\n    if(options.columns_duplicates_to_array === undefined || options.columns_duplicates_to_array === null || options.columns_duplicates_to_array === false){\n      options.columns_duplicates_to_array = false\n    }else if(options.columns_duplicates_to_array !== true){\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', [\n        'Invalid option columns_duplicates_to_array:',\n        'expect an boolean,',\n        `got ${JSON.stringify(options.columns_duplicates_to_array)}`\n      ])\n    }\n    // Normalize option `comment`\n    if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){\n      options.comment = null\n    }else{\n      if(typeof options.comment === 'string'){\n        options.comment = Buffer.from(options.comment)\n      }\n      if(!Buffer.isBuffer(options.comment)){\n        throw new CsvError('CSV_INVALID_OPTION_COMMENT', [\n          'Invalid option comment:',\n          'comment must be a buffer or a string,',\n          `got ${JSON.stringify(options.comment)}`\n        ])\n      }\n    }\n    // Normalize option `delimiter`\n    const delimiter_json = JSON.stringify(options.delimiter)\n    if(!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter]\n    if(options.delimiter.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n        'Invalid option delimiter:',\n        'delimiter must be a non empty string or buffer or array of string|buffer,',\n        `got ${delimiter_json}`\n      ])\n    }\n    options.delimiter = options.delimiter.map(function(delimiter){\n      if(delimiter === undefined || delimiter === null || delimiter === false){\n        return Buffer.from(',')\n      }\n      if(typeof delimiter === 'string'){\n        delimiter = Buffer.from(delimiter)\n      }\n      if( !Buffer.isBuffer(delimiter) || delimiter.length === 0){\n        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n          'Invalid option delimiter:',\n          'delimiter must be a non empty string or buffer or array of string|buffer,',\n          `got ${delimiter_json}`\n        ])\n      }\n      return delimiter\n    })\n    // Normalize option `escape`\n    if(options.escape === undefined || options.escape === true){\n      options.escape = Buffer.from('\"')\n    }else if(typeof options.escape === 'string'){\n      options.escape = Buffer.from(options.escape)\n    }else if (options.escape === null || options.escape === false){\n      options.escape = null\n    }\n    if(options.escape !== null){\n      if(!Buffer.isBuffer(options.escape)){\n        throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`)\n      }else if(options.escape.length !== 1){\n        throw new Error(`Invalid Option Length: escape must be one character, got ${options.escape.length}`)\n      }else{\n        options.escape = options.escape[0]\n      }\n    }\n    // Normalize option `from`\n    if(options.from === undefined || options.from === null){\n      options.from = 1\n    }else{\n      if(typeof options.from === 'string' && /\\d+/.test(options.from)){\n        options.from = parseInt(options.from)\n      }\n      if(Number.isInteger(options.from)){\n        if(options.from < 0){\n          throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`)\n      }\n    }\n    // Normalize option `from_line`\n    if(options.from_line === undefined || options.from_line === null){\n      options.from_line = 1\n    }else{\n      if(typeof options.from_line === 'string' && /\\d+/.test(options.from_line)){\n        options.from_line = parseInt(options.from_line)\n      }\n      if(Number.isInteger(options.from_line)){\n        if(options.from_line <= 0){\n          throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`)\n      }\n    }\n    // Normalize option `info`\n    if(options.info === undefined || options.info === null || options.info === false){\n      options.info = false\n    }else if(options.info !== true){\n      throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`)\n    }\n    // Normalize option `max_record_size`\n    if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){\n      options.max_record_size = 0\n    }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0){\n      // Great, nothing to do\n    }else if(typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)){\n      options.max_record_size = parseInt(options.max_record_size)\n    }else{\n      throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`)\n    }\n    // Normalize option `objname`\n    if(options.objname === undefined || options.objname === null || options.objname === false){\n      options.objname = undefined\n    }else if(Buffer.isBuffer(options.objname)){\n      if(options.objname.length === 0){\n        throw new Error(`Invalid Option: objname must be a non empty buffer`)\n      }\n      options.objname = options.objname.toString()\n    }else if(typeof options.objname === 'string'){\n      if(options.objname.length === 0){\n        throw new Error(`Invalid Option: objname must be a non empty string`)\n      }\n      // Great, nothing to do\n    }else{\n      throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`)\n    }\n    // Normalize option `on_record`\n    if(options.on_record === undefined || options.on_record === null){\n      options.on_record = undefined\n    }else if(typeof options.on_record !== 'function'){\n      throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', [\n        'Invalid option `on_record`:',\n        'expect a function,',\n        `got ${JSON.stringify(options.on_record)}`\n      ])\n    }\n    // Normalize option `quote`\n    if(options.quote === null || options.quote === false || options.quote === ''){\n      options.quote = null\n    }else{\n      if(options.quote === undefined || options.quote === true){\n        options.quote = Buffer.from('\"')\n      }else if(typeof options.quote === 'string'){\n        options.quote = Buffer.from(options.quote)\n      }\n      if(!Buffer.isBuffer(options.quote)){\n        throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`)\n      }else if(options.quote.length !== 1){\n        throw new Error(`Invalid Option Length: quote must be one character, got ${options.quote.length}`)\n      }else{\n        options.quote = options.quote[0]\n      }\n    }\n    // Normalize option `raw`\n    if(options.raw === undefined || options.raw === null || options.raw === false){\n      options.raw = false\n    }else if(options.raw !== true){\n      throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`)\n    }\n    // Normalize option `record_delimiter`\n    if(!options.record_delimiter){\n      options.record_delimiter = []\n    }else if(!Array.isArray(options.record_delimiter)){\n      options.record_delimiter = [options.record_delimiter]\n    }\n    options.record_delimiter = options.record_delimiter.map( function(rd){\n      if(typeof rd === 'string'){\n        rd = Buffer.from(rd)\n      }\n      return rd\n    })\n    // Normalize option `relax`\n    if(typeof options.relax === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax === undefined || options.relax === null){\n      options.relax = false\n    }else{\n      throw new Error(`Invalid Option: relax must be a boolean, got ${JSON.stringify(options.relax)}`)\n    }\n    // Normalize option `relax_column_count`\n    if(typeof options.relax_column_count === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count === undefined || options.relax_column_count === null){\n      options.relax_column_count = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`)\n    }\n    if(typeof options.relax_column_count_less === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count_less === undefined || options.relax_column_count_less === null){\n      options.relax_column_count_less = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`)\n    }\n    if(typeof options.relax_column_count_more === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count_more === undefined || options.relax_column_count_more === null){\n      options.relax_column_count_more = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`)\n    }\n    // Normalize option `skip_empty_lines`\n    if(typeof options.skip_empty_lines === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){\n      options.skip_empty_lines = false\n    }else{\n      throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`)\n    }\n    // Normalize option `skip_lines_with_empty_values`\n    if(typeof options.skip_lines_with_empty_values === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null){\n      options.skip_lines_with_empty_values = false\n    }else{\n      throw new Error(`Invalid Option: skip_lines_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_lines_with_empty_values)}`)\n    }\n    // Normalize option `skip_lines_with_error`\n    if(typeof options.skip_lines_with_error === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_lines_with_error === undefined || options.skip_lines_with_error === null){\n      options.skip_lines_with_error = false\n    }else{\n      throw new Error(`Invalid Option: skip_lines_with_error must be a boolean, got ${JSON.stringify(options.skip_lines_with_error)}`)\n    }\n    // Normalize option `rtrim`\n    if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){\n      options.rtrim = false\n    }else if(options.rtrim !== true){\n      throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`)\n    }\n    // Normalize option `ltrim`\n    if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){\n      options.ltrim = false\n    }else if(options.ltrim !== true){\n      throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`)\n    }\n    // Normalize option `trim`\n    if(options.trim === undefined || options.trim === null || options.trim === false){\n      options.trim = false\n    }else if(options.trim !== true){\n      throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`)\n    }\n    // Normalize options `trim`, `ltrim` and `rtrim`\n    if(options.trim === true && opts.ltrim !== false){\n      options.ltrim = true\n    }else if(options.ltrim !== true){\n      options.ltrim = false\n    }\n    if(options.trim === true && opts.rtrim !== false){\n      options.rtrim = true\n    }else if(options.rtrim !== true){\n      options.rtrim = false\n    }\n    // Normalize option `to`\n    if(options.to === undefined || options.to === null){\n      options.to = -1\n    }else{\n      if(typeof options.to === 'string' && /\\d+/.test(options.to)){\n        options.to = parseInt(options.to)\n      }\n      if(Number.isInteger(options.to)){\n        if(options.to <= 0){\n          throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`)\n      }\n    }\n    // Normalize option `to_line`\n    if(options.to_line === undefined || options.to_line === null){\n      options.to_line = -1\n    }else{\n      if(typeof options.to_line === 'string' && /\\d+/.test(options.to_line)){\n        options.to_line = parseInt(options.to_line)\n      }\n      if(Number.isInteger(options.to_line)){\n        if(options.to_line <= 0){\n          throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`)\n      }\n    }\n    this.info = {\n      comment_lines: 0,\n      empty_lines: 0,\n      invalid_field_length: 0,\n      lines: 1,\n      records: 0\n    }\n    this.options = options\n    this.state = {\n      bomSkipped: false,\n      castField: fnCastField,\n      commenting: false,\n      enabled: options.from_line === 1,\n      escaping: false,\n      escapeIsQuote: options.escape === options.quote,\n      expectedRecordLength: options.columns === null ? 0 : options.columns.length,\n      field: new ResizeableBuffer(20),\n      firstLineToHeaders: fnFirstLineToHeaders,\n      info: Object.assign({}, this.info),\n      previousBuf: undefined,\n      quoting: false,\n      stop: false,\n      rawBuffer: new ResizeableBuffer(100),\n      record: [],\n      recordHasError: false,\n      record_length: 0,\n      recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map( (v) => v.length)),\n      trimChars: [Buffer.from(' ')[0], Buffer.from('\\t')[0]],\n      wasQuoting: false,\n      wasRowDelimiter: false\n    }\n  }\n  // Implementation of `Transform._transform`\n  _transform(buf, encoding, callback){\n    if(this.state.stop === true){\n      return\n    }\n    const err = this.__parse(buf, false)\n    if(err !== undefined){\n      this.state.stop = true\n    }\n    callback(err)\n  }\n  // Implementation of `Transform._flush`\n  _flush(callback){\n    if(this.state.stop === true){\n      return\n    }\n    const err = this.__parse(undefined, true)\n    callback(err)\n  }\n  // Central parser implementation\n  __parse(nextBuf, end){\n    const {bom, comment, escape, from_line, info, ltrim, max_record_size, quote, raw, relax, rtrim, skip_empty_lines, to, to_line} = this.options\n    let {record_delimiter} = this.options\n    const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state\n    let buf\n    if(previousBuf === undefined){\n      if(nextBuf === undefined){\n        // Handle empty string\n        this.push(null)\n        return\n      }else{\n        buf = nextBuf\n      }\n    }else if(previousBuf !== undefined && nextBuf === undefined){\n      buf = previousBuf\n    }else{\n      buf = Buffer.concat([previousBuf, nextBuf])\n    }\n    // Handle UTF BOM\n    if(bomSkipped === false){\n      if(bom === false){\n        this.state.bomSkipped = true\n      }else if(buf.length < 3){\n        // No enough data\n        if(end === false){\n          // Wait for more data\n          this.state.previousBuf = buf\n          return\n        }\n        // skip BOM detect because data length < 3\n      }else{\n        if(bom_utf8.compare(buf, 0, 3) === 0){\n          // Skip BOM\n          buf = buf.slice(3)\n        }\n        this.state.bomSkipped = true\n      }\n    }\n    const bufLen = buf.length\n    let pos\n    for(pos = 0; pos < bufLen; pos++){\n      // Ensure we get enough space to look ahead\n      // There should be a way to move this out of the loop\n      if(this.__needMoreData(pos, bufLen, end)){\n        break\n      }\n      if(this.state.wasRowDelimiter === true){\n        this.info.lines++\n        if(info === true && this.state.record.length === 0 && this.state.field.length === 0 && this.state.wasQuoting === false){\n          this.state.info = Object.assign({}, this.info)\n        }\n        this.state.wasRowDelimiter = false\n      }\n      if(to_line !== -1 && this.info.lines > to_line){\n        this.state.stop = true\n        this.push(null)\n        return\n      }\n      // Auto discovery of record_delimiter, unix, mac and windows supported\n      if(this.state.quoting === false && record_delimiter.length === 0){\n        const record_delimiterCount = this.__autoDiscoverRowDelimiter(buf, pos)\n        if(record_delimiterCount){\n          record_delimiter = this.options.record_delimiter\n        }\n      }\n      const chr = buf[pos]\n      if(raw === true){\n        rawBuffer.append(chr)\n      }\n      if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false ){\n        this.state.wasRowDelimiter = true\n      }\n      // Previous char was a valid escape char\n      // treat the current char as a regular char\n      if(this.state.escaping === true){\n        this.state.escaping = false\n      }else{\n        // Escape is only active inside quoted fields\n        // We are quoting, the char is an escape chr and there is a chr to escape\n        if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if(escapeIsQuote){\n            if(buf[pos+1] === quote){\n              this.state.escaping = true\n              continue\n            }\n          }else{\n            this.state.escaping = true\n            continue\n          }\n        }\n        // Not currently escaping and chr is a quote\n        // TODO: need to compare bytes instead of single char\n        if(this.state.commenting === false && chr === quote){\n          if(this.state.quoting === true){\n            const nextChr = buf[pos+1]\n            const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr)\n            // const isNextChrComment = nextChr === comment\n            const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+1, nextChr)\n            const isNextChrDelimiter = this.__isDelimiter(nextChr, buf, pos+1)\n            const isNextChrRowDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRowDelimiter(buf, pos+1) : this.__isRecordDelimiter(nextChr, buf, pos+1)\n            // Escape a quote\n            // Treat next char as a regular character\n            // TODO: need to compare bytes instead of single char\n            if(escape !== null && chr === escape && nextChr === quote){\n              pos++\n            }else if(!nextChr || isNextChrDelimiter || isNextChrRowDelimiter || isNextChrComment || isNextChrTrimable){\n              this.state.quoting = false\n              this.state.wasQuoting = true\n              continue\n            }else if(relax === false){\n              const err = this.__error(\n                new CsvError('CSV_INVALID_CLOSING_QUOTE', [\n                  'Invalid Closing Quote:',\n                  `got \"${String.fromCharCode(nextChr)}\"`,\n                  `at line ${this.info.lines}`,\n                  'instead of delimiter, row delimiter, trimable character',\n                  '(if activated) or comment',\n                ], this.__context())\n              )\n              if(err !== undefined) return err\n            }else{\n              this.state.quoting = false\n              this.state.wasQuoting = true\n              // continue\n              this.state.field.prepend(quote)\n            }\n          }else{\n            if(this.state.field.length !== 0){\n              // In relax mode, treat opening quote preceded by chrs as regular\n              if( relax === false ){\n                const err = this.__error(\n                  new CsvError('INVALID_OPENING_QUOTE', [\n                    'Invalid Opening Quote:',\n                    `a quote is found inside a field at line ${this.info.lines}`,\n                  ], this.__context(), {\n                    field: this.state.field,\n                  })\n                )\n                if(err !== undefined) return err\n              }\n            }else{\n              this.state.quoting = true\n              continue\n            }\n          }\n        }\n        if(this.state.quoting === false){\n          let recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos)\n          if(recordDelimiterLength !== 0){\n            // Do not emit comments which take a full line\n            const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0)\n            if(skipCommentLine){\n              this.info.comment_lines++\n              // Skip full comment line\n            }else{\n              // Skip if line is empty and skip_empty_lines activated\n              if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){\n                this.info.empty_lines++\n                pos += recordDelimiterLength - 1\n                continue\n              }\n              // Activate records emition if above from_line\n              if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0 ) >= from_line){\n                this.state.enabled = true\n                this.__resetField()\n                this.__resetRow()\n                pos += recordDelimiterLength - 1\n                continue\n              }else{\n                const errField = this.__onField()\n                if(errField !== undefined) return errField\n                const errRecord = this.__onRow()\n                if(errRecord !== undefined) return errRecord\n              }\n              if(to !== -1 && this.info.records >= to){\n                this.state.stop = true\n                this.push(null)\n                return\n              }\n            }\n            this.state.commenting = false\n            pos += recordDelimiterLength - 1\n            continue\n          }\n          if(this.state.commenting){\n            continue\n          }\n          const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr)\n          if(commentCount !== 0){\n            this.state.commenting = true\n            continue\n          }\n          let delimiterLength = this.__isDelimiter(chr, buf, pos)\n          if(delimiterLength !== 0){\n            const errField = this.__onField()\n            if(errField !== undefined) return errField\n            pos += delimiterLength - 1\n            continue\n          }\n        }\n      }\n      if(this.state.commenting === false){\n        if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){\n          const err = this.__error(\n            new CsvError('CSV_MAX_RECORD_SIZE', [\n              'Max Record Size:',\n              'record exceed the maximum number of tolerated bytes',\n              `of ${max_record_size}`,\n              `at line ${this.info.lines}`,\n            ], this.__context())\n          )\n          if(err !== undefined) return err\n        }\n      }\n\n      const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr)\n      // rtrim in non quoting is handle in __onField\n      const rappend = rtrim === false || this.state.wasQuoting === false\n      if( lappend === true && rappend === true ){\n        this.state.field.append(chr)\n      }else if(rtrim === true && !this.__isCharTrimable(chr)){\n        const err = this.__error(\n          new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [\n            'Invalid Closing Quote:',\n            'found non trimable byte after quote',\n            `at line ${this.info.lines}`,\n          ], this.__context())\n        )\n        if(err !== undefined) return err\n      }\n    }\n    if(end === true){\n      // Ensure we are not ending in a quoting state\n      if(this.state.quoting === true){\n        const err = this.__error(\n          new CsvError('CSV_QUOTE_NOT_CLOSED', [\n            'Quote Not Closed:',\n            `the parsing is finished with an opening quote at line ${this.info.lines}`,\n          ], this.__context())\n        )\n        if(err !== undefined) return err\n      }else{\n        // Skip last line if it has no characters\n        if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){\n          const errField = this.__onField()\n          if(errField !== undefined) return errField\n          const errRecord = this.__onRow()\n          if(errRecord !== undefined) return errRecord\n        }else if(this.state.wasRowDelimiter === true){\n          this.info.empty_lines++\n        }else if(this.state.commenting === true){\n          this.info.comment_lines++\n        }\n      }\n    }else{\n      this.state.previousBuf = buf.slice(pos)\n    }\n    if(this.state.wasRowDelimiter === true){\n      this.info.lines++\n      this.state.wasRowDelimiter = false\n    }\n  }\n  // Helper to test if a character is a space or a line delimiter\n  __isCharTrimable(chr){\n    return chr === space || chr === tab || chr === cr || chr === nl || chr === np\n  }\n  __onRow(){\n    const {columns, columns_duplicates_to_array, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_lines_with_empty_values} = this.options\n    const {enabled, record} = this.state\n    if(enabled === false){\n      return this.__resetRow()\n    }\n    // Convert the first line into column names\n    const recordLength = record.length\n    if(columns === true){\n      if(isRecordEmpty(record)){\n        this.__resetRow()\n        return\n      }\n      return this.__firstLineToColumns(record)\n    }\n    if(columns === false && this.info.records === 0){\n      this.state.expectedRecordLength = recordLength\n    }\n    if(recordLength !== this.state.expectedRecordLength){\n      if(relax_column_count === true || \n        (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||\n        (relax_column_count_more === true && recordLength > this.state.expectedRecordLength) ){\n        this.info.invalid_field_length++\n      }else{\n        if(columns === false){\n          const err = this.__error(\n            new CsvError('CSV_INCONSISTENT_RECORD_LENGTH', [\n              'Invalid Record Length:',\n              `expect ${this.state.expectedRecordLength},`,\n              `got ${recordLength} on line ${this.info.lines}`,\n            ], this.__context(), {\n              record: record,\n            })\n          )\n          if(err !== undefined) return err\n        }else{\n          const err = this.__error(\n            // CSV_INVALID_RECORD_LENGTH_DONT_MATCH_COLUMNS\n            new CsvError('CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH', [\n              'Invalid Record Length:',\n              `columns length is ${columns.length},`, // rename columns\n              `got ${recordLength} on line ${this.info.lines}`,\n            ], this.__context(), {\n              record: record,\n            })\n          )\n          if(err !== undefined) return err\n        }\n      }\n    }\n    if(skip_lines_with_empty_values === true){\n      if(isRecordEmpty(record)){\n        this.__resetRow()\n        return\n      }\n    }\n    if(this.state.recordHasError === true){\n      this.__resetRow()\n      this.state.recordHasError = false\n      return\n    }\n    this.info.records++\n    if(from === 1 || this.info.records >= from){\n      if(columns !== false){\n        const obj = {}\n        // Transform record array to an object\n        for(let i = 0, l = record.length; i < l; i++){\n          if(columns[i] === undefined || columns[i].disabled) continue\n          // obj[columns[i].name] = record[i]\n          // Turn duplicate columns into an array\n          if (columns_duplicates_to_array === true && obj[columns[i].name]) {\n            if (Array.isArray(obj[columns[i].name])) {\n              obj[columns[i].name] = obj[columns[i].name].concat(record[i])\n            } else {\n              obj[columns[i].name] = [obj[columns[i].name], record[i]]\n            }\n          } else {\n            obj[columns[i].name] = record[i]\n          }\n        }\n        const {objname} = this.options\n        if(objname === undefined){\n          if(raw === true || info === true){\n            const err = this.__push(Object.assign(\n              {record: obj},\n              (raw === true ? {raw: this.state.rawBuffer.toString()}: {}),\n              (info === true ? {info: this.state.info}: {})\n            ))\n            if(err){\n              return err\n            }\n          }else{\n            const err = this.__push(obj)\n            if(err){\n              return err\n            }\n          }\n        }else{\n          if(raw === true || info === true){\n            const err = this.__push(Object.assign(\n              {record: [obj[objname], obj]},\n              raw === true ? {raw: this.state.rawBuffer.toString()}: {},\n              info === true ? {info: this.state.info}: {}\n            ))\n            if(err){\n              return err\n            }\n          }else{\n            const err = this.__push([obj[objname], obj])\n            if(err){\n              return err\n            }\n          }\n        }\n      }else{\n        if(raw === true || info === true){\n          const err = this.__push(Object.assign(\n            {record: record},\n            raw === true ? {raw: this.state.rawBuffer.toString()}: {},\n            info === true ? {info: this.state.info}: {}\n          ))\n          if(err){\n            return err\n          }\n        }else{\n          const err = this.__push(record)\n          if(err){\n            return err\n          }\n        }\n      }\n    }\n    this.__resetRow()\n  }\n  __firstLineToColumns(record){\n    const {firstLineToHeaders} = this.state\n    try{\n      const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record)\n      if(!Array.isArray(headers)){\n        return this.__error(\n          new CsvError('CSV_INVALID_COLUMN_MAPPING', [\n            'Invalid Column Mapping:',\n            'expect an array from column function,',\n            `got ${JSON.stringify(headers)}`\n          ], this.__context(), {\n            headers: headers,\n          })\n        )\n      }\n      const normalizedHeaders = normalizeColumnsArray(headers)\n      this.state.expectedRecordLength = normalizedHeaders.length\n      this.options.columns = normalizedHeaders\n      this.__resetRow()\n      return\n    }catch(err){\n      return err\n    }\n  }\n  __resetRow(){\n    if(this.options.raw === true){\n      this.state.rawBuffer.reset()\n    }\n    this.state.record = []\n    this.state.record_length = 0\n  }\n  __onField(){\n    const {cast, rtrim, max_record_size} = this.options\n    const {enabled, wasQuoting} = this.state\n    // Short circuit for the from_line options\n    if(enabled === false){ /* this.options.columns !== true && */\n      return this.__resetField()\n    }\n    let field = this.state.field.toString()\n    if(rtrim === true && wasQuoting === false){\n      field = field.trimRight()\n    }\n    if(cast === true){\n      const [err, f] = this.__cast(field)\n      if(err !== undefined) return err\n      field = f\n    }\n    this.state.record.push(field)\n    // Increment record length if record size must not exceed a limit\n    if(max_record_size !== 0 && typeof field === 'string'){\n      this.state.record_length += field.length\n    }\n    this.__resetField()\n  }\n  __resetField(){\n    this.state.field.reset()\n    this.state.wasQuoting = false\n  }\n  __push(record){\n    const {on_record} = this.options\n    if(on_record !== undefined){\n      const context = this.__context()\n      try{\n        record = on_record.call(null, record, context)\n      }catch(err){\n        return err\n      }\n      if(record === undefined || record === null){ return }\n    }\n    this.push(record)\n  }\n  // Return a tuple with the error and the casted value\n  __cast(field){\n    const {columns, relax_column_count} = this.options\n    const isColumns = Array.isArray(columns)\n    // Dont loose time calling cast\n    // because the final record is an object\n    // and this field can't be associated to a key present in columns\n    if( isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length ){\n      return [undefined, undefined]\n    }\n    const context = this.__context()\n    if(this.state.castField !== null){\n      try{\n        return [undefined, this.state.castField.call(null, field, context)]\n      }catch(err){\n        return [err]\n      }\n    }\n    if(this.__isFloat(field)){\n      return [undefined, parseFloat(field)]\n    }else if(this.options.cast_date !== false){\n      return [undefined, this.options.cast_date.call(null, field, context)]\n    }\n    return [undefined, field]\n  }\n  // Keep it in case we implement the `cast_int` option\n  // __isInt(value){\n  //   // return Number.isInteger(parseInt(value))\n  //   // return !isNaN( parseInt( obj ) );\n  //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n  // }\n  __isFloat(value){\n    return (value - parseFloat( value ) + 1) >= 0 // Borrowed from jquery\n  }\n  __compareBytes(sourceBuf, targetBuf, pos, firtByte){\n    if(sourceBuf[0] !== firtByte) return 0\n    const sourceLength = sourceBuf.length\n    for(let i = 1; i < sourceLength; i++){\n      if(sourceBuf[i] !== targetBuf[pos+i]) return 0\n    }\n    return sourceLength\n  }\n  __needMoreData(i, bufLen, end){\n    if(end){\n      return false\n    }\n    const {comment, delimiter} = this.options\n    const {quoting, recordDelimiterMaxLength} = this.state\n    const numOfCharLeft = bufLen - i - 1\n    const requiredLength = Math.max(\n      // Skip if the remaining buffer smaller than comment\n      comment ? comment.length : 0,\n      // Skip if the remaining buffer smaller than row delimiter\n      recordDelimiterMaxLength,\n      // Skip if the remaining buffer can be row delimiter following the closing quote\n      // 1 is for quote.length\n      quoting ? (1 + recordDelimiterMaxLength) : 0,\n      // Skip if the remaining buffer can be delimiter\n      delimiter.length,\n      // Skip if the remaining buffer can be escape sequence\n      // 1 is for escape.length\n      1\n    )\n    return numOfCharLeft < requiredLength\n  }\n  __isDelimiter(chr, buf, pos){\n    const {delimiter} = this.options\n    loop1: for(let i = 0; i < delimiter.length; i++){\n      const del = delimiter[i]\n      if(del[0] === chr){\n        for(let j = 1; j < del.length; j++){\n          if(del[j] !== buf[pos+j]) continue loop1\n        }\n        return del.length\n      }\n    }\n    return 0\n  }\n  __isRecordDelimiter(chr, buf, pos){\n    const {record_delimiter} = this.options\n    const recordDelimiterLength = record_delimiter.length\n    loop1: for(let i = 0; i < recordDelimiterLength; i++){\n      const rd = record_delimiter[i]\n      const rdLength = rd.length\n      if(rd[0] !== chr){\n        continue\n      }\n      for(let j = 1; j < rdLength; j++){\n        if(rd[j] !== buf[pos+j]){\n          continue loop1\n        }\n      }\n      return rd.length\n    }\n    return 0\n  }\n  __autoDiscoverRowDelimiter(buf, pos){\n    const chr = buf[pos]\n    if(chr === cr){\n      if(buf[pos+1] === nl){\n        this.options.record_delimiter.push(Buffer.from('\\r\\n'))\n        this.state.recordDelimiterMaxLength = 2\n        return 2\n      }else{\n        this.options.record_delimiter.push(Buffer.from('\\r'))\n        this.state.recordDelimiterMaxLength = 1\n        return 1\n      }\n    }else if(chr === nl){\n      this.options.record_delimiter.push(Buffer.from('\\n'))\n      this.state.recordDelimiterMaxLength = 1\n      return 1\n    }\n    return 0\n  }\n  __error(msg){\n    const {skip_lines_with_error} = this.options\n    const err = typeof msg === 'string' ? new Error(msg) : msg\n    if(skip_lines_with_error){\n      this.state.recordHasError = true\n      this.emit('skip', err)\n      return undefined\n    }else{\n      return err\n    }\n  }\n  __context(){\n    const {columns} = this.options\n    const isColumns = Array.isArray(columns)\n    return {\n      column: isColumns === true ?\n        ( columns.length > this.state.record.length ?\n          columns[this.state.record.length].name :\n          null\n        ) :\n        this.state.record.length,\n      empty_lines: this.info.empty_lines,\n      header: columns === true,\n      index: this.state.record.length,\n      invalid_field_length: this.info.invalid_field_length,\n      quoting: this.state.wasQuoting,\n      lines: this.info.lines,\n      records: this.info.records\n    }\n  }\n}\n\nconst parse = function(){\n  let data, options, callback\n  for(let i in arguments){\n    const argument = arguments[i]\n    const type = typeof argument\n    if(data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))){\n      data = argument\n    }else if(options === undefined && isObject(argument)){\n      options = argument\n    }else if(callback === undefined && type === 'function'){\n      callback = argument\n    }else{\n      throw new CsvError('CSV_INVALID_ARGUMENT', [\n        'Invalid argument:',\n        `got ${JSON.stringify(argument)} at index ${i}`\n      ])\n    }\n  }\n  const parser = new Parser(options)\n  if(callback){\n    const records = options === undefined || options.objname === undefined ? [] : {}\n    parser.on('readable', function(){\n      let record\n      while((record = this.read()) !== null){\n        if(options === undefined || options.objname === undefined){\n          records.push(record)\n        }else{\n          records[record[0]] = record[1]\n        }\n      }\n    })\n    parser.on('error', function(err){\n      callback(err, undefined, parser.info)\n    })\n    parser.on('end', function(){\n      callback(undefined, records, parser.info)\n    })\n  }\n  if(data !== undefined){\n    // Give a chance for events to be registered later\n    if(typeof setImmediate === 'function'){\n      setImmediate(function(){\n        parser.write(data)\n        parser.end()\n      })\n    }else{\n      parser.write(data)\n      parser.end()\n    }\n  }\n  return parser\n}\n\nclass CsvError extends Error {\n  constructor(code, message, ...contexts) {\n    if(Array.isArray(message)) message = message.join(' ')\n    super(message)\n    if(Error.captureStackTrace !== undefined){\n      Error.captureStackTrace(this, CsvError)\n    }\n    this.code = code\n    for(const context of contexts){\n      for(const key in context){\n        const value = context[key]\n        this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value))\n      }\n    }\n  }\n}\n\nparse.Parser = Parser\n\nparse.CsvError = CsvError\n\nmodule.exports = parse\n\nconst underscore = function(str){\n  return str.replace(/([A-Z])/g, function(_, match){\n    return '_' + match.toLowerCase()\n  })\n}\n\nconst isObject = function(obj){\n  return (typeof obj === 'object' && obj !== null && !Array.isArray(obj))\n}\n\nconst isRecordEmpty = function(record){\n  return record.every( (field) => field == null || field.toString && field.toString().trim() === '' )\n}\n\nconst normalizeColumnsArray = function(columns){\n  const normalizedColumns = [];\n  for(let i = 0, l = columns.length; i < l; i++){\n    const column = columns[i]\n    if(column === undefined || column === null || column === false){\n      normalizedColumns[i] = { disabled: true }\n    }else if(typeof column === 'string'){\n      normalizedColumns[i] = { name: column }\n    }else if(isObject(column)){\n      if(typeof column.name !== 'string'){\n        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', [\n          'Option columns missing name:',\n          `property \"name\" is required at position ${i}`,\n          'when column is an object literal'\n        ])\n      }\n      normalizedColumns[i] = column\n    }else{\n      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', [\n        'Invalid column definition:',\n        'expect a string or a literal object,',\n        `got ${JSON.stringify(column)} at position ${i}`\n      ])\n    }\n  }\n  return normalizedColumns;\n}\n","\nconst parse = require('.')\n\nmodule.exports = function(data, options={}){\n  if(typeof data === 'string'){\n    data = Buffer.from(data)\n  }\n  const records = options && options.objname ? {} : []\n  const parser = new parse.Parser(options)\n  parser.push = function(record){\n    if(record === null){\n      return\n    }\n    if(options.objname === undefined)\n      records.push(record)\n    else{\n      records[record[0]] = record[1]\n    }\n  }\n  const err1 = parser.__parse(data, false)\n  if(err1 !== undefined) throw err1\n  const err2 = parser.__parse(undefined, true)\n  if(err2 !== undefined) throw err2\n  return records\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./src sync recursive\";","/**\n * Manages all of the add-ons used in the system.\n *\n * @module AddonManager\n */\n/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst AddonUtils = require('./addon-utils');\nconst config = require('config');\nconst Constants = require('./constants');\nconst Deferred = require('./deferred');\nconst EventEmitter = require('events').EventEmitter;\nconst Platform = require('./platform');\nconst Settings = require('./models/settings');\nconst UserProfile = require('./user-profile');\nconst Utils = require('./utils');\nconst fs = require('fs');\nconst path = require('path');\nconst rimraf = require('rimraf');\nconst semver = require('semver');\nconst tar = require('tar');\nconst os = require('os');\nconst promisePipe = require('promisepipe');\nconst fetch = require('node-fetch');\nconst find = require('find');\nconst {URLSearchParams} = require('url');\nconst {ncp} = require('ncp');\n\nconst pkg = require('../package.json');\n\nlet PluginServer;\n\n/**\n * @class AddonManager\n * @classdesc The AddonManager will load any add-ons from the 'addons'\n * directory. See loadAddons() for details.\n */\nclass AddonManager extends EventEmitter {\n\n  constructor() {\n    super();\n    this.adapters = new Map();\n    this.notifiers = new Map();\n    this.apiHandlers = new Map();\n    this.devices = {};\n    this.outlets = {};\n    this.extensions = {};\n    this.deferredAdd = null;\n    this.deferredRemovals = new Map();\n    this.removalTimeouts = new Map();\n    this.addonsLoaded = false;\n    this.installedAddons = new Map();\n    this.deferredWaitForAdapter = new Map();\n    this.pluginServer = null;\n    this.updateTimeout = null;\n    this.updateInterval = null;\n  }\n\n  /**\n   * Adds an adapter to the collection of adapters managed by AddonManager.\n   * This function is typically called when loading add-ons.\n   */\n  addAdapter(adapter) {\n    if (!adapter.name) {\n      adapter.name = adapter.constructor.name;\n    }\n    this.adapters.set(adapter.id, adapter);\n\n    /**\n     * Adapter added event.\n     *\n     * This is event is emitted whenever a new adapter is loaded.\n     *\n     * @event adapterAdded\n     * @type  {Adapter}\n     */\n    this.emit(Constants.ADAPTER_ADDED, adapter);\n\n    const deferredWait = this.deferredWaitForAdapter.get(adapter.id);\n    if (deferredWait) {\n      this.deferredWaitForAdapter.delete(adapter.id);\n      deferredWait.resolve(adapter);\n    }\n  }\n\n  addNotifier(notifier) {\n    if (!notifier.name) {\n      notifier.name = notifier.constructor.name;\n    }\n\n    this.notifiers.set(notifier.id, notifier);\n\n    /**\n     * Notifier added event.\n     *\n     * This is event is emitted whenever a new notifier is loaded.\n     *\n     * @event notifierAdded\n     * @type {Notifier}\n     */\n    this.emit(Constants.NOTIFIER_ADDED, notifier);\n  }\n\n  addAPIHandler(handler) {\n    this.apiHandlers.set(handler.packageName, handler);\n\n    /**\n     * API Handler added event.\n     *\n     * This is event is emitted whenever a new API handler is loaded.\n     *\n     * @event apiHandlerAdded\n     * @type {APIHandler}\n     */\n    this.emit(Constants.API_HANDLER_ADDED, handler);\n  }\n\n  /**\n   * @method addNewThing\n   *\n   * Initiates pairing on all of the adapters that support it.\n   *\n   * @returns A promise when the pairing process is complete.\n   */\n  addNewThing(pairingTimeout) {\n    const deferredAdd = new Deferred();\n\n    if (this.deferredAdd) {\n      deferredAdd.reject('Add already in progress');\n    } else {\n      this.deferredAdd = deferredAdd;\n      this.adapters.forEach((adapter) => {\n        console.log('About to call startPairing on', adapter.name);\n        adapter.startPairing(pairingTimeout);\n      });\n      this.pairingTimeout = setTimeout(() => {\n        console.log('Pairing timeout');\n        this.emit(Constants.PAIRING_TIMEOUT);\n        this.cancelAddNewThing();\n      }, pairingTimeout * 1000);\n    }\n\n    return deferredAdd.promise;\n  }\n\n  /**\n   * @method cancelAddNewThing\n   *\n   * Cancels a previous addNewThing request.\n   */\n  cancelAddNewThing() {\n    const deferredAdd = this.deferredAdd;\n\n    if (this.pairingTimeout) {\n      clearTimeout(this.pairingTimeout);\n      this.pairingTimeout = null;\n    }\n\n    if (deferredAdd) {\n      this.adapters.forEach((adapter) => {\n        adapter.cancelPairing();\n      });\n      this.deferredAdd = null;\n      deferredAdd.resolve();\n    }\n  }\n\n  /**\n   * @method cancelRemoveThing\n   *\n   * Cancels a previous removeThing request.\n   */\n  cancelRemoveThing(thingId) {\n    const timeout = this.removalTimeouts.get(thingId);\n    if (timeout) {\n      clearTimeout(timeout);\n      this.removalTimeouts.delete(thingId);\n    }\n\n    const deferredRemove = this.deferredRemovals.get(thingId);\n    if (deferredRemove) {\n      const device = this.getDevice(thingId);\n      if (device) {\n        const adapter = device.adapter;\n        if (adapter) {\n          adapter.cancelRemoveThing(device);\n        }\n      }\n      this.deferredRemovals.delete(thingId);\n      deferredRemove.reject('removeThing cancelled');\n    }\n  }\n\n  /**\n   * @method getAdapter\n   * @returns Returns the adapter with the indicated id.\n   */\n  getAdapter(adapterId) {\n    return this.adapters.get(adapterId);\n  }\n\n  /**\n   * @method getAdaptersByPackageId\n   * @returns Returns a list of loaded adapters with the given package ID.\n   */\n  getAdaptersByPackageId(packageId) {\n    return Array.from(this.adapters.values()).filter(\n      (a) => a.getPackageName() === packageId);\n  }\n\n  /**\n   * @method getAdapters\n   * @returns Returns a Map of the loaded adapters. The dictionary\n   *          key corresponds to the adapter id.\n   */\n  getAdapters() {\n    return this.adapters;\n  }\n\n  /**\n   * @method getNotifiers\n   * @returns Returns a Map of the loaded notifiers. The dictionary\n   *          key corresponds to the notifier id.\n   */\n  getNotifiers() {\n    return this.notifiers;\n  }\n\n  /**\n   * @method getNotifier\n   * @returns Returns the notifier with the indicated id.\n   */\n  getNotifier(notifierId) {\n    return this.notifiers.get(notifierId);\n  }\n\n  /**\n   * @method getNotifiersByPackageId\n   * @returns Returns a list of loaded notifiers with the given package ID.\n   */\n  getNotifiersByPackageId(packageId) {\n    return Array.from(this.notifiers.values()).filter(\n      (n) => n.getPackageName() === packageId);\n  }\n\n  /**\n   * @method getAPIHandlers\n   * @returns Returns a Map of the loaded API handlers. The dictionary\n   *          key corresponds to the package ID.\n   */\n  getAPIHandlers() {\n    return this.apiHandlers;\n  }\n\n  /**\n   * @method getAPIHandler\n   * @returns Returns the API handler with the given package ID.\n   */\n  getAPIHandler(packageId) {\n    return this.apiHandlers.get(packageId);\n  }\n\n  /**\n   * @method getExtensions\n   * @returns Returns a Map of the loaded extensions. The dictionary\n   *          key corresponds to the extension ID.\n   */\n  getExtensions() {\n    return this.extensions;\n  }\n\n  /**\n   * @method getExtensionsByPackageId\n   * @returns Returns a Map of loaded extensions with the given package ID.\n   */\n  getExtensionsByPackageId(packageId) {\n    if (this.extensions.hasOwnProperty(packageId)) {\n      return this.extensions[packageId];\n    }\n\n    return {};\n  }\n\n  /**\n   * @method getDevice\n   * @returns Returns the device with the indicated id.\n   */\n  getDevice(id) {\n    return this.devices[id];\n  }\n\n  /**\n   * @method getDevices\n   * @returns Returns an dictionary of all of the known devices.\n   *          The dictionary key corresponds to the device id.\n   */\n  getDevices() {\n    return this.devices;\n  }\n\n  /**\n   * @method getOutlet\n   * @returns Returns the outlet with the indicated id.\n   */\n  getOutlet(id) {\n    return this.outlets[id];\n  }\n\n  /**\n   * @method getOutlets\n   * @returns Returns an dictionary of all of the known outlets.\n   *          The dictionary key corresponds to the outlet id.\n   */\n  getOutlets() {\n    return this.outlets;\n  }\n\n  /**\n   * @method getPlugin\n   *\n   * Returns a previously registered plugin.\n   */\n  getPlugin(pluginId) {\n    if (this.pluginServer) {\n      return this.pluginServer.getPlugin(pluginId);\n    }\n  }\n\n  /**\n   * @method getThings\n   * @returns Returns a dictionary of all of the known things.\n   *          The dictionary key corresponds to the device id.\n   */\n  getThings() {\n    const things = [];\n    for (const thingId in this.devices) {\n      things.push(this.getThing(thingId));\n    }\n    return things;\n  }\n\n  /**\n   * @method getThing\n   * @returns Returns the thing with the indicated id.\n   */\n  getThing(thingId) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.asThing();\n    }\n  }\n\n  /**\n   * @method getPropertyDescriptions\n   * @returns Retrieves all of the properties associated with the thing\n   *          identified by `thingId`.\n   */\n  getPropertyDescriptions(thingId) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.getPropertyDescriptions();\n    }\n  }\n\n  /**\n   * @method getPropertyDescription\n   * @returns Retrieves the property named `propertyName` from the thing\n   *          identified by `thingId`.\n   */\n  getPropertyDescription(thingId, propertyName) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.getPropertyDescription(propertyName);\n    }\n  }\n\n  /**\n   * @method getProperty\n   * @returns a promise which resolves to the retrieved value of `propertyName`\n   *          from the thing identified by `thingId`.\n   */\n  getProperty(thingId, propertyName) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.getProperty(propertyName);\n    }\n\n    return Promise.reject(`getProperty: device: ${thingId} not found.`);\n  }\n\n  /**\n   * @method setProperty\n   * @returns a promise which resolves to the updated value of `propertyName`\n   *          for the thing identified by `thingId`.\n   */\n  setProperty(thingId, propertyName, value) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.setProperty(propertyName, value);\n    }\n\n    return Promise.reject(`setProperty: device: ${thingId} not found.`);\n  }\n\n  /**\n   * @method notify\n   * @returns a promise which resolves when the outlet has been notified.\n   */\n  notify(outletId, title, message, level) {\n    const outlet = this.getOutlet(outletId);\n    if (outlet) {\n      return outlet.notify(title, message, level);\n    }\n\n    return Promise.reject(`notify: outlet: ${outletId} not found.`);\n  }\n\n  /**\n   * @method setPin\n   * @returns a promise which resolves when the PIN has been set.\n   */\n  setPin(thingId, pin) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.adapter.setPin(thingId, pin);\n    }\n\n    return Promise.reject(`setPin: device ${thingId} not found.`);\n  }\n\n  /**\n   * @method setCredentials\n   * @returns a promise which resolves when the credentials have been set.\n   */\n  setCredentials(thingId, username, password) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.adapter.setCredentials(thingId, username, password);\n    }\n\n    return Promise.reject(`setCredentials: device ${thingId} not found.`);\n  }\n\n  /**\n   * @method requestAction\n   * @returns a promise which resolves when the action has been requested.\n   */\n  requestAction(thingId, actionId, actionName, input) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.requestAction(actionId, actionName, input);\n    }\n\n    return Promise.reject(`requestAction: device: ${thingId} not found.`);\n  }\n\n  /**\n   * @method removeAction\n   * @returns a promise which resolves when the action has been removed.\n   */\n  removeAction(thingId, actionId, actionName) {\n    const device = this.getDevice(thingId);\n    if (device) {\n      return device.removeAction(actionId, actionName);\n    }\n\n    return Promise.reject(`removeAction: device: ${thingId} not found.`);\n  }\n\n  /**\n   * @method handleDeviceAdded\n   *\n   * Called when the indicated device has been added to an adapter.\n   */\n  handleDeviceAdded(device) {\n    this.devices[device.id] = device;\n    const thing = device.asThing();\n\n    /**\n     * Thing added event.\n     *\n     * This event is emitted whenever a new thing is added.\n     *\n     * @event thingAdded\n     * @type  {Thing}\n     */\n    this.emit(Constants.THING_ADDED, thing);\n  }\n\n  /**\n   * @method handleDeviceRemoved\n   * Called when the indicated device has been removed by an adapter.\n   */\n  handleDeviceRemoved(device) {\n    delete this.devices[device.id];\n    const thing = device.asThing();\n\n    /**\n     * Thing removed event.\n     *\n     * This event is emitted whenever a thing is removed.\n     *\n     * @event thingRemoved\n     * @type  {Thing}\n     */\n    this.emit(Constants.THING_REMOVED, thing);\n\n    const timeout = this.removalTimeouts.get(device.id);\n    if (timeout) {\n      clearTimeout(timeout);\n      this.removalTimeouts.delete(device.id);\n    }\n\n    const deferredRemove = this.deferredRemovals.get(device.id);\n    if (deferredRemove && deferredRemove.adapter == device.adapter) {\n      this.deferredRemovals.delete(device.id);\n      deferredRemove.resolve(device.id);\n    }\n  }\n\n  /**\n   * @method handleOutletAdded\n   *\n   * Called when the indicated outlet has been added to a notifier.\n   */\n  handleOutletAdded(outlet) {\n    this.outlets[outlet.id] = outlet;\n\n    /**\n     * Outlet added event.\n     *\n     * This event is emitted whenever a new outlet is added.\n     *\n     * @event outletAdded\n     * @type {Outlet}\n     */\n    this.emit(Constants.OUTLET_ADDED, outlet.asDict());\n  }\n\n  /**\n   * @method handleOutletRemoved\n   * Called when the indicated outlet has been removed by a notifier.\n   */\n  handleOutletRemoved(outlet) {\n    delete this.outlets[outlet.id];\n\n    /**\n     * Outlet removed event.\n     *\n     * This event is emitted whenever an outlet is removed.\n     *\n     * @event outletRemoved\n     * @type {Outlet}\n     */\n    this.emit(Constants.OUTLET_REMOVED, outlet.asDict());\n  }\n\n  /**\n   * @method addonEnabled\n   *\n   * Determine whether the add-on with the given package name is enabled.\n   *\n   * @param {string} packageId The package ID of the add-on\n   * @returns {boolean} Boolean indicating enabled status.\n   */\n  async addonEnabled(packageId) {\n    if (this.installedAddons.has(packageId)) {\n      return this.installedAddons.get(packageId).enabled;\n    }\n\n    return false;\n  }\n\n  async enableAddon(packageId) {\n    if (!this.installedAddons.has(packageId)) {\n      throw new Error('Package not installed.');\n    }\n\n    const obj = this.installedAddons.get(packageId);\n    obj.enabled = true;\n    await Settings.set(`addons.${packageId}`, obj);\n    await this.loadAddon(packageId);\n  }\n\n  async disableAddon(packageId, wait = false) {\n    if (!this.installedAddons.has(packageId)) {\n      throw new Error('Package not installed.');\n    }\n\n    const obj = this.installedAddons.get(packageId);\n    obj.enabled = false;\n    await Settings.set(`addons.${packageId}`, obj);\n    await this.unloadAddon(packageId, wait);\n  }\n\n  /**\n   * @method loadAddon\n   *\n   * Loads add-on with the given package ID.\n   *\n   * @param {String} packageId The package ID of the add-on to load.\n   * @returns A promise which is resolved when the add-on is loaded.\n   */\n  async loadAddon(packageId) {\n    const addonPath = path.join(UserProfile.addonsDir, packageId);\n\n    // Let errors from loading the manifest bubble up.\n    const [manifest, cfg] = AddonUtils.loadManifest(packageId);\n\n    // Get any saved settings for this add-on.\n    const key = `addons.${packageId}`;\n    const configKey = `addons.config.${packageId}`;\n    try {\n      const savedSettings = await Settings.get(key);\n\n      // If the old-style data is stored in the database, we need to transition\n      // to the new format.\n      if (savedSettings.hasOwnProperty('moziot') &&\n          savedSettings.moziot.hasOwnProperty('enabled')) {\n        manifest.enabled = savedSettings.moziot.enabled;\n      } else if (savedSettings.hasOwnProperty('enabled')) {\n        manifest.enabled = savedSettings.enabled;\n      }\n\n      if (savedSettings.hasOwnProperty('moziot') &&\n          savedSettings.moziot.hasOwnProperty('config')) {\n        await Settings.set(configKey, savedSettings.moziot.config);\n      }\n    } catch (_e) {\n      // pass\n    }\n\n    await Settings.set(key, manifest);\n    this.installedAddons.set(packageId, manifest);\n\n    // Get the saved config. If there is none, populate the database with the\n    // defaults.\n    let savedConfig = await Settings.get(configKey);\n    if (!savedConfig) {\n      await Settings.set(configKey, cfg);\n      savedConfig = cfg;\n    }\n\n    // If this add-on is not explicitly enabled, move on.\n    if (!manifest.enabled) {\n      throw new Error(`Add-on not enabled: ${manifest.id}`);\n    }\n\n    if (manifest.content_scripts && manifest.web_accessible_resources) {\n      this.extensions[manifest.id] = {\n        extensions: manifest.content_scripts,\n        resources: manifest.web_accessible_resources,\n      };\n    }\n\n    if (!manifest.exec) {\n      return;\n    }\n\n    const dataPath = path.join(UserProfile.dataDir, manifest.id);\n    try {\n      // Create the add-on data directory, if necessary\n      if (!fs.existsSync(dataPath)) {\n        fs.mkdirSync(dataPath);\n      }\n    } catch (e) {\n      console.error(`Failed to create add-on data directory ${dataPath}:`, e);\n    }\n\n    // Now, we need to build an object so that add-ons which rely on things\n    // being passed in can function properly.\n    const newSettings = {\n      name: manifest.id,\n      display_name: manifest.name,\n      moziot: {\n        exec: manifest.exec,\n      },\n    };\n\n    if (manifest.schema) {\n      newSettings.moziot.schema = manifest.schema;\n    }\n\n    if (savedConfig) {\n      newSettings.moziot.config = savedConfig;\n    }\n\n    // Load the add-on\n    console.log(`Loading add-on: ${manifest.id}`);\n    this.pluginServer.loadPlugin(addonPath, newSettings);\n  }\n\n  /**\n   * @method loadAddons\n   * Loads all of the configured add-ons from the addons directory.\n   */\n  loadAddons() {\n    if (this.addonsLoaded) {\n      // This is kind of a hack, but it allows the gateway to restart properly\n      // when switching between http and https modes.\n      return;\n    }\n    this.addonsLoaded = true;\n\n    // Load the Plugin Server\n    PluginServer = require('./plugin/plugin-server');\n\n    this.pluginServer = new PluginServer(this, {verbose: false});\n\n    // Load the add-ons\n\n    const addonManager = this;\n    const addonPath = UserProfile.addonsDir;\n\n    // Search add-ons directory\n    fs.readdir(addonPath, async (err, files) => {\n      if (err) {\n        // This should probably never happen.\n        console.error('Failed to search add-ons directory');\n        console.error(err);\n        return;\n      }\n\n      for (const addonId of files) {\n        // Skip if not a directory. Use stat rather than lstat such that we\n        // also load through symlinks.\n        if (!fs.statSync(path.join(addonPath, addonId)).isDirectory()) {\n          continue;\n        }\n\n        addonManager.loadAddon(addonId).catch((err) => {\n          console.error(`Failed to load add-on ${addonId}:`, err);\n        });\n      }\n    });\n\n    if (process.env.NODE_ENV !== 'test') {\n      // Check for add-ons in 10 seconds (allow add-ons to load first).\n      this.updateTimeout = setTimeout(() => {\n        this.updateAddons();\n        this.updateTimeout = null;\n\n        // Check every day.\n        const delay = 24 * 60 * 60 * 1000;\n        this.updateInterval = setInterval(this.updateAddons.bind(this), delay);\n      }, 10000);\n    }\n  }\n\n  /**\n   * @method removeThing\n   *\n   * Initiates removing a particular device.\n   *\n   * @returns A promise that resolves to the device which was actually removed.\n   */\n  removeThing(thingId) {\n    const deferredRemove = new Deferred();\n\n    if (this.deferredRemovals.has(thingId)) {\n      deferredRemove.reject('Remove already in progress');\n    } else {\n      const device = this.getDevice(thingId);\n      if (device) {\n        deferredRemove.adapter = device.adapter;\n        this.deferredRemovals.set(thingId, deferredRemove);\n        this.removalTimeouts.set(thingId, setTimeout(() => {\n          this.cancelRemoveThing(thingId);\n        }, Constants.DEVICE_REMOVAL_TIMEOUT));\n        device.adapter.removeThing(device);\n      } else {\n        deferredRemove.resolve(thingId);\n      }\n    }\n\n    return deferredRemove.promise;\n  }\n\n  /**\n   * @method unloadAddons\n   * Unloads all of the loaded add-ons.\n   *\n   * @returns a promise which is resolved when all of the add-ons\n   *          are unloaded.\n   */\n  unloadAddons() {\n    if (!this.addonsLoaded) {\n      // The add-ons are not currently loaded, no need to unload.\n      return Promise.resolve();\n    }\n\n    const unloadPromises = [];\n\n    // unload the adapters in the reverse of the order that they were loaded.\n    for (const adapterId of Array.from(this.adapters.keys()).reverse()) {\n      unloadPromises.push(this.unloadAdapter(adapterId));\n    }\n\n    // unload the notifiers in the reverse of the order that they were loaded.\n    for (const notifierId of Array.from(this.notifiers.keys()).reverse()) {\n      unloadPromises.push(this.unloadNotifier(notifierId));\n    }\n\n    // unload the API handlers in the reverse of the order that they were\n    // loaded.\n    for (const packageName of Array.from(this.apiHandlers.keys()).reverse()) {\n      unloadPromises.push(this.unloadAPIHandler(packageName));\n    }\n\n    this.addonsLoaded = false;\n\n    if (this.updateTimeout) {\n      clearTimeout(this.updateTimeout);\n    }\n\n    if (this.updateInterval) {\n      clearInterval(this.updateInterval);\n    }\n\n    return Promise.all(unloadPromises).then(() => {\n      if (this.pluginServer) {\n        this.pluginServer.shutdown();\n      }\n    });\n  }\n\n  /**\n   * @method unloadAdapter\n   * Unload the given adapter.\n   *\n   * @param {String} id The ID of the adapter to unload.\n   * @returns A promise which is resolved when the adapter is unloaded.\n   */\n  unloadAdapter(id) {\n    if (!this.addonsLoaded) {\n      // The add-ons are not currently loaded, no need to unload.\n      return Promise.resolve();\n    }\n\n    const adapter = this.getAdapter(id);\n    if (typeof adapter === 'undefined') {\n      // This adapter wasn't loaded.\n      return Promise.resolve();\n    }\n\n    console.log('Unloading', adapter.name);\n    this.adapters.delete(adapter.id);\n    return adapter.unload();\n  }\n\n  /**\n   * @method unloadNotifier\n   * Unload the given notifier.\n   *\n   * @param {String} id The ID of the notifier to unload.\n   * @returns A promise which is resolved when the notifier is unloaded.\n   */\n  unloadNotifier(id) {\n    if (!this.addonsLoaded) {\n      // The add-ons are not currently loaded, no need to unload.\n      return Promise.resolve();\n    }\n\n    const notifier = this.getNotifier(id);\n    if (typeof notifier === 'undefined') {\n      // This notifier wasn't loaded.\n      return Promise.resolve();\n    }\n\n    console.log('Unloading', notifier.name);\n    this.notifiers.delete(notifier.id);\n    return notifier.unload();\n  }\n\n  /**\n   * @method unloadAPIHandler\n   * Unload the given API handler.\n   *\n   * @param {string} packageId The ID of the package the handler belongs to.\n   * @returns A promise which is resolved when the handler is unloaded.\n   */\n  unloadAPIHandler(packageId) {\n    if (!this.addonsLoaded) {\n      // The add-ons are not currently loaded, no need to unload.\n      return Promise.resolve();\n    }\n\n    const handler = this.getAPIHandler(packageId);\n    if (typeof handler === 'undefined') {\n      // This handler wasn't loaded.\n      return Promise.resolve();\n    }\n\n    console.log('Unloading', handler.packageName);\n    this.apiHandlers.delete(packageId);\n    return handler.unload();\n  }\n\n  /**\n   * @method unloadAddon\n   * Unload add-on with the given package ID.\n   *\n   * @param {String} packageId The package ID of the add-on to unload.\n   * @param {Boolean} wait Whether or not to wait for unloading to finish\n   * @returns A promise which is resolved when the add-on is unloaded.\n   */\n  unloadAddon(packageId, wait) {\n    if (!this.addonsLoaded) {\n      // The add-ons are not currently loaded, no need to unload.\n      return Promise.resolve();\n    }\n\n    if (this.extensions.hasOwnProperty(packageId)) {\n      delete this.extensions[packageId];\n    }\n\n    const plugin = this.getPlugin(packageId);\n    let pluginProcess = {};\n    if (plugin) {\n      pluginProcess = plugin.process;\n    }\n\n    const adapters = this.getAdaptersByPackageId(packageId);\n    const adapterIds = adapters.map((a) => a.id);\n    const notifiers = this.getNotifiersByPackageId(packageId);\n    const notifierIds = notifiers.map((n) => n.id);\n    const apiHandler = this.getAPIHandler(packageId);\n\n    const unloadPromises = [];\n    if (adapters.length > 0) {\n      for (const a of adapters) {\n        console.log('Unloading', a.name);\n        unloadPromises.push(a.unload());\n        this.adapters.delete(a.id);\n      }\n    }\n\n    if (notifiers.length > 0) {\n      for (const n of notifiers) {\n        console.log('Unloading', n.name);\n        unloadPromises.push(n.unload());\n        this.notifiers.delete(n.id);\n      }\n    }\n\n    if (apiHandler) {\n      console.log('Unloading API handler', packageId);\n      unloadPromises.push(apiHandler.unload());\n      this.apiHandlers.delete(packageId);\n    }\n\n    if (adapters.length === 0 && notifiers.length === 0 && !apiHandler &&\n        plugin) {\n      // If there are no adapters, notifiers, or API handlers, manually unload\n      // the plugin, otherwise it will just restart. Note that if the addon is\n      // disabled, then there might not be a plugin either.\n      plugin.unload();\n    }\n\n    // Give the process 3 seconds to exit before killing it.\n    const cleanup = () => {\n      setTimeout(() => {\n        if (pluginProcess.p) {\n          console.log(`Killing ${packageId} plugin.`);\n          pluginProcess.p.kill();\n        }\n\n        // Remove devices owned by this add-on.\n        for (const deviceId of Object.keys(this.devices)) {\n          if (adapterIds.includes(this.devices[deviceId].adapter.id)) {\n            this.handleDeviceRemoved(this.devices[deviceId]);\n          }\n        }\n\n        // Remove outlets owned by this add-on.\n        for (const outletId of Object.keys(this.outlets)) {\n          if (notifierIds.includes(this.outlets[outletId].notifier.id)) {\n            this.handleOutletRemoved(this.outlets[outletId]);\n          }\n        }\n\n        if (this.extensions.hasOwnProperty(packageId)) {\n          delete this.extensions[packageId];\n        }\n      }, Constants.UNLOAD_PLUGIN_KILL_DELAY);\n    };\n\n    const all =\n      Promise.all(unloadPromises).then(() => cleanup(), () => cleanup());\n\n    if (wait) {\n      // If wait was set, wait 3 seconds + a little for the process to die.\n      // 3 seconds, because that's what is used in unloadAddon().\n      return all.then(() => {\n        return new Promise((resolve) => {\n          setTimeout(resolve, Constants.UNLOAD_PLUGIN_KILL_DELAY + 500);\n        });\n      });\n    }\n\n    return all;\n  }\n\n  /**\n   * @method isAddonInstalled\n   *\n   * @param {String} packageId The package ID to check\n   * @returns Boolean indicating whether or not the package is installed\n   *          on the system.\n   */\n  isAddonInstalled(packageId) {\n    return this.installedAddons.has(packageId);\n  }\n\n  /**\n   * Install an add-on.\n   *\n   * @param {String} id The package ID\n   * @param {String} url The package URL\n   * @param {String} checksum SHA-256 checksum of the package\n   * @param {Boolean} enable Whether or not to enable the add-on after install\n   * @param {object} options Set of options, primarily used by external scripts\n   * @returns A Promise that resolves when the add-on is installed.\n   */\n  async installAddonFromUrl(id, url, checksum, enable, options = {}) {\n    const tempPath = fs.mkdtempSync(`${os.tmpdir()}${path.sep}`);\n    const destPath = path.join(tempPath, `${id}.tar.gz`);\n\n    console.log(`Fetching add-on ${url} as ${destPath}`);\n\n    try {\n      const res = await fetch(url);\n      if (!res.ok) {\n        throw new Error(`HTTP error status: ${res.status}`);\n      }\n\n      const dest = fs.createWriteStream(destPath);\n      await promisePipe(res.body, dest);\n    } catch (e) {\n      rimraf(tempPath, {glob: false}, (e) => {\n        if (e) {\n          console.error(`Error removing temp directory: ${tempPath}\\n${e}`);\n        }\n      });\n      throw new Error(`Failed to download add-on: ${id}\\n${e}`);\n    }\n\n    if (Utils.hashFile(destPath) !== checksum.toLowerCase()) {\n      rimraf(tempPath, {glob: false}, (e) => {\n        if (e) {\n          console.error(`Error removing temp directory: ${tempPath}\\n${e}`);\n        }\n      });\n      throw new Error(`Checksum did not match for add-on: ${id}`);\n    }\n\n    let success = false, err;\n    try {\n      await this.installAddon(id, destPath, enable, options);\n      success = true;\n    } catch (e) {\n      err = e;\n    }\n\n    rimraf(tempPath, {glob: false}, (e) => {\n      if (e) {\n        console.error(`Error removing temp directory: ${tempPath}\\n${e}`);\n      }\n    });\n\n    if (!success) {\n      throw err;\n    }\n  }\n\n  /**\n   * @method installAddon\n   *\n   * @param {String} packageId The package ID to install\n   * @param {String} packagePath Path to the package tarball\n   * @param {Boolean} enable Whether or not to enable the add-on after install\n   * @param {object} options Set of options, primarily used by external scripts\n   * @returns A promise that resolves when the package is installed.\n   */\n  async installAddon(packageId, packagePath, enable, options = {}) {\n    if (!this.addonsLoaded && !options.skipLoad) {\n      throw new Error(\n        'Cannot install add-on before other add-ons have been loaded.'\n      );\n    }\n\n    if (!fs.lstatSync(packagePath).isFile()) {\n      throw new Error(`Cannot extract invalid path: ${packagePath}`);\n    }\n\n    console.log(`Expanding add-on ${packagePath}`);\n\n    try {\n      // Try to extract the tarball\n      await tar.x({\n        file: packagePath,\n        cwd: path.dirname(packagePath),\n      }, ['package']);\n    } catch (e) {\n      throw new Error(`Failed to extract package: ${e}`);\n    }\n\n    // In case we're updating, go ahead and uninstall the existing add-on now\n    await this.uninstallAddon(packageId, true, false);\n\n    const addonPath = path.join(UserProfile.addonsDir, packageId);\n\n    // Copy the package into the proper place\n    await new Promise((resolve, reject) => {\n      ncp(\n        path.join(path.dirname(packagePath), 'package'),\n        addonPath,\n        {stopOnErr: true},\n        (err) => {\n          if (err) {\n            reject(`Failed to move package: ${err}`);\n          } else {\n            resolve();\n          }\n        }\n      );\n    });\n\n    // Update the saved settings (if any) and enable the add-on\n    const key = `addons.${packageId}`;\n    let obj = await Settings.get(key);\n    if (obj) {\n      // Only enable if we're supposed to. Otherwise, keep whatever the current\n      // setting is.\n      if (enable) {\n        obj.enabled = true;\n      }\n    } else {\n      // If this add-on is brand new, use the passed-in enable flag.\n      obj = {\n        enabled: enable,\n      };\n    }\n    await Settings.set(key, obj);\n\n    // If the add-on was previously enabled, load the add-on\n    if (obj.enabled && !options.skipLoad) {\n      // Now, load the add-on\n      try {\n        await this.loadAddon(packageId);\n      } catch (e) {\n        throw new Error(`Failed to load add-on ${packageId}: ${e}`);\n      }\n    }\n  }\n\n  /**\n   * @method uninstallAddon\n   *\n   * @param {String} packageId The package ID to uninstall\n   * @param {Boolean} wait Whether or not to wait for unloading to finish\n   * @param {Boolean} disable Whether or not to disable the add-on\n   * @returns A promise that resolves when the package is uninstalled.\n   */\n  async uninstallAddon(packageId, wait, disable) {\n    try {\n      // Try to gracefully unload\n      await this.unloadAddon(packageId, wait);\n    } catch (e) {\n      console.error(`Failed to unload ${packageId} properly: ${e}`);\n      // keep going\n    }\n\n    const addonPath = path.join(UserProfile.addonsDir, packageId);\n\n    // Unload this module from the require cache\n    Object.keys(require.cache).map((x) => {\n      if (x.startsWith(addonPath)) {\n        delete require.cache[x];\n      }\n    });\n\n    // Remove the package from the file system\n    if (fs.existsSync(addonPath) && fs.lstatSync(addonPath).isDirectory()) {\n      await new Promise((resolve, reject) => {\n        rimraf(addonPath, {glob: false}, (e) => {\n          if (e) {\n            reject(`Error removing ${packageId}: ${e}`);\n          } else {\n            resolve();\n          }\n        });\n      });\n    }\n\n    // Update the saved settings and disable the add-on\n    if (disable) {\n      const key = `addons.${packageId}`;\n      const obj = await Settings.get(key);\n      if (obj) {\n        obj.enabled = false;\n        await Settings.set(key, obj);\n      }\n    }\n\n    // Remove from our list of installed add-ons\n    this.installedAddons.delete(packageId);\n  }\n\n  /**\n   * @method waitForAdapter\n   *\n   * Returns a promise which resolves to the adapter with the indicated id.\n   * This function is really only used to support testing and\n   * ensure that tests don't proceed until\n   */\n  waitForAdapter(adapterId) {\n    const adapter = this.getAdapter(adapterId);\n    if (adapter) {\n      // The adapter already exists, just create a Promise\n      // that resolves to that.\n      return Promise.resolve(adapter);\n    }\n\n    let deferredWait = this.deferredWaitForAdapter.get(adapterId);\n    if (!deferredWait) {\n      // No deferred wait currently setup. Set a new one up.\n      deferredWait = new Deferred();\n      this.deferredWaitForAdapter.set(adapterId, deferredWait);\n    }\n\n    return deferredWait.promise;\n  }\n\n  /**\n   * @method updateAddons\n   *\n   * Attempt to update all installed add-ons.\n   *\n   * @param {object} options Set of options, primarily used by external scripts\n   * @returns A promise which is resolved when updating is complete.\n   */\n  async updateAddons(options = {}) {\n    const urls = config.get('addonManager.listUrls');\n    const architecture = Platform.getArchitecture();\n    const version = pkg.version;\n    const nodeVersion = Platform.getNodeVersion();\n    const pythonVersions = Platform.getPythonVersions();\n    const addonPath = UserProfile.addonsDir;\n    const available = {};\n\n    console.log('Checking for add-on updates...');\n\n    try {\n      const params = new URLSearchParams();\n      params.set('arch', architecture);\n      params.set('version', version);\n      params.set('node', nodeVersion);\n\n      if (pythonVersions && pythonVersions.length > 0) {\n        params.set('python', pythonVersions.join(','));\n      }\n\n      const map = new Map();\n\n      for (const url of urls) {\n        const response = await fetch(`${url}?${params.toString()}`, {\n          headers: {\n            Accept: 'application/json',\n            'User-Agent': Utils.getGatewayUserAgent(),\n          },\n        });\n\n        const addons = await response.json();\n        for (const addon of addons) {\n          // Check for duplicates, keep newest.\n          if (map.has(addon.id) &&\n              semver.gte(map.get(addon.id).version, addon.version)) {\n            continue;\n          }\n\n          map.set(addon.id, addon);\n        }\n      }\n\n      for (const addon of map.values()) {\n        available[addon.id] = {\n          version: addon.version,\n          url: addon.url,\n          checksum: addon.checksum,\n        };\n      }\n    } catch (e) {\n      console.error('Failed to parse add-on list:', e);\n      return;\n    }\n\n    // Try to update what we can. Don't use the installedAddons set because it\n    // doesn't contain add-ons that failed to load properly.\n    fs.readdir(addonPath, async (err, files) => {\n      if (err) {\n        console.error('Failed to search add-on directory');\n        console.error(err);\n        return;\n      }\n\n      for (const addonId of files) {\n        // Skip if not a directory. Use stat rather than lstat such that we\n        // also load through symlinks.\n        if (!fs.statSync(path.join(addonPath, addonId)).isDirectory()) {\n          continue;\n        }\n\n        // Skip if .git directory is present.\n        if (fs.existsSync(path.join(addonPath, addonId, '.git'))) {\n          console.log(\n            `Not updating ${addonId} since a .git directory was detected`);\n          continue;\n        }\n\n        if (options.forceUpdateBinary) {\n          // If the add-on has binary node extensions, it needs to be updated.\n          const addonIdPath = path.join(addonPath, addonId);\n          const binFiles = find.fileSync(/\\.node$/, addonIdPath);\n          if (binFiles.length > 0 && available.hasOwnProperty(addonId)) {\n            try {\n              await this.installAddonFromUrl(\n                addonId,\n                available[addonId].url,\n                available[addonId].checksum,\n                false,\n                options\n              );\n            } catch (e) {\n              console.error(`Failed to update ${addonId}: ${e}`);\n            }\n\n            continue;\n          }\n        }\n\n        // Try to load package.json.\n        const packageJson = path.join(addonPath, addonId, 'package.json');\n        const manifestJson = path.join(addonPath, addonId, 'manifest.json');\n        let manifest;\n        if (fs.existsSync(packageJson)) {\n          try {\n            const data = fs.readFileSync(packageJson);\n            manifest = JSON.parse(data);\n          } catch (e) {\n            console.error(`Failed to read package.json: ${packageJson}\\n${e}`);\n            continue;\n          }\n        } else if (fs.existsSync(manifestJson)) {\n          try {\n            const data = fs.readFileSync(manifestJson);\n            manifest = JSON.parse(data);\n          } catch (e) {\n            console.error(\n              `Failed to read manifest.json: ${manifestJson}\\n${e}`\n            );\n            continue;\n          }\n        } else {\n          continue;\n        }\n\n        // Check if an update is available.\n        if (available.hasOwnProperty(addonId) &&\n            semver.lt(manifest.version, available[addonId].version)) {\n          try {\n            await this.installAddonFromUrl(\n              addonId,\n              available[addonId].url,\n              available[addonId].checksum,\n              false,\n              options\n            );\n          } catch (e) {\n            console.error(`Failed to update ${addonId}: ${e}`);\n          }\n        }\n      }\n\n      console.log('Finished updating add-ons');\n    });\n  }\n}\n\nmodule.exports = new AddonManager();\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst find = require('find');\nconst fs = require('fs');\nconst pkg = require('../package.json');\nconst path = require('path');\nconst semver = require('semver');\nconst UserProfile = require('./user-profile');\nconst Utils = require('./utils');\n\nconst MANIFEST_VERSION = 1;\n\n// Setting this flag will force every file present in an add-on's directory to\n// have a checksum in the SHA256SUMS file. However, several add-ons currently\n// write files directly into their directories. When we resolve all of those\n// issues, this flag can be flipped.\nconst ENFORCE_STRICT_SHA_CHECK = false;\n\n/**\n * Verify one level of an object, recursing as required.\n *\n * @param {string} prefix - Prefix to use for keys, e.g. level1.level2.\n * @param {object} object - Object to validate\n * @param {object} template - Template to validate against\n *\n * @returns {string?} Error string, or undefined if no error.\n */\nfunction validateObject(prefix, object, template) {\n  for (const key in template) {\n    if (key in object) {\n      const objectVal = object[key];\n      const templateVal = template[key];\n\n      if (typeof objectVal !== typeof templateVal) {\n        return `Expecting ${prefix}${key} to have type: ${\n          typeof templateVal}, found: ${typeof objectVal}`;\n      }\n\n      if (typeof objectVal === 'object') {\n        if (Array.isArray(objectVal)) {\n          if (templateVal.length > 0) {\n            const expectedType = typeof templateVal[0];\n            for (const val of objectVal) {\n              if (typeof val !== expectedType) {\n                return `Expecting all values in ${prefix}${key} to be of ` +\n                  `type ${expectedType}`;\n              }\n            }\n          }\n        } else {\n          const err = validateObject(\n            `${prefix + key}.`,\n            objectVal,\n            templateVal\n          );\n          if (err) {\n            return err;\n          }\n        }\n      }\n    } else {\n      return `Manifest is missing: ${prefix}${key}`;\n    }\n  }\n}\n\n/**\n * Verify that a manifest.json looks valid. We only need to validate fields\n * which we actually use.\n *\n * @param {object} manifest - The parsed manifest.json manifest\n *\n * @returns {string?} Error string, or undefined if no error.\n */\nfunction validateManifestJson(manifest) {\n  const manifestTemplate = {\n    author: '',\n    description: '',\n    gateway_specific_settings: {\n      webthings: {\n        primary_type: '',\n      },\n    },\n    homepage_url: '',\n    id: '',\n    license: '',\n    manifest_version: 0,\n    name: '',\n    version: '',\n  };\n\n  // Since we're trying to use a field before full validation, make sure it\n  // exists first.\n  if (!manifest.gateway_specific_settings ||\n      !manifest.gateway_specific_settings.webthings ||\n      !manifest.gateway_specific_settings.webthings.primary_type) {\n    return '' +\n      'Expecting manifest.gateway_specific_settings.webthings.primary_type ' +\n      'to have type: string, found: undefined';\n  }\n\n  // eslint-disable-next-line max-len\n  if (manifest.gateway_specific_settings.webthings.primary_type !== 'extension') {\n    // If we're not using in-process plugins, and this is not an extension,\n    // then we also need the exec keyword to exist.\n    manifestTemplate.gateway_specific_settings.webthings.exec = '';\n  }\n\n  return validateObject('', manifest, manifestTemplate);\n}\n\n/**\n * Load an add-on manifest from a manifest.json file.\n *\n * @param {string} packageId - The ID of the package, e.g. example-adapter\n *\n * @returns {object[]} 2-value array containing a parsed manifest and a default\n *                     config object.\n */\nfunction loadManifestJson(packageId) {\n  const addonPath = path.join(UserProfile.addonsDir, packageId);\n\n  // Read the package.json file.\n  let data;\n  try {\n    data = fs.readFileSync(path.join(addonPath, 'manifest.json'));\n  } catch (e) {\n    throw new Error(\n      `Failed to read manifest.json for add-on ${packageId}: ${e}`\n    );\n  }\n\n  // Parse as JSON\n  let manifest;\n  try {\n    manifest = JSON.parse(data);\n  } catch (e) {\n    throw new Error(\n      `Failed to parse manifest.json for add-on: ${packageId}: ${e}`\n    );\n  }\n\n  // First, verify manifest version.\n  if (manifest.manifest_version !== MANIFEST_VERSION) {\n    throw new Error(\n      `Manifest version ${manifest.manifest_version} for add-on ${packageId\n      } does not match expected version ${MANIFEST_VERSION}`\n    );\n  }\n\n  // Verify that the id in the package matches the packageId\n  if (manifest.id != packageId) {\n    const err = `ID from manifest .json \"${manifest.id}\" doesn't ` +\n                `match the ID from list.json \"${packageId}\"`;\n    throw new Error(err);\n  }\n\n  // If the add-on is not a git repository, check the SHA256SUMS file.\n  if (!fs.existsSync(path.join(addonPath, '.git'))) {\n    const sumsFile = path.resolve(path.join(addonPath, 'SHA256SUMS'));\n\n    if (fs.existsSync(sumsFile)) {\n      const sums = new Map();\n\n      try {\n        const data = fs.readFileSync(sumsFile, 'utf8');\n        const lines = data.trim().split(/\\r?\\n/);\n        for (const line of lines) {\n          const checksum = line.slice(0, 64);\n          let filename = line.slice(64).trimLeft();\n\n          if (filename.startsWith('*')) {\n            filename = filename.substring(1);\n          }\n\n          filename = path.resolve(path.join(addonPath, filename));\n          if (!fs.existsSync(filename)) {\n            throw new Error(\n              `File ${filename} missing for add-on ${packageId}`\n            );\n          }\n\n          sums.set(filename, checksum);\n        }\n      } catch (e) {\n        throw new Error(\n          `Failed to read SHA256SUMS for add-on ${packageId}: ${e}`\n        );\n      }\n\n      find.fileSync(addonPath).forEach((fname) => {\n        fname = path.resolve(fname);\n\n        if (fname === sumsFile) {\n          return;\n        }\n\n        if (!sums.has(fname)) {\n          if (ENFORCE_STRICT_SHA_CHECK) {\n            throw new Error(\n              `No checksum found for file ${fname} in add-on ${packageId}`\n            );\n          } else {\n            return;\n          }\n        }\n\n        if (Utils.hashFile(fname) !== sums.get(fname)) {\n          throw new Error(\n            `Checksum failed for file ${fname} in add-on ${packageId}`\n          );\n        }\n      });\n    } else if (process.env.NODE_ENV !== 'test') {\n      throw new Error(`SHA256SUMS file missing for add-on ${packageId}`);\n    }\n  }\n\n  // Verify that important fields exist in the manifest\n  const err = validateManifestJson(manifest);\n  if (err) {\n    throw new Error(\n      `Error found in manifest for add-on ${packageId}: ${err}`\n    );\n  }\n\n  // Verify gateway version.\n  let min = manifest.gateway_specific_settings.webthings.strict_min_version;\n  let max = manifest.gateway_specific_settings.webthings.strict_max_version;\n\n  if (typeof min === 'string' && min !== '*') {\n    min = semver.coerce(min);\n    if (semver.lt(pkg.version, min)) {\n      throw new Error(\n        `Gateway version ${pkg.version} is lower than minimum version ${min\n        } supported by add-on ${packageId}`\n      );\n    }\n  }\n  if (typeof max === 'string' && max !== '*') {\n    max = semver.coerce(max);\n    if (semver.gt(pkg.version, max)) {\n      throw new Error(\n        `Gateway version ${pkg.version} is higher than maximum version ${max\n        } supported by add-on ${packageId}`\n      );\n    }\n  }\n\n  const obj = {\n    id: manifest.id,\n    author: manifest.author,\n    name: manifest.name,\n    description: manifest.description,\n    homepage_url: manifest.homepage_url,\n    version: manifest.version,\n    primary_type: manifest.gateway_specific_settings.webthings.primary_type,\n    exec: manifest.gateway_specific_settings.webthings.exec,\n    content_scripts: manifest.content_scripts,\n    web_accessible_resources: manifest.web_accessible_resources,\n    enabled: false,\n  };\n\n  let cfg = {};\n  if (manifest.hasOwnProperty('options')) {\n    if (manifest.options.hasOwnProperty('default')) {\n      cfg = manifest.options.default;\n    }\n\n    if (manifest.options.hasOwnProperty('schema')) {\n      obj.schema = manifest.options.schema;\n    }\n  }\n\n  if (manifest.gateway_specific_settings.webthings.enabled) {\n    obj.enabled = true;\n  }\n\n  return [\n    obj,\n    cfg,\n  ];\n}\n\n/**\n * Load the manifest for a given package.\n *\n * @param {string} packageId - The ID of the package, e.g. example-adapter\n *\n * @returns {object[]} 2-value array containing a parsed manifest and a default\n *                     config object.\n */\nfunction loadManifest(packageId) {\n  const addonPath = path.join(UserProfile.addonsDir, packageId);\n\n  if (fs.existsSync(path.join(addonPath, 'manifest.json'))) {\n    return loadManifestJson(packageId);\n  }\n\n  throw new Error(`No manifest found for add-on ${packageId}`);\n}\n\nmodule.exports = {\n  loadManifest,\n};\n","/*\n * WebThings Gateway App.\n *\n * Back end main script.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\n// Set up the user profile.\nconst UserProfile = require('./user-profile');\nUserProfile.init();\nconst migration = UserProfile.migrate();\n\n// Causes a timestamp to be prepended to console log lines.\nrequire('./log-timestamps');\n\n// External Dependencies\nconst https = require('https');\nconst http = require('http');\nconst fs = require('fs');\nconst express = require('express');\nconst expressWs = require('express-ws');\nconst fileUpload = require('express-fileupload');\nconst bodyParser = require('body-parser');\nconst GetOpt = require('node-getopt');\nconst config = require('config');\nconst path = require('path');\nconst expressHandlebars = require('express-handlebars');\nconst ipRegex = require('ip-regex');\nconst SegfaultHandler = require('segfault-handler');\n\n// Internal Dependencies\nconst addonManager = require('./addon-manager');\nconst Constants = require('./constants');\nconst db = require('./db');\nconst mDNSserver = require('./mdns-server');\nconst Logs = require('./models/logs');\nconst platform = require('./platform');\nconst Router = require('./router');\nconst sleep = require('./sleep');\nconst Things = require('./models/things');\nconst TunnelService = require('./ssltunnel');\nconst {RouterSetupApp, isRouterConfigured} = require('./router-setup');\nconst {WiFiSetupApp, isWiFiConfigured} = require('./wifi-setup');\n\nSegfaultHandler.registerHandler(path.join(UserProfile.logDir, 'crash.log'));\n\n// Open the databases\ndb.open();\nLogs.open();\n\nconst servers = {};\nservers.http = http.createServer();\nconst httpApp = createGatewayApp(servers.http, false);\n\nservers.https = createHttpsServer();\nlet httpsApp = null;\n\n/**\n * Creates an HTTPS server object, if successful. If there are no public and\n * private keys stored for the tunnel service, null is returned.\n *\n * @param {}\n * @return {Object|null} https server object if successful, else NULL\n */\nfunction createHttpsServer() {\n  if (!TunnelService.hasCertificates()) {\n    return null;\n  }\n\n  // HTTPS server configuration\n  const options = {\n    key: fs.readFileSync(path.join(UserProfile.sslDir, 'privatekey.pem')),\n    cert: fs.readFileSync(path.join(UserProfile.sslDir, 'certificate.pem')),\n  };\n  if (fs.existsSync(path.join(UserProfile.sslDir, 'chain.pem'))) {\n    options.ca = fs.readFileSync(path.join(UserProfile.sslDir, 'chain.pem'));\n  }\n  return https.createServer(options);\n}\n\nlet httpsAttempts = 5;\nfunction startHttpsGateway() {\n  const port = config.get('ports.https');\n\n  if (!servers.https) {\n    servers.https = createHttpsServer();\n    if (!servers.https) {\n      httpsAttempts -= 1;\n      if (httpsAttempts < 0) {\n        console.error('Unable to create HTTPS server after several tries');\n        gracefulExit();\n        process.exit(0);\n      }\n\n      return sleep(4000).then(startHttpsGateway);\n    }\n  }\n\n  httpsApp = createGatewayApp(servers.https, true);\n  servers.https.on('request', httpsApp);\n\n  const promises = [];\n\n  // Start the HTTPS server\n  promises.push(new Promise((resolve) => {\n    servers.https.listen(port, () => {\n      migration.then(() => {\n        // load existing things from the database\n        return Things.getThings();\n      }).then(() => {\n        addonManager.loadAddons();\n      });\n      rulesEngineConfigure();\n      console.log('HTTPS server listening on port',\n                  servers.https.address().port);\n      resolve();\n    });\n  }));\n\n  // Redirect HTTP to HTTPS\n  servers.http.on('request', httpsApp);\n  const httpPort = config.get('ports.http');\n\n  promises.push(new Promise((resolve) => {\n    servers.http.listen(httpPort, () => {\n      console.log('Redirector listening on port', servers.http.address().port);\n      resolve();\n    });\n  }));\n\n  return Promise.all(promises).then(() => servers.https);\n}\n\nfunction startHttpGateway() {\n  servers.http.on('request', httpApp);\n\n  const port = config.get('ports.http');\n\n  return new Promise((resolve) => {\n    servers.http.listen(port, () => {\n      migration.then(() => {\n        // load existing things from the database\n        return Things.getThings();\n      }).then(() => {\n        addonManager.loadAddons();\n      });\n      rulesEngineConfigure();\n      console.log('HTTP server listening on port', servers.http.address().port);\n      resolve();\n    });\n  });\n}\n\nfunction stopHttpGateway() {\n  servers.http.removeListener('request', httpApp);\n  servers.http.close();\n}\n\nfunction startWiFiSetup() {\n  console.log('Starting WiFi setup');\n  servers.http.on('request', WiFiSetupApp.onRequest);\n\n  const port = config.get('ports.http');\n\n  servers.http.listen(port);\n}\n\nfunction stopWiFiSetup() {\n  console.log('Stopping WiFi Setup');\n  servers.http.removeListener('request', WiFiSetupApp.onRequest);\n  servers.http.close();\n}\n\nfunction startRouterSetup() {\n  console.log('Starting Router Setup');\n  servers.http.on('request', RouterSetupApp.onRequest);\n\n  const port = config.get('ports.http');\n\n  servers.http.listen(port);\n}\n\nfunction stopRouterSetup() {\n  console.log('Stopping Router Setup');\n  servers.http.removeListener('request', RouterSetupApp.onRequest);\n  servers.http.close();\n}\n\nfunction getOptions() {\n  if (!config.get('cli')) {\n    return {\n      debug: false,\n      port: null,\n    };\n  }\n\n  // Command line arguments\n  const getopt = new GetOpt([\n    ['d', 'debug', 'Enable debug features'],\n    ['h', 'help', 'Display help'],\n    ['v', 'verbose', 'Show verbose output'],\n  ]);\n\n  const opt = getopt.parseSystem();\n  const options = {\n    debug: !!opt.options.debug, // cast to bool\n    verbose: opt.options.verbose,\n  };\n\n  if (opt.options.verbose) {\n    console.log(opt);\n  }\n\n  if (opt.options.help) {\n    getopt.showHelp();\n    process.exit(1);\n  }\n\n  if (opt.options.port) {\n    options.port = parseInt(opt.options.port);\n  }\n\n  return options;\n}\n\n/**\n * Set up the rules engine.\n */\nfunction rulesEngineConfigure() {\n  const rulesEngine = require('./rules-engine/index');\n  rulesEngine.configure();\n}\n\nfunction createApp(isSecure) {\n  const port = isSecure ? config.get('ports.https') : config.get('ports.http');\n  const app = express();\n  app.engine(\n    'handlebars',\n    expressHandlebars({\n      defaultLayout: undefined, // eslint-disable-line no-undefined\n      layoutsDir: Constants.VIEWS_PATH,\n    })\n  );\n  app.set('view engine', 'handlebars');\n  app.set('views', Constants.VIEWS_PATH);\n\n  // Redirect based on https://https.cio.gov/apis/\n  app.use((request, response, next) => {\n    // If the server is in non-HTTPS mode, or the request is already HTTPS,\n    // just carry on.\n    if (!isSecure || request.secure) {\n      next();\n      return;\n    }\n\n    // If the Host header was not set, disallow this request.\n    if (!request.hostname) {\n      response.sendStatus(403);\n      return;\n    }\n\n    // If the request is for a bare hostname, a .local address, or an IP\n    // address, allow it.\n    if (request.hostname.indexOf('.') < 0 ||\n        request.hostname.endsWith('.local') ||\n        ipRegex({exact: true}).test(request.hostname)) {\n      next();\n      return;\n    }\n\n    if (request.method !== 'GET') {\n      response.sendStatus(403);\n      return;\n    }\n\n    if (request.headers.authorization) {\n      response.sendStatus(403);\n      return;\n    }\n\n    let httpsUrl = `https://${request.hostname}`;\n\n    // If we're behind forwarding we can redirect to the port-free https url\n    if (port !== 443 && !config.get('behindForwarding')) {\n      httpsUrl += `:${port}`;\n    }\n\n    httpsUrl += request.url;\n    response.redirect(301, httpsUrl);\n  });\n\n  // Use bodyParser to access the body of requests\n  app.use(bodyParser.urlencoded({\n    extended: false,\n  }));\n  app.use(bodyParser.json({limit: '1mb'}));\n\n  // Use fileUpload to handle multi-part uploads\n  app.use(fileUpload());\n\n  return app;\n}\n\n/**\n * @param {http.Server|https.Server} server\n * @return {express.Router}\n */\nfunction createGatewayApp(server, isSecure) {\n  const app = createApp(isSecure);\n  const opt = getOptions();\n\n  // Inject WebSocket support\n  expressWs(app, server);\n\n  // Configure router with configured app and command line options.\n  Router.configure(app, opt);\n  return app;\n}\n\nconst serverStartup = {\n  promise: Promise.resolve(),\n};\n\nswitch (platform.getOS()) {\n  case 'linux-raspbian':\n    migration.then(() => {\n      return isWiFiConfigured();\n    }).then((configured) => {\n      if (!configured) {\n        WiFiSetupApp.onConnection = () => {\n          stopWiFiSetup();\n          startGateway();\n        };\n        startWiFiSetup();\n      } else {\n        startGateway();\n      }\n    });\n    break;\n  case 'linux-openwrt':\n    migration.then(() => {\n      return isRouterConfigured();\n    }).then((configured) => {\n      if (!configured) {\n        RouterSetupApp.onConnection = () => {\n          stopRouterSetup();\n          startGateway();\n        };\n        startRouterSetup();\n      } else {\n        startGateway();\n      }\n    });\n    break;\n  default:\n    startGateway();\n    break;\n}\n\nfunction startGateway() {\n  // if we have the certificates installed, we start https\n  if (TunnelService.hasCertificates()) {\n    serverStartup.promise = TunnelService.userSkipped().then((skipped) => {\n      const promise = startHttpsGateway();\n\n      // if the user opted to skip the tunnel, but still has certificates, go\n      // ahead and start up the https server.\n      if (skipped) {\n        return promise;\n      }\n\n      // if they did not opt to skip, check if they have a tunnel token. if so,\n      // start the tunnel.\n      return promise.then((server) => {\n        TunnelService.hasTunnelToken().then((result) => {\n          if (result) {\n            TunnelService.setServerHandle(server);\n            TunnelService.start();\n          }\n        });\n      });\n    });\n  } else {\n    serverStartup.promise = startHttpGateway();\n  }\n}\n\nfunction gracefulExit() {\n  addonManager.unloadAddons();\n  TunnelService.stop();\n}\n\nif (config.get('cli')) {\n  // Get some decent error messages for unhandled rejections. This is\n  // often just errors in the code.\n  process.on('unhandledRejection', (reason) => {\n    console.log('Unhandled Rejection');\n    console.error(reason);\n  });\n\n  // Do graceful shutdown when Control-C is pressed.\n  process.on('SIGINT', () => {\n    console.log('Control-C: Exiting gracefully');\n    gracefulExit();\n    process.exit(0);\n  });\n}\n\n// function to stop running server and start https\nTunnelService.switchToHttps = () => {\n  stopHttpGateway();\n  startHttpsGateway().then((server) => {\n    TunnelService.setServerHandle(server);\n  });\n};\n\n// This part starts our Service Discovery process.\n// We check to see if mDNS should be setup in default mode, or has a previous\n// user setup a unique domain. Then we start it.\nmDNSserver.getmDNSstate().then((state) => {\n  if (platform.implemented('setMdnsServerStatus')) {\n    platform.setMdnsServerStatus(state);\n  }\n});\n\n// for testing\nmodule.exports = {\n  servers,\n  serverStartup,\n};\n","/**\n * Certificate Manager.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst acme = require('acme-client');\nconst config = require('config');\nconst fetch = require('node-fetch');\nconst fs = require('fs');\nconst path = require('path');\nconst Settings = require('./models/settings');\nconst sleep = require('./sleep');\nconst {URLSearchParams} = require('url');\nconst UserProfile = require('./user-profile');\n\nconst DEBUG = false || (process.env.NODE_ENV === 'test');\n\nconst DIRECTORY_URL = acme.directory.letsencrypt.production;\n\n// For test purposes, uncomment the following:\n// const DIRECTORY_URL = acme.directory.letsencrypt.staging;\n// process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\n/**\n * Write certificates generated by registration/renewal to disk.\n *\n * @param {string} certificate - The generated certificate\n * @param {string} privateKey - The generated private key\n * @param {string} chain - The generated certificate chain\n */\nfunction writeCertificates(certificate, privateKey, chain) {\n  fs.writeFileSync(\n    path.join(UserProfile.sslDir, 'certificate.pem'),\n    certificate\n  );\n  fs.writeFileSync(\n    path.join(UserProfile.sslDir, 'privatekey.pem'),\n    privateKey\n  );\n  fs.writeFileSync(\n    path.join(UserProfile.sslDir, 'chain.pem'),\n    chain\n  );\n}\n\n/**\n * Register domain with Let's Encrypt and get certificates.\n *\n * @param {string} email - User's email address\n * @param {string?} reclamationToken - Reclamation token, if applicable\n * @param {string} subdomain - The subdomain being registered\n * @param {string} fulldomain - The full domain being registered\n * @param {boolean} optout - Whether or not the user opted out of emails\n * @param {function} callback - Callback function\n */\nasync function register(email, reclamationToken, subdomain, fulldomain,\n                        optout, callback) {\n  if (DEBUG) {\n    console.debug('Starting registration:', email, reclamationToken, subdomain,\n                  fulldomain, optout);\n  } else {\n    console.log('Starting registration');\n  }\n\n  const endpoint = config.get('ssltunnel.registration_endpoint');\n  let token;\n\n  // First, try to register the subdomain with the registration server.\n  try {\n    const params = new URLSearchParams();\n    params.set('name', subdomain);\n    params.set('email', email);\n\n    if (reclamationToken) {\n      params.set('reclamationToken', reclamationToken.trim());\n    }\n\n    const subscribeUrl = `${endpoint}/subscribe?${params.toString()}`;\n    const res = await fetch(subscribeUrl);\n    const jsonToken = await res.json();\n\n    if (DEBUG) {\n      console.debug('Sent subscription to registration server:', jsonToken);\n    } else {\n      console.log('Sent subscription to registration server');\n    }\n\n    if (jsonToken.error) {\n      console.log('Error received from registration server:', jsonToken.error);\n      callback(jsonToken.error);\n      return;\n    }\n\n    token = jsonToken.token;\n\n    // Store the token in the db\n    await Settings.set('tunneltoken', jsonToken);\n  } catch (e) {\n    console.error('Failed to subscribe:', e);\n    callback(e);\n    return;\n  }\n\n  // Now we associate user's email with the subdomain, unless it was reclaimed\n  if (!reclamationToken) {\n    const params = new URLSearchParams();\n    params.set('token', token);\n    params.set('email', email);\n    params.set('optout', optout);\n\n    try {\n      await fetch(`${endpoint}/setemail?${params.toString()}`);\n      console.log('Set email on server.');\n    } catch (e) {\n      console.error('Failed to set email on server:', e);\n\n      // https://github.com/mozilla-iot/gateway/issues/358\n      // we should store this error and display to the user on\n      // settings page to allow him to retry\n      callback(e);\n      return;\n    }\n  }\n\n  /**\n   * Function used to satisfy an ACME challenge\n   *\n   * @param {object} authz Authorization object\n   * @param {object} challenge Selected challenge\n   * @param {string} keyAuthorization Authorization key\n   * @returns {Promise}\n   */\n  const challengeCreateFn = async (_authz, _challenge, keyAuthorization) => {\n    const params = new URLSearchParams();\n    params.set('token', token);\n    params.set('challenge', keyAuthorization);\n\n    // Now that we have a challenge, we call our registration server to\n    // setup the TXT record\n    const response = await fetch(`${endpoint}/dnsconfig?${params.toString()}`);\n    if (!response.ok) {\n      throw new Error(`Failed to set DNS token on server: ${response.status}`);\n    }\n\n    console.log('Set DNS token on registration server');\n\n    // Let's wait a few seconds for changes to propagate on the registration\n    // server and its database.\n    await sleep(2500);\n  };\n\n  /**\n   * Function used to remove an ACME challenge response\n   *\n   * @param {object} authz Authorization object\n   * @param {object} challenge Selected challenge\n   * @param {string} keyAuthorization Authorization key\n   * @returns {Promise}\n   */\n  const challengeRemoveFn = async (_authz, _challenge, _keyAuthorization) => {\n    // do nothing for now\n  };\n\n  try {\n    // create an ACME client\n    const client = new acme.Client({\n      directoryUrl: DIRECTORY_URL,\n      accountKey: await acme.forge.createPrivateKey(),\n    });\n\n    // create a CSR\n    const [key, csr] = await acme.forge.createCsr({\n      commonName: fulldomain,\n    });\n\n    // run the ACME registration\n    const cert = await client.auto({\n      csr,\n      email: config.get('ssltunnel.certemail'),\n      termsOfServiceAgreed: true,\n      skipChallengeVerification: true,\n      challengePriority: ['dns-01'],\n      challengeCreateFn,\n      challengeRemoveFn,\n    });\n\n    if (DEBUG) {\n      console.debug('Private Key:', key.toString());\n      console.debug('CSR:', csr.toString());\n      console.debug('Certificate(s):', cert.toString());\n    } else {\n      console.log('Received certificate from Let\\'s Encrypt');\n    }\n\n    const chain = cert\n      .toString()\n      .trim()\n      .split(/[\\r\\n]{2,}/g)\n      .map((s) => `${s}\\n`);\n\n    writeCertificates(chain[0], key.toString(), chain.join('\\n'));\n    console.log('Wrote certificates to file system');\n  } catch (e) {\n    console.error('Failed to generate certificate:', e);\n    callback(e);\n    return;\n  }\n\n  console.log('Registration success!');\n  callback();\n}\n\n/**\n * Try to renew the certificates associated with this domain.\n *\n * @param {Object} server - HTTPS server handle\n */\nasync function renew(server) {\n  console.log('Starting certificate renewal.');\n\n  // Check if we need to renew yet\n  try {\n    const oldCert = fs.readFileSync(\n      path.join(UserProfile.sslDir, 'certificate.pem')\n    );\n    const info = await acme.forge.readCertificateInfo(oldCert);\n    const now = new Date();\n\n    const oneWeek = 7 * 24 * 60 * 60 * 1000;\n    if (info.notAfter - now >= oneWeek) {\n      console.log('Certificate not yet due for renewal.');\n      return;\n    }\n  } catch (_e) {\n    // pass. move on to renewal.\n  }\n\n  let tunnelToken;\n  try {\n    tunnelToken = await Settings.get('tunneltoken');\n  } catch (e) {\n    console.error('Tunnel token not set!');\n    return;\n  }\n\n  /**\n   * Function used to satisfy an ACME challenge\n   *\n   * @param {object} authz Authorization object\n   * @param {object} challenge Selected challenge\n   * @param {string} keyAuthorization Authorization key\n   * @returns {Promise}\n   */\n  const challengeCreateFn = async (_authz, challenge, keyAuthorization) => {\n    const params = new URLSearchParams();\n    params.set('token', tunnelToken.token);\n    params.set('challenge', keyAuthorization);\n\n    // Now that we have a challenge, we call our registration server to\n    // setup the TXT record\n    const endpoint = config.get('ssltunnel.registration_endpoint');\n    const response = await fetch(`${endpoint}/dnsconfig?${params.toString()}`);\n    if (!response.ok) {\n      throw new Error(`Failed to set DNS token on server: ${response.status}`);\n    }\n\n    console.log('Set DNS token on registration server');\n\n    // Let's wait a few seconds for changes to propagate on the registration\n    // server and its database.\n    await sleep(2500);\n  };\n\n  /**\n   * Function used to remove an ACME challenge response\n   *\n   * @param {object} authz Authorization object\n   * @param {object} challenge Selected challenge\n   * @param {string} keyAuthorization Authorization key\n   * @returns {Promise}\n   */\n  const challengeRemoveFn = async (_authz, _challenge, _keyAuthorization) => {\n    // do nothing for now\n  };\n\n  const domain = `${tunnelToken.name}.${config.get('ssltunnel.domain')}`;\n\n  try {\n    // create an ACME client\n    const client = new acme.Client({\n      directoryUrl: DIRECTORY_URL,\n      accountKey: await acme.forge.createPrivateKey(),\n    });\n\n    // create a CSR\n    const [key, csr] = await acme.forge.createCsr({\n      commonName: domain,\n    });\n\n    // run the ACME registration\n    const cert = await client.auto({\n      csr,\n      email: config.get('ssltunnel.certemail'),\n      termsOfServiceAgreed: true,\n      skipChallengeVerification: true,\n      challengePriority: ['dns-01'],\n      challengeCreateFn,\n      challengeRemoveFn,\n    });\n\n    if (DEBUG) {\n      console.debug('Private Key:', key.toString());\n      console.debug('CSR:', csr.toString());\n      console.debug('Certificate(s):', cert.toString());\n    } else {\n      console.log('Received certificate from Let\\'s Encrypt');\n    }\n\n    const chain = cert\n      .toString()\n      .trim()\n      .split(/[\\r\\n]{2,}/g)\n      .map((s) => `${s}\\n`);\n\n    writeCertificates(chain[0], key.toString(), chain.join('\\n'));\n    console.log('Wrote certificates to file system');\n\n    if (server) {\n      const ctx = server._sharedCreds.context;\n      ctx.setCert(chain[0]);\n      ctx.setKey(key.toString());\n      ctx.addCACert(chain.join('\\n'));\n    }\n  } catch (e) {\n    console.error('Failed to renew certificate:', e);\n    return;\n  }\n\n  console.log('Renewal success!');\n}\n\nmodule.exports = {\n  register,\n  renew,\n};\n","/*\n * WebThings Gateway Constants.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst path = require('path');\n\n// Web server routes\nexports.USERS_PATH = '/users';\nexports.THINGS_PATH = '/things';\nexports.PROPERTIES_PATH = '/properties';\nexports.NEW_THINGS_PATH = '/new_things';\nexports.ADAPTERS_PATH = '/adapters';\nexports.ADDONS_PATH = '/addons';\nexports.NOTIFIERS_PATH = '/notifiers';\nexports.ACTIONS_PATH = '/actions';\nexports.EVENTS_PATH = '/events';\nexports.LOGIN_PATH = '/login';\nexports.LOG_OUT_PATH = '/log-out';\nexports.SETTINGS_PATH = '/settings';\nexports.UPDATES_PATH = '/updates';\nexports.UPLOADS_PATH = '/uploads';\nexports.MEDIA_PATH = '/media';\nexports.DEBUG_PATH = '/debug';\nexports.RULES_PATH = '/rules';\nexports.OAUTH_PATH = '/oauth';\nexports.OAUTHCLIENTS_PATH = '/authorizations';\nexports.INTERNAL_LOGS_PATH = '/internal-logs';\nexports.LOGS_PATH = '/logs';\nexports.PUSH_PATH = '/push';\nexports.PING_PATH = '/ping';\nexports.PROXY_PATH = '/proxy';\nexports.EXTENSIONS_PATH = '/extensions';\n// Remember we end up in the build/* directory so these paths looks slightly\n// different than you might expect.\nexports.STATIC_PATH = path.join(__dirname, '../static');\nexports.BUILD_STATIC_PATH = path.join(__dirname, '../build/static');\nexports.VIEWS_PATH = path.join(__dirname, '../build/views');\n\n// Plugin and REST/websocket API things\nexports.ACTION_STATUS = 'actionStatus';\nexports.ADAPTER_ADDED = 'adapterAdded';\nexports.ADD_EVENT_SUBSCRIPTION = 'addEventSubscription';\nexports.API_HANDLER_ADDED = 'apiHandlerAdded';\nexports.CONNECTED = 'connected';\nexports.ERROR = 'error';\nexports.EVENT = 'event';\nexports.MODIFIED = 'modified';\nexports.NOTIFIER_ADDED = 'notifierAdded';\nexports.OUTLET_ADDED = 'outletAdded';\nexports.OUTLET_REMOVED = 'outletRemoved';\nexports.PAIRING_TIMEOUT = 'pairingTimeout';\nexports.PROPERTY_CHANGED = 'propertyChanged';\nexports.PROPERTY_STATUS = 'propertyStatus';\nexports.REMOVED = 'removed';\nexports.REQUEST_ACTION = 'requestAction';\nexports.SET_PROPERTY = 'setProperty';\nexports.THING_ADDED = 'thingAdded';\nexports.THING_MODIFIED = 'thingModified';\nexports.THING_REMOVED = 'thingRemoved';\n\n// OAuth things\nexports.ACCESS_TOKEN = 'access_token';\nexports.AUTHORIZATION_CODE = 'authorization_code';\nexports.USER_TOKEN = 'user_token';\nexports.READWRITE = 'readwrite';\nexports.READ = 'read';\n\n// Logging\nexports.LogSeverity = {\n  DEBUG: 0,\n  INFO: 1,\n  WARNING: 2,\n  ERROR: 3,\n  PROMPT: 4,\n};\n\nexports.UNLOAD_PLUGIN_KILL_DELAY = 3000;\nexports.DEVICE_REMOVAL_TIMEOUT = 30000;\n","/**\n * Actions Controller.\n *\n * Manages the top level actions queue for the gateway and things.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst PromiseRouter = require('express-promise-router');\nconst Action = require('../models/action');\nconst Actions = require('../models/actions');\nconst AddonManager = require('../addon-manager');\nconst Things = require('../models/things');\n\nconst ActionsController = PromiseRouter({mergeParams: true});\n\n/**\n * Handle creating a new action.\n */\nActionsController.post('/', async (request, response) => {\n  const keys = Object.keys(request.body);\n  if (keys.length != 1) {\n    const err = 'Incorrect number of parameters.';\n    console.log(err, request.body);\n    response.status(400).send(err);\n    return;\n  }\n\n  const actionName = keys[0];\n\n  if (!Object.prototype.hasOwnProperty.call(request.body[actionName],\n                                            'input')) {\n    response.status(400).send('Missing input');\n    return;\n  }\n\n  const actionParams = request.body[actionName].input;\n  const thingId = request.params.thingId;\n  let action = null;\n\n  if (thingId) {\n    try {\n      const thing = await Things.getThing(thingId);\n      action = new Action(actionName, actionParams, thing);\n    } catch (e) {\n      console.error('Thing does not exist', thingId, e);\n      response.status(404).send(e);\n      return;\n    }\n  } else {\n    action = new Action(actionName, actionParams);\n  }\n\n  try {\n    if (thingId) {\n      await AddonManager.requestAction(\n        thingId, action.id, actionName, actionParams);\n    }\n    await Actions.add(action);\n\n    response.status(201).json({[actionName]: action.getDescription()});\n  } catch (e) {\n    console.error('Creating action', actionName, 'failed');\n    console.error(e);\n    response.status(400).send(e);\n  }\n});\n\n/**\n * Handle getting a list of actions.\n */\nActionsController.get('/', (request, response) => {\n  if (request.params.thingId) {\n    response.status(200).json(Actions.getByThing(request.params.thingId));\n  } else {\n    response.status(200).json(Actions.getGatewayActions());\n  }\n});\n\n/**\n * Handle getting a list of actions.\n */\nActionsController.get('/:actionName', (request, response) => {\n  const actionName = request.params.actionName;\n  if (request.params.thingId) {\n    response.status(200).json(Actions.getByThing(request.params.thingId,\n                                                 actionName));\n  } else {\n    response.status(200).json(Actions.getGatewayActions(actionName));\n  }\n});\n\n/**\n * Handle creating a new action.\n */\nActionsController.post('/:actionName', async (request, response) => {\n  const actionName = request.params.actionName;\n\n  const keys = Object.keys(request.body);\n  if (keys.length != 1) {\n    const err = 'Incorrect number of parameters.';\n    console.log(err, request.body);\n    response.status(400).send(err);\n    return;\n  }\n\n  if (actionName !== keys[0]) {\n    const err = `Action name must be ${actionName}`;\n    console.log(err, request.body);\n    response.status(400).send(err);\n    return;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(request.body[actionName],\n                                            'input')) {\n    response.status(400).send('Missing input');\n    return;\n  }\n\n  const actionParams = request.body[actionName].input;\n  const thingId = request.params.thingId;\n  let action = null;\n\n  if (thingId) {\n    try {\n      const thing = await Things.getThing(thingId);\n      action = new Action(actionName, actionParams, thing);\n    } catch (e) {\n      console.error('Thing does not exist', thingId, e);\n      response.status(404).send(e);\n      return;\n    }\n  } else {\n    action = new Action(actionName, actionParams);\n  }\n\n  try {\n    if (thingId) {\n      await AddonManager.requestAction(\n        thingId, action.id, actionName, actionParams);\n    }\n    await Actions.add(action);\n\n    response.status(201).json({[actionName]: action.getDescription()});\n  } catch (e) {\n    console.error('Creating action', actionName, 'failed');\n    console.error(e);\n    response.status(400).send(e);\n  }\n});\n\n/**\n * Handle getting a particular action.\n */\nActionsController.get('/:actionName/:actionId', (request, response) => {\n  const actionId = request.params.actionId;\n  const action = Actions.get(actionId);\n  if (action) {\n    response.status(200).json({[action.name]: action.getDescription()});\n  } else {\n    const error = `Action \"${actionId}\" not found`;\n    console.error(error);\n    response.status(404).send(error);\n  }\n});\n\n/**\n * Handle cancelling an action.\n */\nActionsController.delete(\n  '/:actionName/:actionId',\n  async (request, response) => {\n    const actionName = request.params.actionName;\n    const actionId = request.params.actionId;\n    const thingId = request.params.thingId;\n\n    if (thingId) {\n      try {\n        await AddonManager.removeAction(thingId, actionId, actionName);\n      } catch (e) {\n        console.error('Removing action', actionId, 'failed');\n        console.error(e);\n        response.status(400).send(e);\n        return;\n      }\n    }\n\n    try {\n      Actions.remove(actionId);\n    } catch (e) {\n      console.error('Removing action', actionId, 'failed');\n      console.error(e);\n      response.status(404).send(e);\n      return;\n    }\n\n    response.sendStatus(204);\n  });\n\nmodule.exports = ActionsController;\n","/**\n * Adapter Controller.\n *\n * Manages HTTP requests to /adapters.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst express = require('express');\nconst addonManager = require('../addon-manager');\n\nconst adaptersController = express.Router();\n\n/**\n * Return a list of adapters\n */\nadaptersController.get('/', (request, response) => {\n  const adapters = addonManager.getAdapters();\n  const adapterList = Array.from(adapters.values()).map((adapter) => {\n    return adapter.asDict();\n  });\n  response.json(adapterList);\n});\n\n/**\n * Get a particular adapter.\n */\nadaptersController.get('/:adapterId/', (request, response) => {\n  const adapterId = request.params.adapterId;\n  const adapter = addonManager.getAdapter(adapterId);\n  if (adapter) {\n    response.json(adapter.asDict());\n  } else {\n    response.status(404).send(`Adapter \"${adapterId}\" not found.`);\n  }\n});\n\nmodule.exports = adaptersController;\n","'use strict';\n\nconst PromiseRouter = require('express-promise-router');\nconst AddonManager = require('../addon-manager');\nconst Settings = require('../models/settings');\nconst UserProfile = require('../user-profile');\nconst fs = require('fs');\nconst path = require('path');\n\nconst AddonsController = PromiseRouter();\n\nAddonsController.get('/', async (request, response) => {\n  response.status(200).json(Array.from(AddonManager.installedAddons.values()));\n});\n\nAddonsController.get('/:addonId/license', async (request, response) => {\n  const addonId = request.params.addonId;\n  const addonDir = path.join(UserProfile.addonsDir, addonId);\n\n  fs.readdir(addonDir, (err, files) => {\n    if (err) {\n      response.status(404).send(err);\n      return;\n    }\n\n    const licenses = files.filter((f) => {\n      return /^LICENSE(\\..*)?$/.test(f) &&\n        fs.lstatSync(path.join(addonDir, f)).isFile();\n    });\n\n    if (licenses.length === 0) {\n      response.status(404).send('License not found');\n      return;\n    }\n\n    fs.readFile(\n      path.join(addonDir, licenses[0]),\n      {encoding: 'utf8'},\n      (err, data) => {\n        if (err) {\n          response.status(404).send(err);\n          return;\n        }\n\n        response.status(200).type('text/plain').send(data);\n      }\n    );\n  });\n});\n\nAddonsController.put('/:addonId', async (request, response) => {\n  const addonId = request.params.addonId;\n\n  if (!request.body || !request.body.hasOwnProperty('enabled')) {\n    response.status(400).send('Enabled property not defined');\n    return;\n  }\n\n  const enabled = request.body.enabled;\n\n  try {\n    if (enabled) {\n      await AddonManager.enableAddon(addonId);\n    } else {\n      await AddonManager.disableAddon(addonId, true);\n    }\n\n    response.status(200).json({enabled});\n  } catch (e) {\n    console.error(`Failed to toggle add-on ${addonId}`);\n    console.error(e);\n    response.status(400).send(e);\n  }\n});\n\nAddonsController.get('/:addonId/config', async (request, response) => {\n  const addonId = request.params.addonId;\n  const key = `addons.config.${addonId}`;\n\n  try {\n    const config = await Settings.get(key);\n    response.status(200).json(config || {});\n  } catch (e) {\n    console.error(`Failed to get config for add-on ${addonId}`);\n    console.error(e);\n    response.status(400).send(e);\n  }\n});\n\nAddonsController.put('/:addonId/config', async (request, response) => {\n  const addonId = request.params.addonId;\n\n  if (!request.body || !request.body.hasOwnProperty('config')) {\n    response.status(400).send('Config property not defined');\n    return;\n  }\n\n  const config = request.body.config;\n  const key = `addons.config.${addonId}`;\n\n  try {\n    await Settings.set(key, config);\n  } catch (e) {\n    console.error(`Failed to set config for add-on ${addonId}`);\n    console.error(e);\n    response.status(400).send(e);\n    return;\n  }\n\n  try {\n    await AddonManager.unloadAddon(addonId, true);\n\n    if (await AddonManager.addonEnabled(addonId)) {\n      await AddonManager.loadAddon(addonId);\n    }\n\n    response.status(200).json({config});\n  } catch (e) {\n    console.error(`Failed to restart add-on ${addonId}`);\n    console.error(e);\n    response.status(400).send(e);\n  }\n});\n\nAddonsController.post('/', async (request, response) => {\n  if (!request.body ||\n      !request.body.hasOwnProperty('id') ||\n      !request.body.hasOwnProperty('url') ||\n      !request.body.hasOwnProperty('checksum')) {\n    response.status(400).send('Missing required parameter(s).');\n    return;\n  }\n\n  const id = request.body.id;\n  const url = request.body.url;\n  const checksum = request.body.checksum;\n\n  try {\n    await AddonManager.installAddonFromUrl(id, url, checksum, true);\n    const key = `addons.${id}`;\n    const obj = await Settings.get(key);\n    response.status(200).json(obj);\n  } catch (e) {\n    response.status(400).send(e);\n  }\n});\n\nAddonsController.patch('/:addonId', async (request, response) => {\n  const id = request.params.addonId;\n\n  if (!request.body ||\n      !request.body.hasOwnProperty('url') ||\n      !request.body.hasOwnProperty('checksum')) {\n    response.status(400).send('Missing required parameter(s).');\n    return;\n  }\n\n  const url = request.body.url;\n  const checksum = request.body.checksum;\n\n  try {\n    await AddonManager.installAddonFromUrl(id, url, checksum, false);\n    const key = `addons.${id}`;\n    const obj = await Settings.get(key);\n    response.status(200).json(obj);\n  } catch (e) {\n    console.error(`Failed to update add-on: ${id}\\n${e}`);\n    response.status(400).send(e);\n  }\n});\n\nAddonsController.delete('/:addonId', async (request, response) => {\n  const addonId = request.params.addonId;\n\n  try {\n    await AddonManager.uninstallAddon(addonId, false, true);\n    response.sendStatus(204);\n  } catch (e) {\n    console.error(`Failed to uninstall add-on: ${addonId}\\n${e}`);\n    response.status(400).send(e);\n  }\n});\n\nmodule.exports = AddonsController;\n","/**\n * Debug Controller.\n *\n * Manages HTTP requests to /debug/adapters.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Constants = require('../constants');\nconst express = require('express');\nconst addonManager = require('../addon-manager');\n\nconst debugController = express.Router();\n\naddonManager.on(Constants.ADAPTER_ADDED, (adapter) => {\n  console.log('debug: Got:', Constants.ADAPTER_ADDED,\n              'notification for', adapter.id, adapter.name);\n});\n\naddonManager.on(Constants.THING_ADDED, (thing) => {\n  console.log('debug: Got:', Constants.THING_ADDED,\n              'notification for', thing.title);\n});\n\naddonManager.on(Constants.THING_REMOVED, (thing) => {\n  console.log('debug: Got:', Constants.THING_REMOVED,\n              'notification for', thing.title);\n});\n\naddonManager.on(Constants.PROPERTY_CHANGED, (property) => {\n  console.log('debug: Got:', Constants.PROPERTY_CHANGED,\n              'notification for:', property.device.title,\n              'property:', property.name,\n              'value:', property.value);\n});\n\naddonManager.on(Constants.PAIRING_TIMEOUT, () => {\n  console.log('debug: Got:', Constants.PAIRING_TIMEOUT,\n              'notification');\n});\n\n/**\n * List all known adapters\n */\ndebugController.get('/adapters', (request, response) => {\n  const adapters = addonManager.getAdapters();\n  response.status(200).json(Array.from(adapters.values()).map((adapter) => {\n    return adapter.asDict();\n  }));\n});\n\n/**\n * Add a new device\n */\ndebugController.get('/addNewThing', (request, response) => {\n  addonManager.addNewThing(60).then(() => {\n    console.log('debugController: addNewThing added thing');\n  }, () => {\n    console.log('debugController: addNewThing cancelled');\n  });\n  response.sendStatus(204);\n});\n\n/**\n * Cancel adding a new device\n */\ndebugController.get('/cancelAddNewThing', (request, response) => {\n  addonManager.cancelAddNewThing();\n  response.sendStatus(204);\n});\n\n/**\n * Cancel removing a device;\n */\ndebugController.get('/cancelRemoveThing/:thingId', (request, response) => {\n  const thingId = request.params.thingId;\n  addonManager.cancelRemoveThing(thingId);\n  response.sendStatus(204);\n});\n\n/**\n * Get a list of devices ids registered with the add-on manager.\n */\ndebugController.get('/deviceIds', (request, response) => {\n  const devices = addonManager.getDevices();\n  const deviceList = [];\n  for (const deviceId in devices) {\n    const device = addonManager.devices[deviceId];\n    deviceList.push(device.id);\n  }\n  response.status(200).json(deviceList);\n});\n\n/**\n * Get a list of the devices registered with the add-on manager.\n */\ndebugController.get('/devices', (request, response) => {\n  const devices = addonManager.getDevices();\n  const deviceList = [];\n  for (const deviceId in devices) {\n    const device = addonManager.devices[deviceId];\n    deviceList.push(device.asDict());\n  }\n  response.status(200).json(deviceList);\n});\n\n/**\n * Get a particular device registered with the add-on manager.\n */\ndebugController.get('/device/:deviceId', (request, response) => {\n  const deviceId = request.params.deviceId;\n  const device = addonManager.getDevice(deviceId);\n  if (device) {\n    response.status(200).json(device.asDict());\n  } else {\n    response.status(404).send(`Device \"${deviceId}\" not found.`);\n  }\n});\n\n/**\n * Gets an property from a device.\n */\ndebugController.get('/device/:deviceId/:propertyName', (request, response) => {\n  const deviceId = request.params.deviceId;\n  const propertyName = request.params.propertyName;\n  const device = addonManager.getDevice(deviceId);\n  if (device) {\n    device.getProperty(propertyName).then((value) => {\n      const valueDict = {};\n      valueDict[propertyName] = value;\n      response.status(200).json(valueDict);\n    }).catch((error) => {\n      console.log(`Device \"${deviceId}\"`);\n      console.log(error);\n      response.status(404).send(`Device \"${deviceId}${error}`);\n    });\n  } else {\n    response.status(404).send(`Device \"${deviceId}\" not found.`);\n  }\n});\n\n/**\n * Sends a debug command to a particular device.\n */\ndebugController.put('/device/:deviceId/cmd/:cmd', (request, response) => {\n  const deviceId = request.params.deviceId;\n  const device = addonManager.getDevice(deviceId);\n  if (device) {\n    device.debugCmd(request.params.cmd, request.body);\n    response.status(200).json(request.body);\n  } else {\n    response.status(404).send(`Device \"${deviceId}\" not found.`);\n  }\n});\n\n/**\n * Sets an property associated with a device.\n */\ndebugController.put('/device/:deviceId/:propertyName', (request, response) => {\n  const deviceId = request.params.deviceId;\n  const propertyName = request.params.propertyName;\n  const device = addonManager.getDevice(deviceId);\n  if (device) {\n    const propertyValue = request.body[propertyName];\n    if (typeof propertyValue !== 'undefined') {\n      device.setProperty(propertyName, propertyValue).then((updatedValue) => {\n        const valueDict = {};\n        valueDict[propertyName] = updatedValue;\n        response.status(200).json(valueDict);\n      }).catch((error) => {\n        console.log(`Device \"${deviceId}\"`);\n        console.log(error);\n        response.status(404).send(`Device \"${deviceId}\" ${error}`);\n      });\n    } else {\n      response.status(404).send(`Device \"${deviceId\n      }\" property \"${propertyName\n      }\" not found in request.`);\n    }\n  } else {\n    response.status(404).send(`Device \"${deviceId}\" not found.`);\n  }\n});\n\n/**\n * Get a list of plugins\n */\ndebugController.get('/plugins', (request, response) => {\n  const plugins = Array.from(addonManager.pluginServer.plugins.values());\n  response.status(200).json(plugins.map((plugin) => {\n    return plugin.asDict();\n  }));\n});\n\n/**\n * Get a list of the things registered with the add-on manager.\n */\ndebugController.get('/things', (request, response) => {\n  response.status(200).json(addonManager.getThings());\n});\n\n/**\n * Get a particular thing registered with the add-on manager.\n */\ndebugController.get('/thing/:thingId', (request, response) => {\n  const thingId = request.params.thingId;\n  const thing = addonManager.getThing(thingId);\n  if (thing) {\n    response.status(200).json(thing);\n  } else {\n    response.status(404).send(`Thing \"${thingId}\" not found.`);\n  }\n});\n\n/**\n * Gets a property associated with a thing.\n */\ndebugController.get('/thing/:thingId/:propertyName', (request, response) => {\n  const thingId = request.params.thingId;\n  const propertyName = request.params.propertyName;\n  const thing = addonManager.getThing(thingId);\n  if (thing) {\n    addonManager.getProperty(thing.id, propertyName).then((value) => {\n      const valueDict = {};\n      valueDict[propertyName] = value;\n      response.status(200).json(valueDict);\n    }).catch((error) => {\n      response.status(404).send(`Thing \"${thingId} ${error}`);\n    });\n  } else {\n    response.status(404).send(`Thing \"${thingId}\" not found.`);\n  }\n});\n\n/**\n * Sets a property associated with a thing.\n */\ndebugController.put('/thing/:thingId/:propertyName', (request, response) => {\n  const thingId = request.params.thingId;\n  const propertyName = request.params.propertyName;\n  const thing = addonManager.getThing(thingId);\n  if (thing) {\n    const propertyValue = request.body[propertyName];\n    if (typeof propertyValue !== 'undefined') {\n      addonManager.setProperty(propertyName, propertyValue).then((value) => {\n        const valueDict = {};\n        valueDict[propertyName] = value;\n        response.status(200).json(valueDict);\n      }).catch((error) => {\n        console.log(`Thing \"${thingId}`);\n        console.log(error);\n        response.status(404).send(`Thing \"${thingId} ${error}`);\n      });\n    } else {\n      response.status(404).send(`Thing \"${thingId\n      }\" property \"${propertyName\n      }\" not found in request.`);\n    }\n  } else {\n    response.status(404).send(`Thing \"${thingId}\" not found.`);\n  }\n});\n\n/**\n * Remove an existing Thing.\n */\ndebugController.get('/removeThing/:thingId', (request, response) => {\n  const thingId = request.params.thingId;\n  addonManager.removeThing(thingId).then((thingIdRemoved) => {\n    console.log('debugController: removed', thingIdRemoved);\n    if (thingId != thingIdRemoved) {\n      console.log('debugController: Actually removed', thingIdRemoved,\n                  'even though request was for:', thingId);\n    }\n    response.status(200).json({removed: thingIdRemoved});\n  }, (str) => {\n    console.log('debugController: remove failed:', str);\n    response.status(500).send(`remove of ${thingId} failed: ${str}`);\n  });\n});\n\n/**\n * Unload add-ons\n */\ndebugController.get('/unloadAddons', (request, response) => {\n  console.log('debugController: Unloading Add-ons');\n  addonManager.unloadAddons();\n  response.status(200).send('');\n});\n\nmodule.exports = debugController;\n","/**\n * Events Controller.\n *\n * Manages the top level events queue for the gateway and things.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst express = require('express');\nconst Events = require('../models/events');\n\nconst EventsController = express.Router({mergeParams: true});\n\n/**\n * Handle getting a list of events.\n */\nEventsController.get('/', (request, response) => {\n  if (request.params.thingId) {\n    response.status(200).json(Events.getByThing(request.params.thingId));\n  } else {\n    response.status(200).json(Events.getGatewayEvents());\n  }\n});\n\n/**\n * Handle getting a list of events.\n */\nEventsController.get('/:eventName', (request, response) => {\n  const eventName = request.params.eventName;\n\n  if (request.params.thingId) {\n    response.status(200).json(Events.getByThing(request.params.thingId,\n                                                eventName));\n  } else {\n    response.status(200).json(Events.getGatewayEvents(eventName));\n  }\n});\n\nmodule.exports = EventsController;\n","'use strict';\n\nconst AddonManager = require('../addon-manager');\nconst {APIRequest} = require('gateway-addon');\nconst UserProfile = require('../user-profile');\nconst express = require('express');\nconst fs = require('fs');\nconst globToRegExp = require('glob-to-regexp');\nconst jwtMiddleware = require('../jwt-middleware');\nconst path = require('path');\n\nconst auth = jwtMiddleware.middleware();\nconst ExtensionsController = express.Router();\n\nExtensionsController.get('/', auth, (request, response) => {\n  const map = {};\n  for (const [key, value] of Object.entries(AddonManager.getExtensions())) {\n    map[key] = value.extensions;\n  }\n  response.status(200).json(map);\n});\n\n/**\n * Extension API handler.\n */\nExtensionsController.all(\n  '/:extensionId/api/*',\n  auth,\n  async (request, response) => {\n    const extensionId = request.params.extensionId;\n    const apiHandler = AddonManager.getAPIHandler(extensionId);\n    if (!apiHandler) {\n      response.status(404).send(`Extension \"${extensionId}\" not found.`);\n      return;\n    }\n\n    const req = new APIRequest({\n      method: request.method,\n      path: `/${request.path.split('/').slice(3).join('/')}`,\n      query: request.query || {},\n      body: request.body || {},\n    });\n\n    try {\n      const rsp = await apiHandler.handleRequest(req);\n      response.status(rsp.status);\n\n      if (rsp.contentType && rsp.content !== null) {\n        response.type(rsp.contentType);\n        response.send(rsp.content);\n      } else {\n        response.end();\n      }\n    } catch (e) {\n      console.error('Error calling API handler:', e);\n      response.status(500).send(e);\n    }\n  }\n);\n\n/**\n * Static resource handler for extensions. This is intentionally\n * unauthenticated, since we're just loading static content.\n */\nExtensionsController.get('/:extensionId/*', (request, response) => {\n  const extensionId = request.params.extensionId;\n  const relPath = request.path.split('/').slice(2).join('/');\n\n  // make sure the extension is installed and enabled\n  const extensions = AddonManager.getExtensions();\n  if (!extensions.hasOwnProperty(extensionId)) {\n    response.status(404).send();\n    return;\n  }\n\n  // make sure the requested resource is listed in the extension's\n  // web_accessible_resources array\n  let matched = false;\n  const resources = extensions[extensionId].resources;\n  for (let resource of resources) {\n    resource = globToRegExp(resource);\n    if (resource.test(relPath)) {\n      matched = true;\n      break;\n    }\n  }\n\n  if (!matched) {\n    response.status(404).send();\n    return;\n  }\n\n  // make sure the file actually exists\n  const fullPath = path.join(UserProfile.addonsDir, extensionId, relPath);\n  if (!fs.existsSync(fullPath)) {\n    response.status(404).send();\n    return;\n  }\n\n  // finally, send the file\n  response.sendFile(fullPath);\n});\n\nmodule.exports = ExtensionsController;\n","/**\n * Internal logs Controller.\n *\n * Allows user to download current set of internal log files.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst archiver = require('archiver');\nconst express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst PromiseRouter = require('express-promise-router');\nconst WebSocket = require('ws');\n\nconst AddonManager = require('../addon-manager');\nconst Constants = require('../constants');\nconst jwtMiddleware = require('../jwt-middleware');\nconst UserProfile = require('../user-profile');\nconst Utils = require('../utils');\n\nconst InternalLogsController = PromiseRouter();\n\n/**\n * Generate an index of log files.\n */\nInternalLogsController.get('/', async (request, response) => {\n  const jwt = jwtMiddleware.extractJWTHeader(request) ||\n    jwtMiddleware.extractJWTQS(request);\n  const files = fs.readdirSync(UserProfile.logDir)\n    .filter((f) => !f.startsWith('.') && f !== 'logs.sqlite3');\n  files.sort();\n\n  let content =\n    '<!DOCTYPE html>' +\n    '<html lang=\"en\">' +\n    '<head>' +\n    '<meta charset=\"utf-8\">' +\n    '<title>Logs - WebThings Gateway</title>' +\n    '</head>' +\n    '<body>' +\n    '<ul>';\n\n  for (const name of files) {\n    if (fs.lstatSync(path.join(UserProfile.logDir, name)).isFile()) {\n      content +=\n        `${'<li>' +\n        `<a href=\"${Constants.INTERNAL_LOGS_PATH}/files/${encodeURIComponent(name)}?jwt=${jwt}\">`}${\n          Utils.escapeHtml(name)\n        }</a>` +\n        `</li>`;\n    }\n  }\n\n  content +=\n    '</ul>' +\n    '</body>' +\n    '</html>';\n\n  response.send(content);\n});\n\n/**\n * Static handler for log files.\n */\nInternalLogsController.use(\n  '/files',\n  express.static(\n    UserProfile.logDir,\n    {\n      setHeaders: (res, filepath) => {\n        const base = path.basename(filepath);\n        if (base.startsWith('run-app.log')) {\n          res.set('Content-Type', 'text/plain');\n        }\n      },\n    }\n  )\n);\n\n/**\n * Handle request for logs.zip.\n */\nInternalLogsController.get('/zip', async (request, response) => {\n  const archive = archiver('zip');\n\n  archive.on('error', (err) => {\n    response.status(500).send(err.message);\n  });\n\n  response.attachment('logs.zip');\n\n  archive.pipe(response);\n  fs.readdirSync(\n    UserProfile.logDir\n  ).map((f) => {\n    const fullPath = path.join(UserProfile.logDir, f);\n    if (!f.startsWith('.') && fs.lstatSync(fullPath).isFile() &&\n        f !== 'logs.sqlite3') {\n      archive.file(fullPath, {name: path.join('logs', f)});\n    }\n  });\n  archive.finalize();\n});\n\nInternalLogsController.ws('/', (websocket) => {\n  if (websocket.readyState !== WebSocket.OPEN) {\n    return;\n  }\n\n  const heartbeat = setInterval(() => {\n    try {\n      websocket.ping();\n    } catch (e) {\n      websocket.terminate();\n    }\n  }, 30 * 1000);\n\n  function onLog(message) {\n    websocket.send(JSON.stringify(message), (err) => {\n      if (err) {\n        console.error('WebSocket sendMessage failed:', err);\n      }\n    });\n  }\n\n  AddonManager.pluginServer.on('log', onLog);\n\n  const cleanup = () => {\n    AddonManager.pluginServer.removeListener('log', onLog);\n    clearInterval(heartbeat);\n  };\n\n  websocket.on('error', cleanup);\n  websocket.on('close', cleanup);\n});\n\nmodule.exports = InternalLogsController;\n","/**\n * LogOut Controller.\n *\n * Handles logging out the user.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Router = require('express-promise-router');\n\nconst JSONWebToken = require('../models/jsonwebtoken');\n\nconst LogOutController = new Router();\n\n/**\n * Log out the user\n */\nLogOutController.post('/', async (request, response) => {\n  const {jwt} = request;\n  await JSONWebToken.revokeToken(jwt.keyId);\n  response.status(200).json({});\n});\n\nmodule.exports = LogOutController;\n","/**\n * Login Controller.\n *\n * Handles user login.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst path = require('path');\n\nconst Router = require('express-promise-router');\nconst Users = require('../models/users');\nconst JSONWebToken = require('../models/jsonwebtoken');\nconst Passwords = require('../passwords');\nconst Constants = require('../constants');\nconst rateLimit = require('express-rate-limit');\n\nconst LoginController = Router();\n\nconst loginRoot = path.join(Constants.BUILD_STATIC_PATH, 'login');\n\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 10,                  // 10 failed requests per windowMs\n  skipSuccessfulRequests: true,\n});\n\n/**\n * Serve the static login page\n */\nLoginController.get('/', async (request, response) => {\n  response.sendFile('index.html', {root: loginRoot});\n});\n\n/**\n * Handle login request.\n */\nLoginController.post('/', limiter, async (request, response) => {\n  const {body} = request;\n  if (!body || !body.email || !body.password) {\n    response.status(400).send('User requires email and password');\n    return;\n  }\n\n  const user = await Users.getUser(body.email.toLowerCase());\n  if (!user) {\n    response.sendStatus(401);\n    return;\n  }\n\n  const passwordMatch = await Passwords.compare(\n    body.password,\n    user.password\n  );\n\n  if (!passwordMatch) {\n    response.sendStatus(401);\n    return;\n  }\n\n  if (user.mfaEnrolled) {\n    if (!body.mfa) {\n      response.status(401).json({mfaRequired: true});\n      return;\n    }\n\n    if (!Passwords.verifyMfaToken(user.mfaSharedSecret, body.mfa)) {\n      let backupMatch = false;\n\n      if (body.mfa.totp.length === 12) {\n        let index = 0;\n        for (const backup of user.mfaBackupCodes) {\n          backupMatch = await Passwords.compare(body.mfa.totp, backup);\n          if (backupMatch) {\n            break;\n          }\n\n          ++index;\n        }\n\n        if (backupMatch) {\n          user.mfaBackupCodes.splice(index, 1);\n          await Users.editUser(user);\n        }\n      }\n\n      if (!backupMatch) {\n        response.status(401).json({mfaRequired: true});\n        return;\n      }\n    }\n  }\n\n  // Issue a new JWT for this user.\n  const jwt = await JSONWebToken.issueToken(user.id);\n  limiter.resetKey(request.ip);\n  response.status(200).json({jwt});\n});\n\nmodule.exports = LoginController;\n","/**\n * Logs Controller.\n *\n * Manages HTTP requests to /logs.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst PromiseRouter = require('express-promise-router');\nconst WebSocket = require('ws');\n\nconst Constants = require('../constants');\nconst Logs = require('../models/logs');\n\nconst LogsController = PromiseRouter();\n\n/**\n * Get a list of all currently logged properties\n */\nLogsController.get('/.schema', async (request, response) => {\n  const schema = await Logs.getSchema();\n  response.status(200).json(schema);\n});\n\n/**\n * Register a new metric\n */\nLogsController.post('/', async (request, response) => {\n  const descr = request.body.descr;\n  const maxAge = request.body.maxAge;\n  if (!descr || typeof maxAge !== 'number') {\n    response.status(400).send('Invalid descr or maxAge property');\n    return;\n  }\n  let normalizedDescr = '';\n  switch (descr.type) {\n    case 'property':\n      normalizedDescr = Logs.propertyDescr(descr.thing, descr.property);\n      break;\n    case 'action':\n      normalizedDescr = Logs.actionDescr(descr.thing, descr.action);\n      break;\n    case 'event':\n      normalizedDescr = Logs.eventDescr(descr.thing, descr.event);\n      break;\n    default:\n      response.status(400).send('Invalid descr type');\n      return;\n  }\n\n  try {\n    const id = await Logs.registerMetric(normalizedDescr, maxAge);\n    if (typeof id === 'undefined') {\n      response.status(400).send('Log already exists');\n      return;\n    }\n    response.status(200).send({\n      descr: normalizedDescr,\n    });\n  } catch (e) {\n    console.error('Failed to register log:', e);\n    response.status(500).send(`Error registering: ${e.message}`);\n  }\n});\n\n/**\n * Get all the values of the currently logged properties\n */\nLogsController.get('/', async (request, response) => {\n  // if (request.jwt.payload.role !== Constants.USER_TOKEN) {\n  //   if (!request.jwt.payload.scope) {\n  //     response.status(400).send('Token must contain scope');\n  //   } else {\n  //     const scope = request.jwt.payload.scope;\n  //     if (scope.indexOf(' ') === -1 && scope.indexOf('/') == 0 &&\n  //       scope.split('/').length == 2 &&\n  //       scope.split(':')[0] === Constants.THINGS_PATH) {\n  //       Things.getThingDescriptions(request.get('Host'), request.secure)\n  //         .then((things) => {\n  //           response.status(200).json(things);\n  //         });\n  //     } else {\n  //       // Get hrefs of things in scope\n  //       const paths = scope.split(' ');\n  //       const hrefs = new Array(0);\n  //       for (const path of paths) {\n  //         const parts = path.split(':');\n  //         hrefs.push(parts[0]);\n  //       }\n  //       Things.getListThingDescriptions(hrefs,\n  //                                       request.get('Host'),\n  //                                       request.secure)\n  //         .then((things) => {\n  //           response.status(200).json(things);\n  //         });\n  //     }\n  //   }\n  // } else\n  try {\n    const logs = await Logs.getAll(request.query.start, request.query.end);\n    response.status(200).json(logs);\n  } catch (e) {\n    console.error('Failed to get logs:', e);\n    response.status(500).send(`Internal error: ${e}`);\n  }\n});\n\n/**\n * Get a historical list of the values of all a Thing's properties\n */\nLogsController.get(`${Constants.THINGS_PATH}/:thingId`, async (request, response) => {\n  const id = request.params.thingId;\n  try {\n    const logs = await Logs.get(id, request.query.start, request.query.end);\n    response.status(200).json(logs);\n  } catch (error) {\n    console.error(`Error getting logs for thing with id ${id}`);\n    console.error(`Error: ${error}`);\n    response.status(404).send(error);\n  }\n});\n\nconst missingPropertyPath =\n  `${Constants.THINGS_PATH}/:thingId${Constants.PROPERTIES_PATH}`;\nconst singlePropertyPath =\n  `${Constants.THINGS_PATH}/:thingId${Constants.PROPERTIES_PATH}/:propertyName`;\n\n/**\n * Get a historical list of the values of a Thing's property\n */\nLogsController.get(\n  [missingPropertyPath, singlePropertyPath],\n  async (request, response) => {\n    const thingId = request.params.thingId;\n    const propertyName = request.params.propertyName || '';\n    try {\n      const values = await Logs.getProperty(thingId, propertyName,\n                                            request.query.start,\n                                            request.query.end);\n      response.status(200).json(values || []);\n    } catch (err) {\n      response.status(404).send(err);\n    }\n  }\n);\n\nLogsController.delete(\n  [missingPropertyPath, singlePropertyPath],\n  async (request, response) => {\n    const thingId = request.params.thingId;\n    const propertyName = request.params.propertyName || '';\n    const normalizedDescr = Logs.propertyDescr(thingId, propertyName);\n\n    try {\n      await Logs.unregisterMetric(normalizedDescr);\n      response.status(200).send({\n        descr: normalizedDescr,\n      });\n    } catch (e) {\n      console.error('Failed to delete log:', e);\n      response.status(500).send(`Internal error: ${e}`);\n    }\n  }\n);\n\nLogsController.ws('/', (websocket) => {\n  if (websocket.readyState !== WebSocket.OPEN) {\n    return;\n  }\n\n  const heartbeat = setInterval(() => {\n    try {\n      websocket.ping();\n    } catch (e) {\n      websocket.terminate();\n    }\n  }, 30 * 1000);\n\n  function streamMetric(metrics) {\n    if (!metrics || metrics.length === 0) {\n      return;\n    }\n    try {\n      websocket.send(JSON.stringify(metrics), (_err) => {});\n    } catch (_e) {\n      // Just don't let it crash anything\n    }\n  }\n\n  const cleanup = () => {\n    clearInterval(heartbeat);\n  };\n\n  Logs.streamAll(streamMetric).then(() => {\n    cleanup();\n    // Eventually send dynamic property value updates for the graphs to update\n    // in real time\n    websocket.close();\n  });\n\n  websocket.on('error', cleanup);\n  websocket.on('close', cleanup);\n});\nmodule.exports = LogsController;\n","/**\n * New Things Controller.\n *\n * /new_things returns a list of Things connected/paired with the gateway which\n * haven't yet been added to the gateway database.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst PromiseRouter = require('express-promise-router');\nconst fetch = require('node-fetch');\nconst WebSocket = require('ws');\nconst Things = require('../models/things');\n\nconst NewThingsController = PromiseRouter();\n\n/**\n * Handle GET requests to /new_things\n */\nNewThingsController.get('/', (request, response) => {\n  Things.getNewThings().then((newThings) => {\n    response.json(newThings);\n  }).catch((error) => {\n    console.error(`Error getting a list of new things from adapters ${error}`);\n    response.status(500).send(error);\n  });\n});\n\n/**\n * Handle a WebSocket request on /new_things\n */\nNewThingsController.ws('/', (websocket) => {\n  // Since the Gateway have the asynchronous express middlewares, there is a\n  // possibility that the WebSocket have been closed.\n  if (websocket.readyState !== WebSocket.OPEN) {\n    return;\n  }\n  console.log('Opened a new things socket');\n  // Register the WebSocket with the Things model so new devices can be pushed\n  // to the client as they are added.\n  Things.registerWebsocket(websocket);\n  // Send a list of things the adapter manager already knows about\n  Things.getNewThings().then(function(newThings) {\n    newThings.forEach((newThing) => {\n      websocket.send(JSON.stringify(newThing));\n    }, this);\n  }).catch((error) => {\n    console.error(`Error getting a list of new things from adapters ${error}`);\n  });\n});\n\n/**\n * Handle POST requests to /new_things\n */\nNewThingsController.post('/', async (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('url')) {\n    response.status(400).send('No URL in thing description');\n    return;\n  }\n\n  const url = request.body.url;\n  try {\n    const res = await fetch(url, {headers: {Accept: 'application/json'}});\n\n    if (!res.ok) {\n      response.status(400).send('Web thing not found');\n      return;\n    }\n\n    const description = await res.json();\n\n    // Verify some high level thing description properties.\n    if ((description.hasOwnProperty('title') ||\n         description.hasOwnProperty('name')) &&  // backwards compat\n        (description.hasOwnProperty('properties') ||\n         description.hasOwnProperty('actions') ||\n         description.hasOwnProperty('events'))) {\n      response.json(description);\n    } else if (Array.isArray(description)) {\n      response.status(400).send('Web things must be added individually');\n    } else {\n      response.status(400).send('Invalid thing description');\n    }\n  } catch (e) {\n    response.status(400).send('Web thing not found');\n  }\n});\n\nmodule.exports = NewThingsController;\n","'use strict';\n\nconst AddonManager = require('../addon-manager');\nconst {NotificationLevel} = require('gateway-addon').Constants;\nconst PromiseRouter = require('express-promise-router');\n\nconst NotifiersController = PromiseRouter();\n\n/**\n * Helper function to cut down on unnecessary API round trips\n * @param {Notifier} notifier\n * @return {Object}\n */\nfunction notifierAsDictWithOutlets(notifier) {\n  const notifierDict = notifier.asDict();\n  const outlets = notifier.getOutlets();\n  notifierDict.outlets = Array.from(Object.values(outlets)).map((outlet) => {\n    return outlet.asDict();\n  });\n  return notifierDict;\n}\n\nNotifiersController.get('/', async (request, response) => {\n  const notifiers = AddonManager.getNotifiers();\n  const notifierList = Array.from(notifiers.values())\n    .map(notifierAsDictWithOutlets);\n  response.status(200).json(notifierList);\n});\n\nNotifiersController.get('/:notifierId', async (request, response) => {\n  const notifierId = request.params.notifierId;\n  const notifier = AddonManager.getNotifier(notifierId);\n  if (notifier) {\n    response.status(200).send(notifierAsDictWithOutlets(notifier));\n  } else {\n    response.status(404).send(`Notifier \"${notifierId}\" not found.`);\n  }\n});\n\nNotifiersController.get('/:notifierId/outlets', async (request, response) => {\n  const notifierId = request.params.notifierId;\n  const notifier = AddonManager.getNotifier(notifierId);\n  if (!notifier) {\n    response.status(404).send(`Notifier \"${notifierId}\" not found.`);\n    return;\n  }\n  const outlets = notifier.getOutlets();\n  const outletList = Array.from(Object.values(outlets)).map((outlet) => {\n    return outlet.asDict();\n  });\n  response.status(200).json(outletList);\n});\n\n/**\n * Create a new notification with the title, message, and level contained in\n * the request body\n */\nNotifiersController.post(`/:notifierId/outlets/:outletId/notification`, async (request, response) => {\n  const notifierId = request.params.notifierId;\n  const outletId = request.params.outletId;\n  const notifier = AddonManager.getNotifier(notifierId);\n  if (!notifier) {\n    response.status(404).send(`Notifier \"${notifierId}\" not found.`);\n    return;\n  }\n  const outlet = notifier.getOutlet(outletId);\n  if (!outlet) {\n    response.status(404).send(`Outlet \"${outletId}\" of notifier \"${notifierId}\" not found.`);\n    return;\n  }\n  const {title, message, level} = request.body;\n  if (typeof title !== 'string' || typeof message !== 'string') {\n    response.status(400).send(`Title and message must be strings`);\n    return;\n  }\n  const levels = Object.values(NotificationLevel);\n  if (!levels.includes(level)) {\n    response.status(400).send(`Level must be one of ${JSON.stringify(levels)}`);\n    return;\n  }\n  try {\n    await outlet.notify(title, message, level);\n    response.status(201);\n  } catch (e) {\n    response.status(500).send(e);\n  }\n});\n\nmodule.exports = NotifiersController;\n\n","/**\n * OAuth Controller.\n *\n * Handles a simple OAuth2 flow with a hardcoded client\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nimport * as express from 'express';\nimport { URL } from 'url';\nimport * as assert from 'assert';\nconst JSONWebToken = require('../models/jsonwebtoken');\nconst config = require('config');\nimport * as Database from '../db';\nimport {\n  scopeValidSubset, Scope, ScopeAccess, ScopeRaw, ClientId, ClientRegistry\n} from '../oauth-types';\n\nimport OAuthClients from '../models/oauthclients';\nimport * as jwtMiddleware from '../jwt-middleware';\nimport * as Constants from '../constants';\n\nconst auth = jwtMiddleware.middleware();\n\nconst OAuthController = express.Router();\n\ntype InvalidRequest = 'invalid_request';\ntype UnauthorizedClient = 'unauthorized_client';\n\ntype OAuthRequest = {\n  client_id: ClientId,\n  redirect_uri: URL|undefined,\n  state?: string\n};\n\n// https://tools.ietf.org/html/rfc6749#section-4.1.1\ntype AuthorizationRequest = {\n  response_type: string,\n  client_id: ClientId,\n  redirect_uri: URL|undefined,\n  scope: ScopeRaw,\n  state?: string\n};\n\ntype AuthorizationCode = string;\ntype AuthorizationError =\n  'invalid_request' | 'unauthorized_client' | 'access_denied' |\n  'unsupported_response_type' | 'invalid_scope' | 'server_error' |\n  'temporarily_unavailable';\n\ntype AuthorizationSuccessResponse = {\n  code: AuthorizationCode,\n  state: string|undefined\n};\n\ntype ErrorResponse<T> = {\n  error: T,\n  error_description?: string,\n  error_uri?: URL,\n  state?: string\n};\n\ntype AuthorizationErrorResponse = ErrorResponse<AuthorizationError>;\n\ntype AuthorizationResponse =\n  AuthorizationSuccessResponse|AuthorizationErrorResponse;\n\n// https://tools.ietf.org/html/rfc6749#section-4.1.3\ntype AccessTokenRequest = {\n  grant_type: 'authorization_code',\n  code: AuthorizationCode,\n  redirect_uri: URL|undefined,\n  client_id: ClientId\n};\n\ntype Token = string; // JWT\n\ntype AccessTokenSuccessResponse = {\n  access_token: Token,\n  token_type: 'bearer',\n  expires_in?: number,\n  refresh_token?: Token,\n  scope: ScopeRaw\n};\n\ntype AccessTokenError =\n  'invalid_request' | 'invalid_client' | 'invalid_grant' |\n  'unauthorized_client' | 'unsupported_grant_type' | 'invalid_scope';\n\ntype AccessTokenErrorResponse = ErrorResponse<AccessTokenError>;\ntype AccessTokenResponse = AccessTokenSuccessResponse|AccessTokenErrorResponse;\n\ntype RefreshTokenRequest = {\n  grant_type: 'refresh_token',\n  refresh_token: Token,\n  scope: ScopeRaw\n};\n\ntype RefreshTokenResponse = AccessTokenResponse;\n\nfunction redirect(response: express.Response, baseURL: URL, params: {[key: string]: any}) {\n  let url = new URL(baseURL.toString());\n  for (let key in params) {\n    if (!params.hasOwnProperty(key)) {\n      continue;\n    }\n    if (typeof params[key] !== 'undefined') {\n      url.searchParams.set(key, params[key].toString());\n    }\n  }\n  if (url.hostname === 'gateway.localhost') {\n    response.redirect(url.toString().replace(/^https:\\/\\/gateway\\.localhost/, ''));\n    return;\n  }\n  response.redirect(url.toString());\n}\n\nfunction verifyClient(request: OAuthRequest, response: express.Response):\n  ClientRegistry|null {\n  let client = OAuthClients.get(request.client_id, request.redirect_uri);\n  if (!client) {\n    let err: ErrorResponse<UnauthorizedClient> = {\n      error: 'unauthorized_client',\n      error_description: 'client id unknown',\n      state: request.state\n    };\n\n    response.status(400).json(err);\n    return null;\n  }\n\n  if (!request.redirect_uri) {\n    request.redirect_uri = client.redirect_uri;\n  }\n\n  if (request.redirect_uri!.toString() !== client.redirect_uri.toString()) {\n    let err: ErrorResponse<InvalidRequest> = {\n      error: 'invalid_request',\n      error_description: 'mismatched redirect_uri',\n      state: request.state\n    };\n\n    response.status(400).json(err);\n    return null;\n  }\n\n  return client;\n}\n\nfunction extractClientInfo(request: express.Request, response: express.Response):\n    {clientId: string, clientSecret: string}|undefined {\n  let authorization = request.headers.authorization;\n  if (!authorization) {\n    if (!request.body.client_id) {\n      return;\n    }\n    return {\n      clientId: request.body.client_id,\n      clientSecret: request.body.client_secret,\n    };\n  }\n\n  if (typeof authorization !== 'string' || !authorization.startsWith('Basic ')) {\n    let err: ErrorResponse<UnauthorizedClient> = {\n      error: 'unauthorized_client',\n      error_description: 'authorization header missing or malformed',\n    };\n\n    response.status(400).json(err);\n    return;\n  }\n\n  let userPassB64 = authorization.substring('Basic '.length);\n  let userPass = Buffer.from(userPassB64, 'base64').toString();\n\n  let parts = userPass.split(':');\n  if (parts.length !== 2) {\n    let err: ErrorResponse<UnauthorizedClient> = {\n      error: 'unauthorized_client',\n      error_description: 'authorization header missing or malformed',\n    };\n\n    response.status(400).json(err);\n    return;\n  }\n\n  return {\n    clientId: decodeURIComponent(parts[0].replace(/\\+/g, '%20')),\n    clientSecret: decodeURIComponent(parts[1].replace(/\\+/g, '%20')),\n  };\n}\n\nfunction verifyAuthorizationRequest(authRequest: AuthorizationRequest,\n                                    response: express.Response):\n                                      ClientRegistry|undefined {\n  let client = verifyClient(authRequest, response);\n  if (!client) {\n    return;\n  }\n\n  if (authRequest.response_type !== 'code') {\n    let err: AuthorizationErrorResponse = {\n      error: 'unsupported_response_type',\n      state: authRequest.state\n    };\n    redirect(\n      response,\n      client.redirect_uri,\n      err\n    );\n    return;\n  }\n\n  if (!scopeValidSubset(client.scope, authRequest.scope)) {\n    let err: AuthorizationErrorResponse = {\n      error: 'invalid_scope',\n      error_description: 'client scope does not cover requested scope',\n      state: authRequest.state\n    };\n    redirect(\n      response,\n      client.redirect_uri,\n      err\n    );\n    return;\n  }\n\n  return client;\n}\n\nOAuthController.get('/authorize', async (request: express.Request, response: express.Response) => {\n  let redirect_uri;\n  if (request.query.redirect_uri) {\n    redirect_uri = new URL(`${request.query.redirect_uri}`);\n  }\n\n  // From query component construct\n  let authRequest: AuthorizationRequest = {\n    response_type: `${request.query.response_type}`,\n    client_id: `${request.query.client_id}`,\n    redirect_uri: redirect_uri,\n    scope: `${request.query.scope}`,\n    state: `${request.query.state}`\n  };\n\n  let client = verifyAuthorizationRequest(authRequest, response);\n  if (!client) {\n    return;\n  }\n\n  response.render('authorize', {\n    name: client.name,\n    domain: client.redirect_uri.host,\n    request: authRequest\n  });\n});\n\nOAuthController.get('/local-token-service', async (request: express.Request, response: express.Response) => {\n  let localClient: ClientRegistry = OAuthClients.get('local-token', undefined)!;\n  let tokenRequest: AccessTokenRequest = {\n    grant_type: 'authorization_code',\n    code: `${request.query.code}`,\n    redirect_uri: localClient.redirect_uri,\n    client_id: localClient.id\n  };\n  request.body = tokenRequest;\n  request.headers.authorization = 'Basic ' +\n    Buffer.from(localClient.id + ':' + localClient.secret).toString('base64');\n  let token = await handleAccessTokenRequest(request, response);\n  if (token) {\n    response.render('local-token-service', {\n      oauthPostToken: config.get('oauthPostToken'),\n      token: token.access_token\n    });\n  }\n});\n\nOAuthController.get('/allow', auth, async (request: express.Request, response: express.Response) => {\n  let redirect_uri;\n  if (request.query.redirect_uri) {\n    redirect_uri = new URL(`${request.query.redirect_uri}`);\n  }\n\n  let authRequest: AuthorizationRequest = {\n    response_type: `${request.query.response_type}`,\n    client_id: `${request.query.client_id}`,\n    redirect_uri: redirect_uri,\n    scope: `${request.query.scope}`,\n    state: `${request.query.state}`\n  };\n\n  let client = verifyAuthorizationRequest(authRequest, response);\n  if (!client) {\n    return;\n  }\n\n  let jwt = (request as any).jwt;\n  if (!jwt) {\n    return;\n  }\n\n  if (!jwt.payload || jwt.payload.role !== 'user_token') {\n    response.status(401).send('Authorization must come from user');\n    return;\n  }\n\n  // TODO: should expire in 10 minutes\n  let code = await JSONWebToken.issueOAuthToken(client, jwt.user, {\n    role: 'authorization_code',\n    scope: authRequest.scope\n  });\n\n  let success: AuthorizationSuccessResponse = {\n    code: code,\n    state: authRequest.state\n  };\n\n  redirect(\n    response,\n    client.redirect_uri,\n    success\n  );\n});\n\nOAuthController.post('/token', async (request: express.Request, response: express.Response) => {\n  const requestData = request.body;\n  if (requestData.grant_type === 'authorization_code') {\n    let token = await handleAccessTokenRequest(request, response);\n    if (token) {\n      response.json(token);\n    }\n    return;\n  }\n  // if (requestData.grant_type === 'refresh_token') {\n  //   handleRefreshTokenRequest(request, response);\n  // }\n  let err: AccessTokenErrorResponse = {\n    error: 'unsupported_grant_type',\n    state: requestData.state\n  };\n  response.status(400).json(err);\n});\n\n/**\n * Handles the request for an access token using an authorization code.\n * On error sends a 400 with a JSON reason.\n */\nasync function handleAccessTokenRequest(request: express.Request, response: express.Response):\n    Promise<AccessTokenSuccessResponse|undefined> {\n  const requestData = request.body;\n  let reqClientInfo = extractClientInfo(request, response);\n  if (!reqClientInfo) {\n    let err: ErrorResponse<UnauthorizedClient> = {\n      error: 'unauthorized_client',\n      error_description: 'client info missing or malformed',\n    };\n\n    response.status(400).json(err);\n    return;\n  }\n\n  let tokenRequest: AccessTokenRequest = {\n    grant_type: requestData.grant_type,\n    code: requestData.code,\n    redirect_uri: requestData.redirect_uri && new URL(requestData.redirect_uri),\n    client_id: reqClientInfo.clientId,\n  };\n\n  let client = verifyClient(tokenRequest, response);\n  if (!client) {\n    return;\n  }\n\n  if (client.id !== reqClientInfo.clientId ||\n      client.secret !== reqClientInfo.clientSecret) {\n    let err: ErrorResponse<UnauthorizedClient> = {\n      error: 'unauthorized_client',\n      error_description: 'client info mismatch',\n    };\n\n    response.status(400).json(err);\n    return;\n  }\n\n  let tokenData = await JSONWebToken.verifyJWT(tokenRequest.code);\n  if (!tokenData) {\n    let err: AccessTokenErrorResponse = {\n      error: 'invalid_grant',\n      error_description: 'included JWT is invalid',\n      state: request.body.state\n    };\n\n    response.status(400).json(err);\n    return;\n  }\n\n  let payload = tokenData.payload;\n  if (!payload || payload.role !== 'authorization_code' || payload.client_id !== client.id) {\n    let err: AccessTokenErrorResponse = {\n      error: 'invalid_grant',\n      state: request.body.state\n    };\n\n    response.status(400).json(err);\n    return;\n  }\n\n  let accessToken = await JSONWebToken.issueOAuthToken(client, tokenData.user, {\n    role: Constants.ACCESS_TOKEN,\n    scope: tokenData.payload.scope\n  });\n\n  // let refreshToken = await JSONWebToken.issueOAuthToken(client, 'refresh_token');\n\n  let res: AccessTokenSuccessResponse = {\n    access_token: accessToken,\n    token_type: 'bearer',\n    // refresh_token: refreshToken,\n    scope: client.scope\n  };\n\n  return res;\n}\n\nexport default OAuthController;\n","/**\n * OAuthClients Controller.\n *\n * Lists and revokes oauth client authorizations\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nimport * as express from 'express';\n\nconst PromiseRouter = require('express-promise-router');\nimport OAuthClients from '../models/oauthclients';\nimport {ClientRegistry} from '../oauth-types';\n\nconst OAuthClientsController = PromiseRouter();\n\n/**\n * Get the currently authorized clients\n */\nOAuthClientsController.get('/', async (request: express.Request, response: express.Response) => {\n  let user = (request as any).jwt.user;\n  let clients = await OAuthClients.getAuthorized(user);\n\n  response.json(clients.map((client: ClientRegistry) => {\n    return client.getDescription();\n  }));\n});\n\nOAuthClientsController.delete('/:clientId', async (request: express.Request, response: express.Response) => {\n  let clientId = request.params.clientId;\n  if (!OAuthClients.get(clientId, undefined)) {\n    response.status(404).send('Client not found');\n    return;\n  }\n  let user = (request as any).jwt.user;\n\n  await OAuthClients.revokeClientAuthorization(user, clientId);\n  response.sendStatus(204);\n});\n\nexport default OAuthClientsController;\n","/**\n * Ping Controller.\n *\n * Handles requests to /ping, used for connectivity checks.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst express = require('express');\n\nconst PingController = express.Router();\n\nPingController.get('/', (request, response) => {\n  response.sendStatus(204);\n});\n\nmodule.exports = PingController;\n","/**\n * Proxy Controller.\n *\n * Handles proxied resources.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst httpProxy = require('http-proxy');\nconst Router = require('express-promise-router');\n\nconst ProxyController = new Router();\n\nconst proxies = new Map();\nconst proxy = httpProxy.createProxyServer({\n  changeOrigin: true,\n});\n\nproxy.on('error', (e) => {\n  console.debug('Proxy error:', e);\n});\n\nProxyController.addProxyServer = (thingId, server) => {\n  proxies.set(thingId, server);\n};\n\nProxyController.removeProxyServer = (thingId) => {\n  proxies.delete(thingId);\n};\n\n/**\n * Proxy the request, if configured.\n */\nProxyController.all('/:thingId/*', (request, response) => {\n  const thingId = request.params.thingId;\n\n  if (!proxies.has(thingId)) {\n    response.sendStatus(404);\n    return;\n  }\n\n  request.url = request.url.substring(thingId.length + 1);\n  proxy.web(request, response, {target: proxies.get(thingId)});\n});\n\nmodule.exports = ProxyController;\n","/**\n * Push API Controller.\n *\n * Implements the Push API for notifications to use\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst PromiseRouter = require('express-promise-router');\nconst PushService = require('../push-service');\n\nconst PushController = PromiseRouter();\n\n/**\n * Handle requests for the public key\n */\nPushController.get('/vapid-public-key', async (request, response) => {\n  // const vapid = await PushService.getVAPIDKeys();\n  const vapid = false;\n  if (!vapid) {\n    // response.status(500).json({error: 'vapid not configured'});\n    return;\n  }\n  response.status(200).json({publicKey: vapid.publicKey});\n});\n\nPushController.post('/register', async (request, response) => {\n  const subscription = request.body.subscription;\n  try {\n    await PushService.createPushSubscription(subscription);\n  } catch (err) {\n    console.error(`PushController: Failed to register ${subscription}`, err);\n    response.status(500).json({error: 'register failed'});\n    return;\n  }\n  response.status(200).json({});\n});\n\nmodule.exports = PushController;\n","/**\n * Root Controller.\n *\n * Handles requests to /.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst express = require('express');\nconst Constants = require('../constants');\nconst TunnelService = require('../ssltunnel');\n\nconst RootController = express.Router();\n\n/**\n * Get the home page.\n */\nRootController.get('/', TunnelService.isTunnelSet, (request, response) => {\n  response.sendFile('index.html', {\n    root: Constants.BUILD_STATIC_PATH,\n  });\n});\n\nmodule.exports = RootController;\n","/**\n * Settings Controller.\n *\n * Manages gateway settings.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\n/* jshint unused:false */\n\nconst CertificateManager = require('../certificate-manager');\nconst config = require('config');\nconst Constants = require('../constants');\nconst fetch = require('node-fetch');\nconst fs = require('fs');\nconst isoLookup = require('../iso-639/index');\nconst jwtMiddleware = require('../jwt-middleware');\nconst mDNSserver = require('../mdns-server');\nconst path = require('path');\nconst pkg = require('../../package.json');\nconst Platform = require('../platform');\nconst PromiseRouter = require('express-promise-router');\nconst Settings = require('../models/settings');\nconst TunnelService = require('../ssltunnel');\n\nconst auth = jwtMiddleware.middleware();\nconst SettingsController = PromiseRouter();\n\n/**\n * Set an experiment setting.\n */\nSettingsController.put(\n  '/experiments/:experimentName',\n  auth,\n  async (request, response) => {\n    const experimentName = request.params.experimentName;\n\n    if (!request.body || !request.body.hasOwnProperty('enabled')) {\n      response.status(400).send('Enabled property not defined');\n      return;\n    }\n\n    const enabled = request.body.enabled;\n\n    try {\n      const result =\n        await Settings.set(`experiments.${experimentName}.enabled`,\n                           enabled);\n      response.status(200).json({enabled: result});\n    } catch (e) {\n      console.error(`Failed to set setting experiments.${experimentName}`);\n      console.error(e);\n      response.status(400).send(e);\n    }\n  });\n\n/**\n * Get an experiment setting.\n */\nSettingsController.get(\n  '/experiments/:experimentName',\n  auth,\n  async (request, response) => {\n    const experimentName = request.params.experimentName;\n\n    try {\n      const result =\n        await Settings.get(`experiments.${experimentName}.enabled`);\n      if (typeof result === 'undefined') {\n        response.status(404).send('Setting not found');\n      } else {\n        response.status(200).json({enabled: result});\n      }\n    } catch (e) {\n      console.error(`Failed to get setting experiments.${experimentName}`);\n      console.error(e);\n      response.status(400).send(e);\n    }\n  }\n);\n\nSettingsController.post('/reclaim', async (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('subdomain')) {\n    response.statusMessage = 'Subdomain missing from request';\n    response.status(400).end();\n    return;\n  }\n\n  const subdomain = request.body.subdomain;\n\n  try {\n    await fetch(`${config.get('ssltunnel.registration_endpoint')\n    }/reclaim?name=${subdomain}`);\n    response.status(200).json({});\n  } catch (e) {\n    console.error(e);\n    response.statusMessage = `Error reclaiming domain - ${e}`;\n    response.status(400).end();\n  }\n});\n\nSettingsController.post('/subscribe', async (request, response, next) => {\n  if (!request.body ||\n      !request.body.hasOwnProperty('email') ||\n      !request.body.hasOwnProperty('subdomain') ||\n      !request.body.hasOwnProperty('optout')) {\n    response.statusMessage = 'Invalid request';\n    response.status(400).end();\n    return;\n  }\n\n  // increase the timeout for this request, as registration can take a while\n  request.setTimeout(5 * 60 * 1000, () => {\n    const err = new Error('Request Timeout');\n    err.status = 408;\n    next(err);\n  });\n\n  const email = request.body.email.trim().toLowerCase();\n  const reclamationToken = request.body.reclamationToken.trim().toLowerCase();\n  const subdomain = request.body.subdomain.trim().toLowerCase();\n  const fulldomain = `${subdomain}.${config.get('ssltunnel.domain')}`;\n  const optout = request.body.optout ? 1 : 0;\n\n  function cb(err) {\n    if (err) {\n      response.statusMessage = `Error issuing certificate - ${err}`;\n      response.status(400).end();\n    } else {\n      const endpoint = {\n        url: `https://${subdomain}.${config.get('ssltunnel.domain')}`,\n      };\n      TunnelService.start(response, endpoint);\n      TunnelService.switchToHttps();\n    }\n  }\n\n  await CertificateManager.register(\n    email,\n    reclamationToken,\n    subdomain,\n    fulldomain,\n    optout,\n    cb\n  );\n});\n\nSettingsController.post('/skiptunnel', async (request, response) => {\n  try {\n    await Settings.set('notunnel', true);\n    response.status(200).json({});\n  } catch (e) {\n    console.error('Failed to set notunnel setting.');\n    console.error(e);\n    response.status(400).send(e);\n  }\n});\n\nSettingsController.get('/tunnelinfo', auth, async (request, response) => {\n  try {\n    const localDomainSettings = await Settings.getTunnelInfo();\n    response.status(200).json(localDomainSettings);\n  } catch (e) {\n    console.error('Failed to retrieve default settings for ' +\n      'tunneltoken or local service discovery setting');\n    console.error(e);\n    response.status(400).send(e);\n  }\n});\n\n/* This is responsible for controlling dynamically the local domain name\n * settings (via mDNS) and changing or updating mozilla tunnel endpoints.\n * The /domain endpoint is invoked from:\n *   MainMenu -> Settings -> Doamin\n *\n * JSON data: {\n *              local: {\n *                multicastDNSstate: boolean,\n *                localDNSname: string, - e.g. MyHome\n *              },\n *              mozillaTunnel: {\n *                tunnel: boolean,\n *                tunnelName: string, - e.g. MyName\n *                tunnelEmail: string\n *              }\n *            }\n */\nSettingsController.put('/domain', auth, async (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('local')) {\n    response.statusMessage = 'Invalid request.';\n    response.status(400).end();\n    return;\n  }\n\n  try {\n    if (request.body.local.hasOwnProperty('localDNSname')) {\n      if (!Platform.implemented('setHostname') ||\n          !Platform.setHostname(request.body.local.localDNSname)) {\n        response.sendStatus(500);\n        return;\n      }\n    } else if (request.body.local.hasOwnProperty('multicastDNSstate')) {\n      if (!Platform.implemented('setMdnsServerStatus') ||\n          !Platform.setMdnsServerStatus(request.body.local.multicastDNSstate)) {\n        response.sendStatus(500);\n        return;\n      }\n    } else {\n      response.statusMessage = 'Invalid request.';\n      response.status(400).end();\n      return;\n    }\n\n    let protocol, port;\n    if (request.secure) {\n      protocol = 'https';\n      port = config.get('ports.https');\n    } else {\n      protocol = 'http';\n      port = config.get('ports.http');\n    }\n\n    const domain = await mDNSserver.getmDNSdomain();\n    const state = await mDNSserver.getmDNSstate();\n    const url = `${protocol}://${domain}.local:${port}`;\n    const localDomainSettings = {\n      localDomain: url,\n      update: true,\n      mDNSstate: state,\n    };\n    response.status(200).json(localDomainSettings);\n  } catch (err) {\n    console.error(`Failed setting domain with: ${err} `);\n    const domain = await mDNSserver.getmDNSdomain();\n    const state = await mDNSserver.getmDNSstate();\n    const localDomainSettings = {\n      localDomain: domain,\n      update: false,\n      mDNSstate: state,\n      error: err.message,\n    };\n    response.status(400).json(localDomainSettings);\n  }\n});\n\nSettingsController.get('/addonsInfo', auth, (request, response) => {\n  response.json({\n    urls: config.get('addonManager.listUrls'),\n    architecture: Platform.getArchitecture(),\n    version: pkg.version,\n    nodeVersion: Platform.getNodeVersion(),\n    pythonVersions: Platform.getPythonVersions(),\n    testAddons: config.get('addonManager.testAddons'),\n  });\n});\n\nSettingsController.get('/system/platform', auth, (request, response) => {\n  response.json({\n    architecture: Platform.getArchitecture(),\n    os: Platform.getOS(),\n  });\n});\n\nSettingsController.get('/system/ssh', auth, (request, response) => {\n  const toggleImplemented = Platform.implemented('setSshServerStatus');\n  let enabled = false;\n  if (Platform.implemented('getSshServerStatus')) {\n    enabled = Platform.getSshServerStatus();\n  }\n\n  response.json({\n    toggleImplemented,\n    enabled,\n  });\n});\n\nSettingsController.put('/system/ssh', auth, (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('enabled')) {\n    response.status(400).send('Enabled property not defined');\n    return;\n  }\n\n  const toggleImplemented = Platform.implemented('setSshServerStatus');\n  if (toggleImplemented) {\n    const enabled = request.body.enabled;\n    if (Platform.setSshServerStatus(enabled)) {\n      response.status(200).json({enabled});\n    } else {\n      response.status(400).send('Failed to toggle SSH');\n    }\n  } else {\n    response.status(500).send('Toggle SSH not implemented');\n  }\n});\n\nSettingsController.post('/system/actions', auth, (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('action')) {\n    response.status(400).send('Action property not defined');\n    return;\n  }\n\n  const action = request.body.action;\n  switch (action) {\n    case 'restartGateway':\n      if (Platform.implemented('restartGateway')) {\n        if (Platform.restartGateway()) {\n          response.status(200).json({});\n        } else {\n          response.status(500).send('Failed to restart gateway');\n        }\n      } else {\n        response.status(500).send('Restart gateway not implemented');\n      }\n      break;\n    case 'restartSystem':\n      if (Platform.implemented('restartSystem')) {\n        if (Platform.restartSystem()) {\n          response.status(200).json({});\n        } else {\n          response.status(500).send('Failed to restart system');\n        }\n      } else {\n        response.status(500).send('Restart system not implemented');\n      }\n      break;\n    default:\n      response.status(400).send('Unsupported action');\n      break;\n  }\n});\n\nSettingsController.get('/system/ntp', (request, response) => {\n  const statusImplemented = Platform.implemented('getNtpStatus');\n\n  let synchronized = false;\n  if (statusImplemented) {\n    synchronized = Platform.getNtpStatus();\n  }\n\n  response.json({\n    statusImplemented,\n    synchronized,\n  });\n});\n\nSettingsController.post('/system/ntp', (request, response) => {\n  if (Platform.implemented('restartNtpSync')) {\n    if (Platform.restartNtpSync()) {\n      response.status(200).json({});\n    } else {\n      response.status(500).send('Failed to restart NTP sync');\n    }\n  } else {\n    response.status(500).send('Restart NTP sync not implemented');\n  }\n});\n\nSettingsController.get('/network/dhcp', auth, (request, response) => {\n  if (Platform.implemented('getDhcpServerStatus')) {\n    response.json({enabled: Platform.getDhcpServerStatus()});\n  } else {\n    response.status(500).send('DHCP status not implemented');\n  }\n});\n\nSettingsController.put('/network/dhcp', auth, (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('enabled')) {\n    response.status(400).send('Missing enabled property');\n    return;\n  }\n\n  const enabled = request.body.enabled;\n\n  if (Platform.implemented('setDhcpServerStatus')) {\n    if (Platform.setDhcpServerStatus(enabled)) {\n      response.status(200).json({});\n    } else {\n      response.status(500).send('Failed to toggle DHCP');\n    }\n  } else {\n    response.status(500).send('Toggle DHCP not implemented');\n  }\n});\n\nSettingsController.get('/network/lan', auth, (request, response) => {\n  if (Platform.implemented('getLanMode')) {\n    response.json(Platform.getLanMode());\n  } else {\n    response.status(500).send('LAN mode not implemented');\n  }\n});\n\nSettingsController.put('/network/lan', auth, (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('mode')) {\n    response.status(400).send('Missing mode property');\n    return;\n  }\n\n  const mode = request.body.mode;\n  const options = request.body.options;\n\n  if (Platform.implemented('setLanMode')) {\n    if (Platform.setLanMode(mode, options)) {\n      response.status(200).json({});\n    } else {\n      response.status(500).send('Failed to update LAN configuration');\n    }\n  } else {\n    response.status(500).send('Setting LAN mode not implemented');\n  }\n});\n\nSettingsController.get('/network/wan', auth, (request, response) => {\n  if (Platform.implemented('getWanMode')) {\n    response.json(Platform.getWanMode());\n  } else {\n    response.status(500).send('WAN mode not implemented');\n  }\n});\n\nSettingsController.put('/network/wan', auth, (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('mode')) {\n    response.status(400).send('Missing mode property');\n    return;\n  }\n\n  const mode = request.body.mode;\n  const options = request.body.options;\n\n  if (Platform.implemented('setWanMode')) {\n    if (Platform.setWanMode(mode, options)) {\n      response.status(200).json({});\n    } else {\n      response.status(500).send('Failed to update WAN configuration');\n    }\n  } else {\n    response.status(500).send('Setting WAN mode not implemented');\n  }\n});\n\nSettingsController.get('/network/wireless', auth, (request, response) => {\n  if (Platform.implemented('getWirelessMode')) {\n    response.json(Platform.getWirelessMode());\n  } else {\n    response.status(500).send('Wireless mode not implemented');\n  }\n});\n\nSettingsController.get(\n  '/network/wireless/networks',\n  auth,\n  (request, response) => {\n    if (Platform.implemented('scanWirelessNetworks')) {\n      response.json(Platform.scanWirelessNetworks());\n    } else {\n      response.status(500).send('Wireless scanning not implemented');\n    }\n  }\n);\n\nSettingsController.put('/network/wireless', auth, (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('enabled')) {\n    response.status(400).send('Missing enabled property');\n    return;\n  }\n\n  const enabled = request.body.enabled;\n  const mode = request.body.mode;\n  const options = request.body.options;\n\n  if (Platform.implemented('setWirelessMode')) {\n    if (Platform.setWirelessMode(enabled, mode, options)) {\n      response.status(200).json({});\n    } else {\n      response.status(500).send('Failed to update wireless configuration');\n    }\n  } else {\n    response.status(500).send('Setting wireless mode not implemented');\n  }\n});\n\nSettingsController.get('/network/addresses', auth, (request, response) => {\n  if (Platform.implemented('getNetworkAddresses')) {\n    response.json(Platform.getNetworkAddresses());\n  } else {\n    response.status(500).send('Network addresses not implemented');\n  }\n});\n\nSettingsController.get('/localization/country', auth, (request, response) => {\n  let valid = [];\n  if (Platform.implemented('getValidWirelessCountries')) {\n    valid = Platform.getValidWirelessCountries();\n  }\n\n  let current = '';\n  if (Platform.implemented('getWirelessCountry')) {\n    current = Platform.getWirelessCountry();\n  }\n\n  const setImplemented = Platform.implemented('setWirelessCountry');\n  response.json({valid, current, setImplemented});\n});\n\nSettingsController.put('/localization/country', auth, (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('country')) {\n    response.status(400).send('Missing country property');\n    return;\n  }\n\n  if (Platform.implemented('setWirelessCountry')) {\n    if (Platform.setWirelessCountry(request.body.country)) {\n      response.status(200).json({});\n    } else {\n      response.status(500).send('Failed to update country');\n    }\n  } else {\n    response.status(500).send('Setting country not implemented');\n  }\n});\n\nSettingsController.get('/localization/timezone', auth, (request, response) => {\n  let valid = [];\n  if (Platform.implemented('getValidTimezones')) {\n    valid = Platform.getValidTimezones();\n  }\n\n  let current = '';\n  if (Platform.implemented('getTimezone')) {\n    current = Platform.getTimezone();\n  }\n\n  const setImplemented = Platform.implemented('setTimezone');\n  response.json({valid, current, setImplemented});\n});\n\nSettingsController.put('/localization/timezone', auth, (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('zone')) {\n    response.status(400).send('Missing zone property');\n    return;\n  }\n\n  if (Platform.implemented('setTimezone')) {\n    if (Platform.setTimezone(request.body.zone)) {\n      response.status(200).json({});\n    } else {\n      response.status(500).send('Failed to update timezone');\n    }\n  } else {\n    response.status(500).send('Setting timezone not implemented');\n  }\n});\n\nSettingsController.get(\n  '/localization/language',\n  auth,\n  async (request, response) => {\n    const fluentDir = path.join(Constants.BUILD_STATIC_PATH, 'fluent');\n    const valid = [];\n    try {\n      for (const dirname of fs.readdirSync(fluentDir)) {\n        const name = isoLookup(dirname);\n\n        if (!name) {\n          console.error('Unknown language code:', dirname);\n          continue;\n        }\n\n        valid.push({\n          code: dirname,\n          name,\n        });\n      }\n\n      valid.sort((a, b) => a.name.localeCompare(b.name));\n    } catch (e) {\n      console.log(e);\n      response.status(500).send('Failed to retrieve list of languages');\n      return;\n    }\n\n    try {\n      const current = await Settings.get('localization.language');\n      response.json({valid, current});\n    } catch (_) {\n      response.status(500).send('Failed to get current language');\n    }\n  }\n);\n\nSettingsController.put(\n  '/localization/language',\n  auth,\n  async (request, response) => {\n    if (!request.body || !request.body.hasOwnProperty('language')) {\n      response.status(400).send('Missing language property');\n      return;\n    }\n\n    try {\n      await Settings.set('localization.language', request.body.language);\n      response.json({});\n    } catch (_) {\n      response.status(500).send('Failed to set language');\n    }\n  }\n);\n\nSettingsController.get(\n  '/localization/units',\n  auth,\n  async (request, response) => {\n    let temperature;\n\n    try {\n      temperature = await Settings.get('localization.units.temperature');\n    } catch (e) {\n      // pass\n    }\n\n    response.json({\n      temperature: temperature || 'degree celsius',\n    });\n  }\n);\n\nSettingsController.put(\n  '/localization/units',\n  auth,\n  async (request, response) => {\n    for (const [key, value] of Object.entries(request.body)) {\n      try {\n        await Settings.set(`localization.units.${key}`, value);\n      } catch (_) {\n        response.status(500).send('Failed to set unit');\n        return;\n      }\n    }\n\n    response.json({});\n  }\n);\n\nmodule.exports = SettingsController;\n","/**\n * Things Controller.\n *\n * Manages HTTP requests to /things.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Action = require('../models/action');\nconst Actions = require('../models/actions');\nconst ActionsController = require('./actions_controller');\nconst AddonManager = require('../addon-manager');\nconst Constants = require('../constants');\nconst EventsController = require('./events_controller');\nconst PromiseRouter = require('express-promise-router');\nconst Settings = require('../models/settings');\nconst Things = require('../models/things');\nconst WebSocket = require('ws');\n\nconst ThingsController = PromiseRouter();\n\n/**\n * Connect to receive messages from a Thing or all Things\n *\n * Note that these must precede the normal routes to allow express-ws to work\n */\nThingsController.ws('/:thingId/', websocketHandler);\nThingsController.ws('/', websocketHandler);\n\n/**\n * Get a list of Things.\n */\nThingsController.get('/', (request, response) => {\n  if (request.jwt.payload.role !== Constants.USER_TOKEN) {\n    if (!request.jwt.payload.scope) {\n      response.status(400).send('Token must contain scope');\n    } else {\n      const scope = request.jwt.payload.scope;\n      if (!scope.includes(' ') && scope.indexOf('/') == 0 &&\n        scope.split('/').length == 2 &&\n        scope.split(':')[0] === Constants.THINGS_PATH) {\n        Things.getThingDescriptions(request.get('Host'), request.secure)\n          .then((things) => {\n            response.status(200).json(things);\n          });\n      } else {\n        // Get hrefs of things in scope\n        const paths = scope.split(' ');\n        const hrefs = new Array(0);\n        for (const path of paths) {\n          const parts = path.split(':');\n          hrefs.push(parts[0]);\n        }\n        Things.getListThingDescriptions(hrefs,\n                                        request.get('Host'),\n                                        request.secure)\n          .then((things) => {\n            response.status(200).json(things);\n          });\n      }\n    }\n  } else {\n    Things.getThingDescriptions(request.get('Host'), request.secure)\n      .then((things) => {\n        response.status(200).json(things);\n      });\n  }\n});\n\nThingsController.patch('/', async (request, response) => {\n  if (!request.body ||\n      !request.body.hasOwnProperty('thingId') ||\n      !request.body.thingId) {\n    response.status(400).send('Invalid request');\n    return;\n  }\n\n  const thingId = request.body.thingId;\n\n  if (request.body.hasOwnProperty('pin') &&\n      request.body.pin.length > 0) {\n    const pin = request.body.pin;\n\n    try {\n      const device = await AddonManager.setPin(thingId, pin);\n      response.status(200).json(device);\n    } catch (e) {\n      console.error(`Failed to set PIN for ${thingId}: ${e}`);\n      response.status(400).send(e);\n    }\n  } else if (request.body.hasOwnProperty('username') &&\n             request.body.username.length > 0 &&\n             request.body.hasOwnProperty('password') &&\n             request.body.password.length > 0) {\n    const username = request.body.username;\n    const password = request.body.password;\n\n    try {\n      const device = await AddonManager.setCredentials(\n        thingId,\n        username,\n        password\n      );\n      response.status(200).json(device);\n    } catch (e) {\n      console.error(`Failed to set credentials for ${thingId}: ${e}`);\n      response.status(400).send(e);\n    }\n  } else {\n    response.status(400).send('Invalid request');\n  }\n});\n\n/**\n * Handle creating a new thing.\n */\nThingsController.post('/', async (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('id')) {\n    response.status(400).send('No id in thing description');\n    return;\n  }\n  const description = request.body;\n  const id = description.id;\n  delete description.id;\n\n  try {\n    // If the thing already exists, bail out.\n    await Things.getThing(id);\n    const err = 'Web thing already added';\n    console.log(err, id);\n    response.status(400).send(err);\n    return;\n  } catch (_e) {\n    // Do nothing, this is what we want.\n  }\n\n  // If we're adding a native webthing, we need to update the config for\n  // thing-url-adapter so that it knows about it.\n  let webthing = false;\n  if (description.hasOwnProperty('webthingUrl')) {\n    webthing = true;\n\n    const key = 'addons.config.thing-url-adapter';\n    try {\n      const config = await Settings.get(key);\n      if (typeof config === 'undefined') {\n        throw new Error('Setting is undefined.');\n      }\n\n      config.urls.push(description.webthingUrl);\n      await Settings.set(key, config);\n    } catch (e) {\n      console.error('Failed to update settings for thing-url-adapter');\n      console.error(e);\n      response.status(400).send(e);\n      return;\n    }\n\n    delete description.webthingUrl;\n  }\n\n  try {\n    const thing = await Things.createThing(id, description, webthing);\n    console.log(`Successfully created new thing ${thing.title}`);\n    response.status(201).send(thing);\n  } catch (error) {\n    console.error('Error saving new thing', id, description);\n    console.error(error);\n    response.status(500).send(error);\n  }\n\n  // If this is a web thing, we need to restart thing-url-adapter.\n  if (webthing) {\n    try {\n      await AddonManager.unloadAddon('thing-url-adapter', true);\n      await AddonManager.loadAddon('thing-url-adapter');\n    } catch (e) {\n      console.error('Failed to restart thing-url-adapter');\n      console.error(e);\n    }\n  }\n});\n\n/**\n * Get a Thing.\n */\nThingsController.get('/:thingId', (request, response) => {\n  const id = request.params.thingId;\n  Things.getThingDescription(id, request.get('Host'), request.secure)\n    .then((thing) => {\n      response.status(200).json(thing);\n    })\n    .catch((error) => {\n      console.error(\n        `Error getting thing description for thing with id ${id}:`,\n        error\n      );\n      response.status(404).send(error);\n    });\n});\n\n/**\n * Get the properties of a Thing.\n */\nThingsController.get('/:thingId/properties', async (request, response) => {\n  const thingId = request.params.thingId;\n\n  let thing;\n  try {\n    thing = await Things.getThing(thingId);\n  } catch (e) {\n    console.error('Failed to get thing:', e);\n    response.status(404).send(e);\n    return;\n  }\n\n  const result = {};\n  for (const name in thing.properties) {\n    try {\n      const value = await AddonManager.getProperty(thingId, name);\n      result[name] = value;\n    } catch (e) {\n      console.error(`Failed to get property ${name}:`, e);\n    }\n  }\n\n  response.status(200).json(result);\n});\n\n/**\n * Get a property of a Thing.\n */\nThingsController.get(\n  '/:thingId/properties/:propertyName',\n  async (request, response) => {\n    const thingId = request.params.thingId;\n    const propertyName = request.params.propertyName;\n    try {\n      const value = await Things.getThingProperty(thingId, propertyName);\n      const result = {};\n      result[propertyName] = value;\n      response.status(200).json(result);\n    } catch (err) {\n      response.status(err.code).send(err.message);\n    }\n  });\n\n/**\n * Set a property of a Thing.\n */\nThingsController.put(\n  '/:thingId/properties/:propertyName',\n  async (request, response) => {\n    const thingId = request.params.thingId;\n    const propertyName = request.params.propertyName;\n    if (!request.body || typeof request.body[propertyName] === 'undefined') {\n      response.status(400).send('Invalid property name');\n      return;\n    }\n    const value = request.body[propertyName];\n    try {\n      const updatedValue = await Things.setThingProperty(thingId, propertyName,\n                                                         value);\n      const result = {\n        [propertyName]: updatedValue,\n      };\n      response.status(200).json(result);\n    } catch (e) {\n      response.status(e.code).send(e.message);\n    }\n  });\n\n/**\n * Use an ActionsController to handle each thing's actions.\n */\nThingsController.use(`/:thingId${Constants.ACTIONS_PATH}`, ActionsController);\n\n/**\n * Use an EventsController to handle each thing's events.\n */\nThingsController.use(`/:thingId${Constants.EVENTS_PATH}`, EventsController);\n\n/**\n * Modify a Thing's floorplan position or layout index.\n */\nThingsController.patch('/:thingId', async (request, response) => {\n  const thingId = request.params.thingId;\n  if (!request.body) {\n    response.status(400).send('request body missing');\n    return;\n  }\n\n  let thing;\n  try {\n    thing = await Things.getThing(thingId);\n  } catch (e) {\n    response.status(404).send('thing not found');\n    return;\n  }\n\n  let description;\n  try {\n    if (request.body.hasOwnProperty('floorplanX') &&\n        request.body.hasOwnProperty('floorplanY')) {\n      description = await thing.setCoordinates(\n        request.body.floorplanX,\n        request.body.floorplanY\n      );\n    } else if (request.body.hasOwnProperty('layoutIndex')) {\n      description = await thing.setLayoutIndex(request.body.layoutIndex);\n    } else {\n      response.status(400).send('request body missing required parameters');\n      return;\n    }\n\n    response.status(200).json(description);\n  } catch (e) {\n    response.status(500).send(`Failed to update thing ${thingId}: ${e}`);\n  }\n});\n\n/**\n * Modify a Thing.\n */\nThingsController.put('/:thingId', async (request, response) => {\n  const thingId = request.params.thingId;\n  if (!request.body || !request.body.hasOwnProperty('title')) {\n    response.status(400).send('title parameter required');\n    return;\n  }\n\n  const title = request.body.title.trim();\n  if (title.length === 0) {\n    response.status(400).send('Invalid title');\n    return;\n  }\n\n  let thing;\n  try {\n    thing = await Things.getThing(thingId);\n  } catch (e) {\n    response.status(500).send(`Failed to retrieve thing ${thingId}: ${e}`);\n    return;\n  }\n\n  if (request.body.selectedCapability) {\n    try {\n      await thing.setSelectedCapability(request.body.selectedCapability);\n    } catch (e) {\n      response.status(500).send(`Failed to update thing ${thingId}: ${e}`);\n      return;\n    }\n  }\n\n  if (request.body.iconData) {\n    try {\n      await thing.setIcon(request.body.iconData, true);\n    } catch (e) {\n      response.status(500).send(`Failed to update thing ${thingId}: ${e}`);\n      return;\n    }\n  }\n\n  let description;\n  try {\n    description = await thing.setTitle(title);\n  } catch (e) {\n    response.status(500).send(`Failed to update thing ${thingId}: ${e}`);\n    return;\n  }\n\n  response.status(200).json(description);\n});\n\n/**\n * Remove a Thing.\n */\nThingsController.delete('/:thingId', (request, response) => {\n  const thingId = request.params.thingId;\n\n  const _finally = () => {\n    Things.removeThing(thingId).then(() => {\n      console.log(`Successfully deleted ${thingId} from database.`);\n      response.sendStatus(204);\n    }).catch((e) => {\n      response.status(500).send(`Failed to remove thing ${thingId}: ${e}`);\n    });\n  };\n\n  AddonManager.removeThing(thingId).then(_finally, _finally);\n});\n\nfunction websocketHandler(websocket, request) {\n  // Since the Gateway have the asynchronous express middlewares, there is a\n  // possibility that the WebSocket have been closed.\n  if (websocket.readyState !== WebSocket.OPEN) {\n    return;\n  }\n\n  const thingId = request.params.thingId;\n  const subscribedEventNames = {};\n\n  async function sendMessage(message) {\n    websocket.send(JSON.stringify(message), (err) => {\n      if (err) {\n        console.error(`WebSocket sendMessage failed: ${err}`);\n      }\n    });\n  }\n\n  function onPropertyChanged(property) {\n    if (typeof thingId !== 'undefined' && property.device.id !== thingId) {\n      return;\n    }\n\n    sendMessage({\n      id: property.device.id,\n      messageType: Constants.PROPERTY_STATUS,\n      data: {\n        [property.name]: property.value,\n      },\n    });\n  }\n\n  function onActionStatus(action) {\n    if (action.hasOwnProperty('thingId') &&\n        typeof thingId !== 'undefined' &&\n        action.thingId !== thingId) {\n      return;\n    }\n\n    const message = {\n      messageType: Constants.ACTION_STATUS,\n      data: {\n        [action.name]: action.getDescription(),\n      },\n    };\n\n    if (action.hasOwnProperty('thingId')) {\n      message.id = action.thingId;\n    }\n\n    sendMessage(message);\n  }\n\n  function onEvent(event) {\n    if (typeof thingId !== 'undefined' && event.thingId !== thingId) {\n      return;\n    }\n\n    if (!subscribedEventNames[event.name]) {\n      return;\n    }\n\n    sendMessage({\n      id: event.thingId,\n      messageType: Constants.EVENT,\n      data: {\n        [event.name]: event.getDescription(),\n      },\n    });\n  }\n\n  let thingCleanups = {};\n  function addThing(thing) {\n    thing.addEventSubscription(onEvent);\n\n    function onConnected(connected) {\n      sendMessage({\n        id: thing.id,\n        messageType: Constants.CONNECTED,\n        data: connected,\n      });\n    }\n    thing.addConnectedSubscription(onConnected);\n\n    const onRemoved = () => {\n      if (thingCleanups[thing.id]) {\n        thingCleanups[thing.id]();\n        delete thingCleanups[thing.id];\n      }\n\n      if (typeof thingId !== 'undefined' &&\n          (websocket.readyState === WebSocket.OPEN ||\n           websocket.readyState === WebSocket.CONNECTING)) {\n        websocket.close();\n      } else {\n        sendMessage({\n          id: thing.id,\n          messageType: Constants.THING_REMOVED,\n          data: {},\n        });\n      }\n    };\n    thing.addRemovedSubscription(onRemoved);\n\n    const onModified = () => {\n      sendMessage({\n        id: thing.id,\n        messageType: Constants.THING_MODIFIED,\n        data: {},\n      });\n    };\n    thing.addModifiedSubscription(onModified);\n\n    const thingCleanup = () => {\n      thing.removeEventSubscription(onEvent);\n      thing.removeConnectedSubscription(onConnected);\n      thing.removeRemovedSubscription(onRemoved);\n      thing.removeModifiedSubscription(onModified);\n    };\n    thingCleanups[thing.id] = thingCleanup;\n\n    // send initial property values\n    for (const name in thing.properties) {\n      AddonManager.getProperty(thing.id, name).then((value) => {\n        sendMessage({\n          id: thing.id,\n          messageType: Constants.PROPERTY_STATUS,\n          data: {\n            [name]: value,\n          },\n        });\n      }).catch((e) => {\n        console.error(`Failed to get property ${name}:`, e);\n      });\n    }\n  }\n\n  function onThingAdded(thing) {\n    sendMessage({\n      id: thing.id,\n      messageType: Constants.THING_ADDED,\n      data: {},\n    });\n\n    addThing(thing);\n  }\n\n  if (typeof thingId !== 'undefined') {\n    Things.getThing(thingId).then((thing) => {\n      addThing(thing);\n    }).catch(() => {\n      console.error('WebSocket opened on nonexistent thing', thingId);\n      sendMessage({\n        messageType: Constants.ERROR,\n        data: {\n          code: 404,\n          status: '404 Not Found',\n          message: `Thing ${thingId} not found`,\n        },\n      });\n      websocket.close();\n    });\n  } else {\n    Things.getThings().then((things) => {\n      things.forEach(addThing);\n    });\n    Things.on(Constants.THING_ADDED, onThingAdded);\n  }\n\n  AddonManager.on(Constants.PROPERTY_CHANGED, onPropertyChanged);\n  Actions.on(Constants.ACTION_STATUS, onActionStatus);\n\n  const heartbeatInterval = setInterval(() => {\n    try {\n      websocket.ping();\n    } catch (e) {\n      // Do nothing. Let cleanup() handle things if necessary.\n      websocket.terminate();\n    }\n  }, 30 * 1000);\n\n  const cleanup = () => {\n    Things.removeListener(Constants.THING_ADDED, onThingAdded);\n    AddonManager.removeListener(Constants.PROPERTY_CHANGED, onPropertyChanged);\n    Actions.removeListener(Constants.ACTION_STATUS, onActionStatus);\n    for (const id in thingCleanups) {\n      thingCleanups[id]();\n    }\n    thingCleanups = {};\n    clearInterval(heartbeatInterval);\n  };\n\n  websocket.on('error', cleanup);\n  websocket.on('close', cleanup);\n\n  websocket.on('message', (requestText) => {\n    let request = null;\n    try {\n      request = JSON.parse(requestText);\n    } catch (e) {\n      sendMessage({\n        messageType: Constants.ERROR,\n        data: {\n          code: 400,\n          status: '400 Bad Request',\n          message: 'Parsing request failed',\n        },\n      });\n      return;\n    }\n\n    const id = request.id || thingId;\n    if (typeof id === 'undefined') {\n      sendMessage({\n        messageType: Constants.ERROR,\n        data: {\n          code: 400,\n          status: '400 Bad Request',\n          message: 'Missing thing id',\n          request,\n        },\n      });\n      return;\n    }\n\n    const device = AddonManager.getDevice(id);\n    if (!device) {\n      sendMessage({\n        messageType: Constants.ERROR,\n        data: {\n          code: 400,\n          status: '400 Bad Request',\n          message: `Thing ${id} not found`,\n          request,\n        },\n      });\n      return;\n    }\n\n    switch (request.messageType) {\n      case Constants.SET_PROPERTY: {\n        const setRequests = Object.keys(request.data).map((property) => {\n          const value = request.data[property];\n          return device.setProperty(property, value);\n        });\n        Promise.all(setRequests).catch((err) => {\n          // If any set fails, send an error\n          sendMessage({\n            messageType: Constants.ERROR,\n            data: {\n              code: 400,\n              status: '400 Bad Request',\n              message: err,\n              request,\n            },\n          });\n        });\n        break;\n      }\n\n      case Constants.ADD_EVENT_SUBSCRIPTION: {\n        for (const eventName in request.data) {\n          subscribedEventNames[eventName] = true;\n        }\n        break;\n      }\n\n      case Constants.REQUEST_ACTION: {\n        for (const actionName in request.data) {\n          const actionParams = request.data[actionName].input;\n          Things.getThing(id).then((thing) => {\n            const action = new Action(actionName, actionParams, thing);\n            return Actions.add(action).then(() => {\n              return AddonManager.requestAction(\n                id, action.id, actionName, actionParams);\n            });\n          }).catch((err) => {\n            sendMessage({\n              messageType: Constants.ERROR,\n              data: {\n                code: 400,\n                status: '400 Bad Request',\n                message: err.message,\n                request,\n              },\n            });\n          });\n        }\n        break;\n      }\n\n      default: {\n        sendMessage({\n          messageType: Constants.ERROR,\n          data: {\n            code: 400,\n            status: '400 Bad Request',\n            message: `Unknown messageType: ${request.messageType}`,\n            request,\n          },\n        });\n        break;\n      }\n    }\n  });\n}\n\nmodule.exports = ThingsController;\n","'use strict';\n\nconst childProcess = require('child_process');\nconst config = require('config');\nconst fs = require('fs');\nconst fetch = require('node-fetch');\nconst semver = require('semver');\nconst Platform = require('../platform');\nconst PromiseRouter = require('express-promise-router');\nconst Utils = require('../utils');\n\nconst pkg = require('../../package.json');\n\nconst UpdatesController = PromiseRouter();\n\nfunction readVersion(packagePath) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(packagePath, {encoding: 'utf8'}, (err, data) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      try {\n        const pkgJson = JSON.parse(data);\n\n        if (!semver.valid(pkgJson.version)) {\n          reject(new Error(`Invalid gateway semver: ${pkgJson.version}`));\n          return;\n        }\n\n        resolve(pkgJson.version);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  });\n}\n\nfunction stat(path) {\n  return new Promise((resolve, reject) => {\n    fs.stat(path, (err, stats) => {\n      if (err) {\n        if (err.code === 'ENOENT') {\n          resolve(null);\n        } else {\n          reject(err);\n        }\n      } else {\n        resolve(stats);\n      }\n    });\n  });\n}\n\nconst cacheLatest = {\n  tag: null,\n  time: 0,\n  value: {version: null},\n};\nconst cacheDuration = 60 * 1000;\n\nfunction cacheLatestInsert(response, value) {\n  cacheLatest.tag = response.get('etag');\n  cacheLatest.time = Date.now();\n  cacheLatest.value = value;\n}\n\n/**\n * Send the client an object describing the latest release\n */\nUpdatesController.get('/latest', async (request, response) => {\n  const etag = request.get('If-None-Match');\n  if (etag) {\n    if (cacheLatest.tag === etag &&\n        Date.now() - cacheLatest.time < cacheDuration) {\n      response.sendStatus(304);\n      return;\n    }\n  }\n\n  const res = await fetch(\n    config.get('updateUrl'),\n    {headers: {'User-Agent': Utils.getGatewayUserAgent()}}\n  );\n\n  const releases = await res.json();\n  if (!releases || !releases.filter) {\n    console.warn('API returned invalid releases, rate limit likely exceeded');\n    const value = {version: null};\n    response.send(value);\n    cacheLatestInsert(response, value);\n    return;\n  }\n  const latestRelease = releases.filter((release) => {\n    return !release.prerelease && !release.draft;\n  })[0];\n  if (!latestRelease) {\n    console.warn('No releases found');\n    const value = {version: null};\n    response.send(value);\n    cacheLatestInsert(response, value);\n    return;\n  }\n  const releaseVer = latestRelease.tag_name;\n  const value = {version: releaseVer};\n  response.send(value);\n  cacheLatestInsert(response, value);\n});\n\n/**\n * Send an object describing the update status of the gateway\n */\nUpdatesController.get('/status', async (request, response) => {\n  // gateway, gateway_failed, gateway_old\n  // oldVersion -> gateway_old's package.json version\n  // if (gateway_failed.version > thisversion) {\n  //  update failed, last attempt was ctime of gateway_failed\n  // }\n  const currentVersion = pkg.version;\n\n  const oldStats = await stat('../gateway_old/package.json');\n  let oldVersion = null;\n  if (oldStats) {\n    try {\n      oldVersion = await readVersion('../gateway_old/package.json');\n    } catch (e) {\n      console.error('Failed to read ../gateway_old/package.json:', e);\n    }\n  }\n\n  const failedStats = await stat('../gateway_failed/package.json');\n  let failedVersion = null;\n  if (failedStats) {\n    try {\n      failedVersion = await readVersion('../gateway_failed/package.json');\n    } catch (e) {\n      console.error('Failed to read ../gateway_failed/package.json:', e);\n    }\n  }\n\n  if (failedVersion && semver.gt(failedVersion, currentVersion)) {\n    response.send({\n      success: false,\n      version: currentVersion,\n      failedVersion,\n      timestamp: failedStats.ctime,\n    });\n  } else {\n    let timestamp = null;\n    if (oldStats) {\n      timestamp = oldStats.ctime;\n    }\n    response.send({\n      success: true,\n      version: currentVersion,\n      oldVersion,\n      timestamp,\n    });\n  }\n});\n\nUpdatesController.post('/update', async (request, response) => {\n  childProcess.exec('sudo systemctl start ' +\n    'mozilla-iot-gateway.check-for-update.service');\n\n  response.json({});\n});\n\nUpdatesController.get('/self-update', async (request, response) => {\n  if (!Platform.implemented('getSelfUpdateStatus')) {\n    response.json({\n      available: false,\n      enabled: false,\n    });\n  } else {\n    response.json(Platform.getSelfUpdateStatus());\n  }\n});\n\nUpdatesController.put('/self-update', async (request, response) => {\n  if (!request.body || !request.body.hasOwnProperty('enabled')) {\n    response.status(400).send('Enabled property not defined');\n    return;\n  }\n\n  if (!Platform.implemented('setSelfUpdateStatus')) {\n    response.status(500).send('Cannot toggle auto updates');\n    return;\n  }\n\n  if (Platform.setSelfUpdateStatus(request.body.enabled)) {\n    response.status(200).json({enabled: request.body.enabled});\n  } else {\n    response.status(500).send('Failed to toggle auto updates');\n  }\n});\n\nmodule.exports = UpdatesController;\n","/**\n * Uploads Controller.\n *\n * Manages file uploads.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst Constants = require('../constants');\nconst UserProfile = require('../user-profile');\n\nconst UPLOADS_PATH = UserProfile.uploadsDir;\nconst FLOORPLAN_PATH = path.join(UPLOADS_PATH, 'floorplan.svg');\nconst FALLBACK_FLOORPLAN_PATH = path.join(Constants.STATIC_PATH,\n                                          'images',\n                                          'floorplan.svg');\n\n// On startup, copy the default floorplan, if necessary.\nif (!fs.existsSync(FLOORPLAN_PATH)) {\n  try {\n    fs.copyFileSync(FALLBACK_FLOORPLAN_PATH, FLOORPLAN_PATH);\n  } catch (err) {\n    console.error(`Failed to copy floorplan: ${err}`);\n  }\n}\n\nconst UploadsController = express.Router();\n\n/**\n * Upload a file.\n */\nUploadsController.post('/', (request, response) => {\n  if (!request.files || !request.files.file) {\n    return response.status(500).send('No file provided for upload');\n  }\n\n  try {\n    if (fs.existsSync(FLOORPLAN_PATH)) {\n      fs.unlinkSync(FLOORPLAN_PATH);\n    }\n  } catch (err) {\n    return response.status(500).send(`Failed to unlink old floorplan: ${err}`);\n  }\n\n  const file = request.files.file;\n  file.mv(FLOORPLAN_PATH, (error) => {\n    if (error) {\n      // On error, try to copy the fallback.\n      try {\n        fs.copyFileSync(FALLBACK_FLOORPLAN_PATH, FLOORPLAN_PATH);\n      } catch (err) {\n        console.error(`Failed to copy floorplan: ${err}`);\n      }\n\n      return response.status(500).send(\n        `Failed to save uploaded file: ${error}`);\n    }\n\n    response.status(201).send('Successfully uploaded file');\n  });\n});\n\nmodule.exports = UploadsController;\n","/**\n * Users Controller.\n *\n * Manages HTTP requests to /users.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst PromiseRouter = require('express-promise-router');\nconst Passwords = require('../passwords');\nconst Users = require('../models/users');\nconst JSONWebToken = require('../models/jsonwebtoken');\nconst jwtMiddleware = require('../jwt-middleware');\nconst auth = jwtMiddleware.middleware();\n\nconst UsersController = PromiseRouter();\n\n/**\n * Get the count of users.\n *\n * NOTE: This is temporary while we figure out mutli user UI.\n */\nUsersController.get('/count', async (request, response) => {\n  const count = await Users.getCount();\n  return response.status(200).send({count});\n});\n\n/**\n * Get info about all users.\n */\nUsersController.get('/info', auth, async (request, response) => {\n  const users = await Users.getUsers();\n  const descriptions = users.map((user) => {\n    const loggedIn = user.id === request.jwt.user;\n    return Object.assign(user.getDescription(), {loggedIn});\n  });\n  return response.status(200).send(descriptions);\n});\n\n/**\n * Get a user.\n */\nUsersController.get('/:userId', auth, async (request, response) => {\n  const user = await Users.getUserById(request.params.userId);\n\n  if (!user) {\n    response.sendStatus(404);\n    return;\n  }\n\n  response.status(200).json(user.getDescription());\n});\n\n/**\n * Create a user\n */\nUsersController.post('/', async (request, response) => {\n  const body = request.body;\n\n  if (!body || !body.email || !body.password) {\n    response.status(400).send('User requires email and password.');\n    return;\n  }\n\n  // If a user has already been created, this path must be authenticated.\n  const count = await Users.getCount();\n  if (count > 0) {\n    const jwt = await jwtMiddleware.authenticate(request);\n    if (!jwt) {\n      response.sendStatus(401);\n      return;\n    }\n  }\n\n  // See if this user already exists.\n  const found = await Users.getUser(body.email);\n  if (found) {\n    response.status(400).send('User already exists.');\n    return;\n  }\n\n  // TODO: user facing errors...\n  const hash = await Passwords.hash(body.password);\n  const user = await Users.createUser(body.email, hash, body.name);\n  const jwt = await JSONWebToken.issueToken(user.id);\n\n  response.send({\n    jwt,\n  });\n});\n\nUsersController.post('/:userId/mfa', auth, async (request, response) => {\n  const user = await Users.getUserById(request.params.userId);\n\n  if (!user) {\n    response.sendStatus(404);\n    return;\n  }\n\n  const body = request.body;\n  if (body.enable) {\n    if (!body.mfa) {\n      // Initial MFA enablement, generate params\n      const params = await user.generateMfaParams();\n      response.status(200).json(params);\n    } else if (Passwords.verifyMfaToken(user.mfaSharedSecret, body.mfa)) {\n      // Stage 2, verify MFA token\n      user.mfaEnrolled = true;\n      const backupCodes = await user.generateMfaBackupCodes();\n      await Users.editUser(user);\n      response.status(200).json({backupCodes});\n    } else {\n      response.sendStatus(401);\n    }\n  } else {\n    // Disable MFA\n    user.mfaEnrolled = false;\n    await Users.editUser(user);\n    response.sendStatus(204);\n  }\n});\n\nUsersController.put('/:userId/mfa/codes', auth, async (request, response) => {\n  const user = await Users.getUserById(request.params.userId);\n\n  if (!user) {\n    response.sendStatus(404);\n    return;\n  }\n\n  const body = request.body;\n  if (body.generate) {\n    const backupCodes = await user.generateMfaBackupCodes();\n    await Users.editUser(user);\n    response.status(200).json({backupCodes});\n    return;\n  }\n\n  response.status(400).send('Request missing generate parameter');\n});\n\n/**\n * Edit a user\n */\nUsersController.put('/:userId', auth, async (request, response) => {\n  const user = await Users.getUserById(request.params.userId);\n\n  if (!user) {\n    response.sendStatus(404);\n    return;\n  }\n\n  const body = request.body;\n  if (!body || !body.email || !body.password) {\n    response.status(400).send('User requires email and password.');\n    return;\n  }\n\n  const passwordMatch = await Passwords.compare(body.password, user.password);\n  if (!passwordMatch) {\n    response.status(400).send('Passwords do not match.');\n    return;\n  }\n\n  if (body.newPassword) {\n    user.password = await Passwords.hash(body.newPassword);\n  }\n\n  user.email = body.email;\n  user.name = body.name;\n\n  await Users.editUser(user);\n  response.status(200).json({});\n});\n\n/**\n * Delete a user\n */\nUsersController.delete('/:userId', auth, async (request, response) => {\n  const userId = request.params.userId;\n\n  await Users.deleteUser(userId);\n  response.sendStatus(204);\n});\n\nmodule.exports = UsersController;\n","/**\n * WebThings Gateway Database.\n *\n * Stores a list of Things connected to the gateway.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst config = require('config');\nconst sqlite3 = require('sqlite3').verbose();\nconst fs = require('fs');\nconst path = require('path');\nconst assert = require('assert');\nconst UserProfile = require('./user-profile');\n\nconst TABLES = [\n  'users',\n  'jsonwebtokens',\n  'things',\n  'settings',\n  'pushSubscriptions',\n];\n\nconst DEBUG = false || (process.env.NODE_ENV === 'test');\n\nconst Database = {\n  /**\n   * SQLite3 Database object.\n   */\n  db: null,\n\n  /**\n   * Open the database.\n   */\n  open: function() {\n    // If the database is already open, just return.\n    if (this.db) {\n      return;\n    }\n\n    // Don't pull this from user-profile.js, because that would cause a\n    // circular dependency.\n    const filename = path.join(UserProfile.configDir, 'db.sqlite3');\n\n    // Check if database already exists\n    let exists = fs.existsSync(filename);\n    const removeBeforeOpen = config.get('database.removeBeforeOpen');\n    if (exists && removeBeforeOpen) {\n      fs.unlinkSync(filename);\n      exists = false;\n    }\n\n    console.log(exists ? 'Opening' : 'Creating', 'database:', filename);\n    // Open database or create it if it doesn't exist\n    this.db = new sqlite3.Database(filename);\n\n    // Set a timeout in case the database is locked. 10 seconds is a bit long,\n    // but it's better than crashing.\n    this.db.configure('busyTimeout', 10000);\n\n    this.db.serialize(() => {\n      this.createTables();\n      this.migrate();\n      // If database newly created, populate with default data\n      if (!exists) {\n        this.populate();\n      }\n    });\n  },\n\n  createTables: function() {\n    // Create Things table\n    this.db.run('CREATE TABLE IF NOT EXISTS things (' +\n      'id TEXT PRIMARY KEY,' +\n      'description TEXT' +\n    ');');\n\n    // Create Users table\n    this.db.run('CREATE TABLE IF NOT EXISTS users (' +\n      'id INTEGER PRIMARY KEY ASC,' +\n      'email TEXT UNIQUE,' +\n      'password TEXT,' +\n      'name TEXT,' +\n      'mfaSharedSecret TEXT,' +\n      'mfaEnrolled BOOLEAN DEFAULT 0,' +\n      'mfaBackupCodes TEXT' +\n    ');');\n\n    /**\n     * This really should have a foreign key constraint but it does not work\n     * with our version of node-sqlite / sqlite.\n     *\n     * https://github.com/mapbox/node-sqlite3/pull/660\n     *\n     * Instead, the INTEGER user is either the id of the user or -1 if NULL\n     */\n    this.db.run('CREATE TABLE IF NOT EXISTS jsonwebtokens (' +\n      'id INTEGER PRIMARY KEY ASC,' +\n      'keyId TEXT UNIQUE,' + // public id (kid in JWT terms).\n      'user INTEGER,' +\n      'issuedAt DATE,' +\n      'publicKey TEXT,' +\n      'payload TEXT' +\n    ');');\n\n    // Create Settings table\n    this.db.run('CREATE TABLE IF NOT EXISTS settings (' +\n      'key TEXT PRIMARY KEY,' +\n      'value TEXT' +\n    ');');\n\n    this.db.run(`CREATE TABLE IF NOT EXISTS pushSubscriptions (\n      id INTEGER PRIMARY KEY,\n      subscription TEXT UNIQUE\n    );`);\n  },\n\n  /**\n   * Do anything necessary to migrate from old database schemas.\n   */\n  migrate: function() {\n    this.db.run('DROP TABLE IF EXISTS jsonwebtoken_to_user');\n    this.db.run('ALTER TABLE users ADD COLUMN mfaSharedSecret TEXT', () => {});\n    this.db.run(\n      'ALTER TABLE users ADD COLUMN mfaEnrolled BOOLEAN DEFAULT 0',\n      () => {}\n    );\n    this.db.run('ALTER TABLE users ADD COLUMN mfaBackupCodes TEXT', () => {});\n  },\n\n  /**\n   * Populate the database with default data.\n   */\n  populate: function() {\n    // Add any settings provided.\n    const generateSettings = (obj, baseKey) => {\n      const settings = [];\n\n      for (const key in obj) {\n        let newKey;\n        if (baseKey !== '') {\n          newKey = `${baseKey}.${key}`;\n        } else {\n          newKey = key;\n        }\n\n        if (typeof obj[key] === 'object') {\n          settings.push(...generateSettings(obj[key], newKey));\n        } else {\n          settings.push([newKey, obj[key]]);\n        }\n      }\n      return settings;\n    };\n\n    const settings = generateSettings(config.get('settings.defaults'), '');\n    for (const setting of settings) {\n      this.db.run(\n        'INSERT INTO settings (key, value) VALUES (?, ?)',\n        [setting[0], setting[1]],\n        (error) => {\n          if (error) {\n            console.error(`Failed to insert setting ${\n              setting[0]}`);\n          } else if (DEBUG) {\n            console.log(`Saved setting ${setting[0]} = ${\n              setting[1]}`);\n          }\n        }\n      );\n    }\n  },\n\n  /**\n   * Get all Things stored in the database.\n   *\n   * @return Promise which resolves with a list of Thing objects.\n   */\n  getThings: function() {\n    return new Promise((function(resolve, reject) {\n      this.db.all(\n        'SELECT id, description FROM things',\n        ((err, rows) => {\n          if (err) {\n            reject(err);\n          } else {\n            const things = [];\n            for (const row of rows) {\n              const thing = JSON.parse(row.description);\n              thing.id = row.id;\n              things.push(thing);\n            }\n            resolve(things);\n          }\n        }));\n    }).bind(this));\n  },\n\n  /**\n   * Add a new Thing to the Database.\n   *\n   * @param String id The ID to give the new Thing.\n   * @param String description A serialised Thing description.\n   */\n  createThing: function(id, description) {\n    return new Promise((function(resolve, reject) {\n      const db = this.db;\n      db.run(\n        'INSERT INTO things (id, description) VALUES (?, ?)',\n        [id, JSON.stringify(description)],\n        (error) => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(description);\n          }\n        });\n    }).bind(this));\n  },\n\n  /**\n   * Update a Thing in the Database.\n   *\n   * @param String id ID of the thing to update.\n   * @param String description A serialised Thing description.\n   */\n  updateThing: function(id, description) {\n    return new Promise((function(resolve, reject) {\n      const db = this.db;\n      db.run(\n        'UPDATE things SET description=? WHERE id=?',\n        [JSON.stringify(description), id],\n        (error) => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(description);\n          }\n        });\n    }).bind(this));\n  },\n\n  /**\n   * Remove a Thing from the Database.\n   *\n   * @param String id The ID of the Thing to remove.\n   */\n  removeThing: function(id) {\n    return new Promise((function(resolve, reject) {\n      const db = this.db;\n      db.run('DELETE FROM things WHERE id = ?', id, (error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    }).bind(this));\n  },\n\n  /**\n   * Get a user by their email address.\n   */\n  getUser: function(email) {\n    return new Promise((function(resolve, reject) {\n      const db = this.db;\n      db.get(\n        'SELECT * FROM users WHERE email = ?',\n        email,\n        (error, row) => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(row);\n          }\n        });\n    }).bind(this));\n  },\n\n  /**\n   * Get a user by it's primary key (id).\n   */\n  getUserById: async function(id) {\n    assert(typeof id === 'number');\n    return await this.get(\n      'SELECT * FROM users WHERE id = ?',\n      id\n    );\n  },\n\n  /**\n   * Get all Users stored in the database.\n   *\n   * @return {Promise<Array<User>>} resolves with a list of User objects\n   */\n  getUsers: function() {\n    return new Promise((resolve, reject) => {\n      this.db.all('SELECT * FROM users', (err, rows) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(rows);\n        }\n      });\n    });\n  },\n\n  getUserCount: async function() {\n    const {count} = await this.get('SELECT count(*) as count FROM users');\n    return count;\n  },\n\n  /**\n   * Get a setting or return undefined\n   * @param {String} key\n   * @return {Promise<Object?>} value\n   */\n  getSetting: async function(key) {\n    const res = await this.get('SELECT value FROM settings WHERE key=?', key);\n    if (DEBUG) {\n      console.log('getSetting', key, res);\n    }\n\n    if (!res) {\n      return;\n    }\n\n    const {value} = res;\n    if (typeof value === 'undefined') {\n      return value;\n    } else {\n      return JSON.parse(value);\n    }\n  },\n\n  /**\n   * Set a setting. Assumes that the only access to the database is\n   * single-threaded.\n   *\n   * @param {String} key\n   * @param {Object} value\n   * @return {Promise}\n   */\n  setSetting: async function(key, value) {\n    value = JSON.stringify(value);\n    const currentValue = await this.getSetting(key);\n    if (typeof currentValue === 'undefined') {\n      return this.run('INSERT INTO settings (key, value) VALUES (?, ?)',\n                      [key, value]);\n    } else {\n      return this.run('UPDATE settings SET value=? WHERE key=?', [value, key]);\n    }\n  },\n\n  /**\n   * Remove a setting. Assumes that the only access to the database is\n   * single-threaded.\n   *\n   * @param {String} key\n   * @return {Promise}\n   */\n  deleteSetting: async function(key) {\n    this.run('DELETE FROM settings WHERE key = ?', [key]);\n  },\n\n  /**\n   * Create a user\n   * @param {User} user\n   * @return {Promise<User>}\n   */\n  createUser: async function(user) {\n    const result = await this.run(\n      'INSERT INTO users ' +\n      '(email, password, name, mfaSharedSecret, mfaEnrolled, mfaBackupCodes) ' +\n      'VALUES (?, ?, ?, ?, ?, ?)',\n      [\n        user.email,\n        user.password,\n        user.name,\n        user.mfaSharedSecret,\n        user.mfaEnrolled,\n        JSON.stringify(user.mfaBackupCodes || '[]'),\n      ]\n    );\n    assert(typeof result.lastID === 'number');\n    return result.lastID;\n  },\n\n  /**\n   * Edit a user.\n   * @param {User} user\n   * @return Promise that resolves when operation is complete.\n   */\n  editUser: async function(user) {\n    assert(typeof user.id === 'number');\n    return this.run(\n      'UPDATE users SET ' +\n      'email=?, password=?, name=?, mfaSharedSecret=?, mfaEnrolled=?, ' +\n      'mfaBackupCodes=? WHERE id=?',\n      [\n        user.email,\n        user.password,\n        user.name,\n        user.mfaSharedSecret,\n        user.mfaEnrolled,\n        JSON.stringify(user.mfaBackupCodes || '[]'),\n        user.id,\n      ]\n    );\n  },\n\n  /**\n   * Delete a user.\n   * @param {Number} userId\n   * @return Promise that resolves when operation is complete.\n   */\n  deleteUser: function(userId) {\n    assert(typeof userId === 'number');\n    const deleteUser = this.run(\n      'DELETE FROM users WHERE id = ?',\n      [userId]\n    );\n    const deleteTokens = this.deleteJSONWebTokensForUser(userId);\n    /**\n     * XXX: This is a terrible hack until we get foreign key constraint support\n     * turned on with node-sqlite. As is this could leave junk around in the db.\n     */\n    return Promise.all([deleteTokens, deleteUser]);\n  },\n\n  /**\n   * Delete all jsonwebtoken's for a given user.\n   */\n  deleteJSONWebTokensForUser: function(userId) {\n    assert(typeof userId === 'number');\n    return this.run(\n      'DELETE FROM jsonwebtokens WHERE user = ?',\n      [userId]\n    );\n  },\n\n  /**\n   * Insert a JSONWebToken into the database\n   * @param {JSONWebToken} token\n   * @return {Promise<number>} resolved to JWT's primary key\n   */\n  createJSONWebToken: async function(token) {\n    const {keyId, user, publicKey, issuedAt, payload} = token;\n    const result = await this.run(\n      'INSERT INTO jsonwebtokens (keyId, user, issuedAt, publicKey, payload) ' +\n      'VALUES (?, ?, ?, ?, ?)',\n      [keyId, user, issuedAt, publicKey, JSON.stringify(payload)]\n    );\n    assert(typeof result.lastID === 'number');\n    return result.lastID;\n  },\n\n  /**\n   * Get a JWT by its key id.\n   * @param {string} keyId\n   * @return {Promise<Object>} jwt data\n   */\n  getJSONWebTokenByKeyId: function(keyId) {\n    assert(typeof keyId === 'string');\n    return this.get(\n      'SELECT * FROM jsonwebtokens WHERE keyId = ?',\n      keyId\n    );\n  },\n\n  /**\n   * Get all known JWTs of a user\n   * @param {number} userId\n   * @return {Promise<Array<Object>>}\n   */\n  getJSONWebTokensByUser: function(userId) {\n    return new Promise((resolve, reject) => {\n      this.db.all(\n        'SELECT * FROM jsonwebtokens WHERE user = ?',\n        [userId],\n        (err, rows) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(rows);\n          }\n        });\n    });\n  },\n\n  /**\n   * Delete a JWT by it's key id.\n   * @param {string} keyId\n   * @return {Promise<boolean>} whether deleted\n   */\n  deleteJSONWebTokenByKeyId: async function(keyId) {\n    assert(typeof keyId === 'string');\n    const result = await this.run(\n      'DELETE FROM jsonwebtokens WHERE keyId = ?',\n      keyId\n    );\n    return result.changes !== 0;\n  },\n\n  /**\n   * Store a new Push subscription\n   * @param {Object} subscription\n   * @return {Promise<number>} resolves to sub id\n   */\n  createPushSubscription: function(desc) {\n    const description = JSON.stringify(desc);\n\n    const insert = () => {\n      return this.run(\n        'INSERT INTO pushSubscriptions (subscription) VALUES (?)',\n        [description]\n      ).then((res) => {\n        return parseInt(res.lastID);\n      });\n    };\n\n    return this.get(\n      'SELECT id FROM pushSubscriptions WHERE subscription = ?',\n      description\n    ).then((res) => {\n      if (typeof res === 'undefined') {\n        return insert();\n      }\n\n      return res.id;\n    }).catch(() => {\n      return insert();\n    });\n  },\n\n  /**\n   * Get all push subscriptions\n   * @return {Promise<Array<PushSubscription>>}\n   */\n  getPushSubscriptions: function() {\n    return new Promise((resolve, reject) => {\n      this.db.all(\n        'SELECT id, subscription FROM pushSubscriptions',\n        [],\n        (err, rows) => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          const subs = [];\n          for (const row of rows) {\n            const sub = JSON.parse(row.subscription);\n            sub.id = row.id;\n            subs.push(sub);\n          }\n          resolve(subs);\n        }\n      );\n    });\n  },\n\n  /**\n   * Delete a single subscription\n   * @param {number} id\n   */\n  deletePushSubscription: function(id) {\n    return this.run('DELETE FROM pushSubscriptions WHERE id = ?', [id]);\n  },\n\n  /**\n   * ONLY for tests (clears all tables).\n   */\n  deleteEverything: async function() {\n    return Promise.all(TABLES.map((t) => {\n      return this.run(`DELETE FROM ${t}`);\n    }));\n  },\n\n  get: function(sql, ...params) {\n    return new Promise((accept, reject) => {\n      params.push((err, row) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        accept(row);\n      });\n\n      try {\n        this.db.get(sql, ...params);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  },\n\n  /**\n   * Run a SQL statement\n   * @param {String} sql\n   * @param {Array<any>} values\n   * @return {Promise<Object>} promise resolved to `this` of statement result\n   */\n  run: function(sql, values) {\n    return new Promise((accept, reject) => {\n      try {\n        this.db.run(sql, values, function(err) {\n          if (err) {\n            reject(err);\n            return;\n          }\n          // node-sqlite puts results on \"this\" so avoid arrrow fn.\n          accept(this);\n        });\n      } catch (err) {\n        reject(err);\n      }\n    });\n  },\n};\n\nmodule.exports = Database;\n","/**\n * Wraps up a promise in a slightly more convenient manner for passing\n * around, or saving.\n *\n * @module Deferred\n */\n\n'use strict';\n\nconst DEBUG = false;\n\nlet id = 0;\n\nclass Deferred {\n  constructor() {\n    this.id = ++id;\n    this.promise = new Promise((resolve, reject) => {\n      this.resolveFunc = resolve;\n      this.rejectFunc = reject;\n    });\n    if (DEBUG) {\n      console.log('Deferred: Created deferred promise id:', this.id);\n    }\n  }\n\n  resolve(arg) {\n    if (DEBUG) {\n      console.log('Deferred: Resolving deferred promise id:', this.id,\n                  'arg:', arg);\n    }\n    return this.resolveFunc(arg);\n  }\n\n  reject(arg) {\n    if (DEBUG) {\n      console.log('Deferred: Rejecting deferred promise id:', this.id,\n                  'arg:', arg);\n    }\n    return this.rejectFunc(arg);\n  }\n}\n\nmodule.exports = Deferred;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\n// Use webpack provided require for dynamic includes from the bundle.\nmodule.exports = (() => {\n  if (typeof __non_webpack_require__ !== 'undefined') {\n    // eslint-disable-next-line no-undef\n    return __non_webpack_require__;\n  }\n  return require;\n})();\n","/**\n * Elliptic curve helpers for the ES256 curve.\n *\n * This file contains the logic to generate public/private key pairs and return\n * them in the format openssl/crypto expects.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nimport * as asn1 from 'asn1.js';\nimport * as crypto from 'crypto';\n\n/**\n * This curve goes by different names in different standards.\n *\n * These are all equivilent for our uses:\n *\n * prime256v1 = ES256 (JWT) = secp256r1 (rfc5480) = P256 (NIST).\n */\nconst CURVE = 'prime256v1';\n\n// https://tools.ietf.org/html/rfc5915#section-3\nconst ECPrivateKeyASN = asn1.define('ECPrivateKey', function() {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('privateKey').octstr(),\n    this.key('parameters').explicit(0).objid().optional(),\n    this.key('publicKey').explicit(1).bitstr().optional()\n  );\n});\n\n// https://tools.ietf.org/html/rfc3280#section-4.1\nconst SubjectPublicKeyInfoASN = asn1.define('SubjectPublicKeyInfo', function() {\n  this.seq().obj(\n    this.key('algorithm').seq().obj(\n      this.key('id').objid(),\n      this.key('namedCurve').objid()\n    ),\n    this.key('pub').bitstr()\n  )\n});\n\n// Chosen because it is _must_ implement.\n// https://tools.ietf.org/html/rfc5480#section-2.1.1\nconst UNRESTRICTED_ALGORITHM_ID = [1, 2, 840, 10045, 2, 1];\n// https://tools.ietf.org/html/rfc5480#section-2.1.1.1 (secp256r1)\nconst SECP256R1_CURVE = [1, 2, 840, 10045, 3, 1, 7];\n\n/**\n * Generate a public/private key pair.\n *\n * The returned keys are formatted in PEM for use with openssl (crypto).\n *\n * @return {Object} .public in PEM. .prviate in PEM.\n */\nexport function generateKeyPair() {\n  const key = crypto.createECDH(CURVE);\n  key.generateKeys();\n\n  const priv = ECPrivateKeyASN.encode({\n    version: 1,\n    privateKey: key.getPrivateKey(),\n    parameters: SECP256R1_CURVE,\n  }, 'pem', {\n    // https://tools.ietf.org/html/rfc5915#section-4\n    label: 'EC PRIVATE KEY',\n  });\n\n  const pub = SubjectPublicKeyInfoASN.encode({\n    pub: {\n      unused: 0,\n      data: key.getPublicKey(),\n    },\n    algorithm: {\n      id: UNRESTRICTED_ALGORITHM_ID,\n      namedCurve: SECP256R1_CURVE,\n    },\n  }, 'pem', {\n    label: 'PUBLIC KEY',\n  });\n\n  return { public: pub, private: priv };\n}\n\nexport const JWT_ALGORITHM = 'ES256';\n","/**\n * Read data from the official ISO 639-3 table.\n */\n\n'use strict';\n\nconst fs = require('fs');\nconst {getName} = require('country-list');\nconst parse = require('csv-parse/lib/sync');\nconst path = require('path');\n\nlet parsed = false;\nconst by1 = new Map();\nconst by3 = new Map();\n\n/**\n * Parse the table in this directory.\n */\nfunction readFile() {\n  let fname;\n  try {\n    for (const name of fs.readdirSync(__dirname)) {\n      if (name.endsWith('.tab')) {\n        fname = name;\n        break;\n      }\n    }\n  } catch (e) {\n    console.error('Failed to list directory:', e);\n    return false;\n  }\n\n  if (!fname) {\n    return false;\n  }\n\n  let data;\n  try {\n    data = fs.readFileSync(path.join(__dirname, fname), 'utf8');\n  } catch (e) {\n    console.error('Failed to read ISO-639 table:', e);\n    return false;\n  }\n\n  if (!data) {\n    return false;\n  }\n\n  const records = parse(data, {delimiter: '\\t', columns: true, trim: true});\n  if (records.length === 0) {\n    return false;\n  }\n\n  for (const record of records) {\n    // Id is the 639-3 code\n    if (record.Id) {\n      by3.set(record.Id, record.Ref_Name);\n    }\n\n    // Part1 is the 639-1 code\n    if (record.Part1) {\n      by1.set(record.Part1, record.Ref_Name);\n    }\n  }\n\n  return true;\n}\n\n/**\n * Look up the provided code.\n *\n * @param {string} code - Code to look up\n * @returns {string?} Language name or undefined if not found.\n */\nfunction lookup(code) {\n  if (!parsed) {\n    if (!readFile()) {\n      return;\n    }\n\n    parsed = true;\n  }\n\n  const [language, country] = code.split('-');\n  let name;\n  if (language.length === 2) {\n    name = by1.get(language);\n  } else if (language.length === 3) {\n    name = by3.get(language);\n  } else {\n    return;\n  }\n\n  if (name && country) {\n    const countryName = getName(country) || country;\n    name = `${name} (${countryName})`;\n  }\n\n  return name;\n}\n\nmodule.exports = lookup;\n","/**\n * JWT authorization middleware.\n *\n * Contains logic to create a middleware which validates the presence of a JWT\n * token in either the header or query parameters (for websockets).\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Constants = require('./constants');\nconst JSONWebToken = require('./models/jsonwebtoken');\n\nconst AUTH_TYPE = 'Bearer';\n\n/**\n * Attempt to find the JWT in query parameters.\n *\n * @param {Request} req incoming http request.\n * @return {string|false} JWT string or false.\n */\nfunction extractJWTQS(req) {\n  if (typeof req.query === 'object' && req.query.jwt) {\n    return req.query.jwt;\n  }\n  return false;\n}\n\n/**\n *  Attempt to find the JWT in the Authorization header.\n *\n * @param {Request} req incoming http request.\n * @return {string|false} JWT string or false.\n */\nfunction extractJWTHeader(req) {\n  const {authorization} = req.headers;\n  if (!authorization) {\n    return false;\n  }\n  const [type, sig] = authorization.split(' ');\n  if (type !== AUTH_TYPE) {\n    console.warn('JWT header extraction failed: invalid auth type');\n    return false;\n  }\n  return sig;\n}\n\n/**\n * Authenticate the incoming call by checking it's JWT.\n *\n * TODO: User error messages.\n */\nasync function authenticate(req) {\n  const sig = extractJWTHeader(req) || extractJWTQS(req);\n  if (!sig) {\n    return false;\n  }\n  return await JSONWebToken.verifyJWT(sig);\n}\n\nfunction scopeAllowsRequest(scope, request) {\n  const requestPath = request.originalUrl;\n  if (!scope) {\n    return true;\n  }\n  const paths = scope.split(' ');\n  for (let path of paths) {\n    const parts = path.split(':');\n    if (parts.length !== 2) {\n      console.warn('Invalid scope', scope);\n      return false;\n    }\n    const access = parts[1];\n    const readwrite = access === Constants.READWRITE;\n    path = parts[0];\n    const allowedDirect = requestPath.startsWith(path);\n    const allowedThings = requestPath === Constants.THINGS_PATH &&\n      path.startsWith(Constants.THINGS_PATH);\n    // Allow access to media only if scope covers all things\n    const allowedMedia = requestPath.startsWith(Constants.MEDIA_PATH) &&\n      path === Constants.THINGS_PATH;\n\n    if (allowedDirect || allowedThings || allowedMedia) {\n      if (!readwrite && request.method !== 'GET' &&\n          request.method !== 'OPTIONS') {\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction middleware() {\n  return (req, res, next) => {\n    authenticate(req, res).\n      then((jwt) => {\n        if (!jwt) {\n          res.status(401).end();\n          return;\n        }\n        let scope = jwt.payload.scope;\n        if (jwt.payload.role === Constants.AUTHORIZATION_CODE) {\n          scope = `${Constants.OAUTH_PATH}:${Constants.READWRITE}`;\n        }\n        if (!scopeAllowsRequest(scope, req)) {\n          res.status(401).send(\n            `Token of role ${jwt.payload.role} used out of scope: ${scope}`);\n          return;\n        }\n        if (jwt.payload.role !== Constants.USER_TOKEN) {\n          if (!jwt.payload.scope) {\n            res.status(400)\n              .send('Token must contain scope');\n            return;\n          }\n        }\n\n        req.jwt = jwt;\n        next();\n      }).\n      catch((err) => {\n        console.error('error running jwt middleware', err.stack);\n        next(err);\n      });\n  };\n}\n\nmodule.exports = {\n  middleware,\n  authenticate,\n  extractJWTQS,\n  extractJWTHeader,\n};\n","/**\n * @module log-timestamps\n *\n * Modifies console.log and friends to prepend a timestamp to log lines.\n */\n/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst winston = require('winston');\nconst DailyRotateFile = require('winston-daily-rotate-file');\nconst UserProfile = require('./user-profile');\nconst format = require('util').format;\n\nclass CustomFormatter {\n  transform(info) {\n    const level = info.level.toUpperCase().padEnd(7, ' ');\n    info.message = `${info.timestamp} ${level}: ${info.message}`;\n    return info;\n  }\n}\n\nconst timestampFormat = winston.format.timestamp({\n  format: 'YYYY-MM-DD HH:mm:ss.SSS',\n});\n\nconst logger = winston.createLogger({\n  level: 'debug',\n  transports: [\n    new winston.transports.Console({\n      format: winston.format.combine(\n        timestampFormat,\n        new CustomFormatter(),\n        winston.format.colorize({\n          all: true,\n          colors: {\n            debug: 'white',\n            info: 'dim white',\n            warn: 'yellow',\n            error: 'red',\n          },\n        }),\n        winston.format.printf((info) => info.message)\n      ),\n    }),\n    new DailyRotateFile({\n      dirname: UserProfile.logDir,\n      filename: 'run-app.log.%DATE%',\n      symlinkName: 'run-app.log',\n      createSymlink: true,\n      zippedArchive: false,\n      maxSize: '10m',\n      maxFiles: 10,\n      format: winston.format.combine(\n        timestampFormat,\n        new CustomFormatter(),\n        winston.format.printf((info) => info.message)\n      ),\n    }),\n  ],\n  exitOnError: false,\n});\n\nfunction logPrefix() {\n  const currTime = new Date();\n  return `${currTime.getFullYear()}-${\n    (`0${currTime.getMonth() + 1}`).slice(-2)}-${\n    (`0${currTime.getDate()}`).slice(-2)} ${\n    (`0${currTime.getHours()}`).slice(-2)}:${\n    (`0${currTime.getMinutes()}`).slice(-2)}:${\n    (`0${currTime.getSeconds()}`).slice(-2)}.${\n    (`00${currTime.getMilliseconds()}`).slice(-3)} `;\n}\n\nif (!console.constructor.hooked) {\n  console.constructor.hooked = true;\n\n  // BufferedConsole is used (under jest) when running multiple tests\n  // CustomConsole is used (under jest) when running a single test\n\n  if (console.constructor.name === 'BufferedConsole') {\n    // The code for the write function comes from the jest source code:\n    // https://github.com/facebook/jest/blob/master/packages/jest-util/\n    //    src/buffered_console.js\n\n    const callsites = require('callsites');\n\n    console.constructor.write = function write(buffer, type, message, level) {\n      const call = callsites()[level != null ? level : 2];\n      const origin = `${call.getFileName()}:${call.getLineNumber()}`;\n      buffer.push({message: logPrefix() + message, origin, type});\n      return buffer;\n    };\n\n    console.log = function log() {\n      console.constructor.write(\n        this._buffer, 'log', format.apply(null, arguments));\n    };\n    console.info = function info() {\n      console.constructor.write(\n        this._buffer, 'info', format.apply(null, arguments));\n    };\n    console.warn = function warn() {\n      console.constructor.write(\n        this._buffer, 'warn', format.apply(null, arguments));\n    };\n    console.error = function error() {\n      console.constructor.write(\n        this._buffer, 'error', format.apply(null, arguments));\n    };\n    // jest's BufferedConsole doesn't provide a debug, so we skip it as well.\n  } else if (console.constructor.name === 'CustomConsole') {\n    // See: https://github.com/facebook/jest/blob/master/packages/jest-util/\n    //        src/Console.js\n    //      for the implementation of _log\n\n    console.log = function log() {\n      console._log('log', logPrefix() + format.apply(null, arguments));\n    };\n\n    console.info = function info() {\n      console._log('info', logPrefix() + format.apply(null, arguments));\n    };\n\n    console.warn = function warn() {\n      console._log('warn', logPrefix() + format.apply(null, arguments));\n    };\n\n    console.error = function error() {\n      console._log('error', logPrefix() + format.apply(null, arguments));\n    };\n    // jest's CustomConsole doesn't provide a debug, so we skip it as well.\n  } else {\n    // This path is for the normal non-jest output\n    const FUNCS = ['info', 'debug', 'error', 'warn', 'verbose', 'silly'];\n\n    for (const func of FUNCS) {\n      console[func] = function() {\n        logger[func](format.apply(null, arguments));\n      };\n    }\n\n    console.log = console.info;\n  }\n}\n","/*\n * mDNS service handler.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst config = require('config');\nconst Settings = require('./models/settings');\n\n/**\n * Get the current domain of the mDNS service.\n */\nasync function getmDNSdomain() {\n  let mDNSserviceDomain = config.get('settings.defaults.mdns.domain');\n\n  try {\n    const domain = await Settings.get('localDNSname');\n    if (mDNSserviceDomain) {\n      mDNSserviceDomain = domain;\n    }\n  } catch (_) {\n    // pass\n  }\n\n  return mDNSserviceDomain;\n}\n\n/**\n * Get the current enablement state of the mDNS service.\n */\nasync function getmDNSstate() {\n  let mDNSstate = config.get('settings.defaults.mdns.enabled');\n  try {\n    const state = await Settings.get('multicastDNSstate');\n    if (typeof state !== 'undefined') {\n      mDNSstate = state;\n    }\n  } catch (_) {\n    // pass\n  }\n\n  return mDNSstate;\n}\n\nmodule.exports = {\n  getmDNSdomain,\n  getmDNSstate,\n};\n","/**\n * Action Model.\n *\n * Manages Action data model and business logic.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Actions = require('../models/actions');\nconst Constants = require('../constants');\nconst EventEmitter = require('events');\nconst {Utils} = require('gateway-addon');\n\nclass Action extends EventEmitter {\n  /**\n   * Create a new Action\n   * @param {String} name\n   * @param {Object} input\n   * @param {Thing?} thing\n   */\n  constructor(name, input, thing) {\n    super();\n\n    this.id = Actions.generateId();\n    this.name = name;\n    this.input = input || {};\n    if (thing) {\n      this.href = `${thing.href}${Constants.ACTIONS_PATH}/${name}/${this.id}`;\n      this.thingId = thing.id;\n    } else {\n      this.href = `${Constants.ACTIONS_PATH}/${name}/${this.id}`;\n    }\n    this.status = 'created';\n    this.timeRequested = Utils.timestamp();\n    this.timeCompleted = null;\n    this.error = '';\n  }\n\n  getDescription() {\n    const description = {\n      input: this.input,\n      href: this.href,\n      status: this.status,\n      timeRequested: this.timeRequested,\n    };\n\n    if (this.timeCompleted) {\n      description.timeCompleted = this.timeCompleted;\n    }\n\n    if (this.error) {\n      description.error = this.error;\n    }\n\n    return description;\n  }\n\n  /**\n   * Update status and notify listeners\n   * @param {String} newStatus\n   */\n  updateStatus(newStatus) {\n    if (this.status === newStatus) {\n      return;\n    }\n\n    if (newStatus === 'completed') {\n      this.timeCompleted = Utils.timestamp();\n    }\n\n    this.status = newStatus;\n    this.emit(Constants.ACTION_STATUS, this);\n  }\n\n  /**\n   * Update from another action.\n   */\n  update(action) {\n    this.timeRequested = action.timeRequested;\n    this.timeCompleted = action.timeCompleted;\n\n    if (this.status !== action.status) {\n      this.status = action.status;\n      this.emit(Constants.ACTION_STATUS, this);\n    }\n  }\n}\n\nmodule.exports = Action;\n","/**\n * Actions.\n *\n * Manages a collection of Actions.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Things = require('../models/things');\nconst AddonManager = require('../addon-manager');\nconst Constants = require('../constants');\nconst EventEmitter = require('events');\n\nclass Actions extends EventEmitter {\n\n  constructor() {\n    super();\n\n    /**\n     * A map of action requests.\n     */\n    this.actions = {};\n\n    /**\n     * A counter to generate action IDs.\n     */\n    this.nextId = 0;\n\n    this.onActionStatus = this.onActionStatus.bind(this);\n  }\n\n  /**\n   * Reset actions state.\n   */\n  clearState() {\n    this.nextId = 0;\n    for (const id in this.actions) {\n      this.remove(id);\n    }\n  }\n\n  /**\n   * Generate an ID for a new action.\n   *\n   * @returns {integer} An id.\n   */\n  generateId() {\n    return `${++this.nextId}`;\n  }\n\n  /**\n   * Get a particular action.\n   *\n   * @returns {Object} The specified action, or undefined if the action\n   * doesn't exist.\n   */\n  get(id) {\n    return this.actions[id];\n  }\n\n  /**\n   * Get a list of all current actions.\n   *\n   * @returns {Array} A list of current actions.\n   */\n  getAll() {\n    return Object.keys(this.actions).map((id) => {\n      return this.actions[id];\n    });\n  }\n\n  /**\n   * Get only the actions which are not associated with a specific thing and\n   * therefore belong to the root Gateway\n   */\n  getGatewayActions(actionName) {\n    return this.getAll().filter((action) => {\n      return !action.thingId;\n    }).filter((action) => {\n      if (actionName) {\n        return actionName === action.name;\n      }\n\n      return true;\n    }).map((action) => {\n      return {[action.name]: action.getDescription()};\n    });\n  }\n\n\n  /**\n   * Get only the actions which are associated with a specific thing\n   */\n  getByThing(thingId, actionName) {\n    return this.getAll().filter((action) => {\n      return action.thingId === thingId;\n    }).filter((action) => {\n      if (actionName) {\n        return actionName === action.name;\n      }\n\n      return true;\n    }).map((action) => {\n      return {[action.name]: action.getDescription()};\n    });\n  }\n\n  /**\n   * Add a new action.\n   *\n   * @param {Action} action An Action object.\n   * @return {Promise} resolved when action added or rejected if failed\n   */\n  add(action) {\n    const id = action.id;\n    this.actions[id] = action;\n\n    // Call this initially for the 'created' status.\n    this.onActionStatus(action);\n\n    action.on(Constants.ACTION_STATUS, this.onActionStatus);\n\n    if (action.thingId) {\n      return Things.getThing(action.thingId).then((thing) => {\n        const success = thing.addAction(action);\n        if (!success) {\n          delete this.actions[id];\n          throw new Error(`Invalid thing action name: \"${action.name}\"`);\n        }\n      });\n    }\n\n    // Only update the action status if it's being handled internally\n    action.updateStatus('pending');\n\n    switch (action.name) {\n      case 'pair':\n        AddonManager.addNewThing(action.input.timeout).then(() => {\n          action.updateStatus('completed');\n        }).catch((error) => {\n          action.error = error;\n          action.updateStatus('error');\n          console.error('Thing was not added');\n          console.error(error);\n        });\n        break;\n      case 'unpair':\n        if (action.input.id) {\n          const _finally = () => {\n            console.log('unpair: thing:', action.input.id, 'was unpaired');\n            Things.removeThing(action.input.id).then(() => {\n              action.updateStatus('completed');\n            }).catch((error) => {\n              action.error = error;\n              action.updateStatus('error');\n              console.error('unpair of thing:',\n                            action.input.id, 'failed.');\n              console.error(error);\n            });\n          };\n\n          AddonManager.removeThing(action.input.id).then(_finally, _finally);\n        } else {\n          const msg = 'unpair missing \"id\" parameter.';\n          action.error = msg;\n          action.updateStatus('error');\n          console.error(msg);\n        }\n        break;\n      default:\n        delete this.actions[id];\n        return Promise.reject(\n          new Error(`Invalid action name: \"${action.name}\"`)\n        );\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Forward the actionStatus event\n   */\n  onActionStatus(action) {\n    this.emit(Constants.ACTION_STATUS, action);\n  }\n\n  /**\n   * Remove an action from the action list.\n   *\n   * @param integer id Action ID.\n   *\n   * If the action has not yet been completed, it is cancelled.\n   */\n  remove(id) {\n    const action = this.actions[id];\n    if (!action) {\n      throw `Invalid action id: ${id}`;\n    }\n\n    if (action.status === 'pending') {\n      if (action.thingId) {\n        Things.getThing(action.thingId).then((thing) => {\n          if (!thing.removeAction(action)) {\n            throw `Invalid thing action name: \"${action.name}\"`;\n          }\n        }).catch((err) => {\n          console.error('Error removing thing action:', err);\n        });\n      } else {\n        switch (action.name) {\n          case 'pair':\n            AddonManager.cancelAddNewThing();\n            break;\n          case 'unpair':\n            AddonManager.cancelRemoveThing(action.input.id);\n            break;\n          default:\n            throw `Invalid action name: \"${action.name}\"`;\n        }\n      }\n    }\n\n    action.updateStatus('deleted');\n    action.removeListener(Constants.ACTION_STATUS, this.onActionStatus);\n    delete this.actions[id];\n  }\n}\n\nmodule.exports = new Actions();\n","/**\n * Event Model.\n *\n * Manages Event data model\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst {Utils} = require('gateway-addon');\n\nclass Event {\n  /**\n   * Create a new Event\n   * @param {String} name\n   * @param {*} data\n   * @param {String?} thingId\n   * @param {String?} timestamp\n   */\n  constructor(name, data, thingId, timestamp) {\n    this.name = name;\n    this.data = typeof data === 'undefined' ? null : data;\n    this.thingId = thingId;\n    this.timestamp = timestamp || Utils.timestamp();\n  }\n\n  getDescription() {\n    return {\n      data: this.data,\n      timestamp: this.timestamp,\n    };\n  }\n}\n\nmodule.exports = Event;\n","/**\n * Events.\n *\n * Manages a collection of Events.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Things = require('../models/things');\n\nclass Events {\n\n  constructor() {\n    this.events = [];\n  }\n\n  /**\n   * Reset events state.\n   */\n  clearState() {\n    this.events = [];\n  }\n\n  /**\n   * Get only the events which are not associated with a specific thing and\n   * therefore belong to the root Gateway.\n   */\n  getGatewayEvents(eventName) {\n    return this.events.filter((event) => {\n      return !event.thingId;\n    }).filter((event) => {\n      if (eventName) {\n        return eventName === event.name;\n      }\n\n      return true;\n    }).map((event) => {\n      return {[event.name]: event.getDescription()};\n    });\n  }\n\n\n  /**\n   * Get only the events which are associated with a specific thing.\n   */\n  getByThing(thingId, eventName) {\n    return this.events.filter((event) => {\n      return event.thingId === thingId;\n    }).filter((event) => {\n      if (eventName) {\n        return eventName === event.name;\n      }\n\n      return true;\n    }).map((event) => {\n      return {[event.name]: event.getDescription()};\n    });\n  }\n\n  /**\n   * Add a new event.\n   *\n   * @param {Object} event An Event object.\n   * @returns {Promise} Promise which resolves when the event has been added.\n   */\n  add(event) {\n    this.events.push(event);\n\n    if (event.thingId) {\n      return Things.getThing(event.thingId).then((thing) => {\n        thing.dispatchEvent(event);\n      }).catch(() => {\n        console.warn('Received event for unknown thing:', event.thingId);\n      });\n    }\n\n    return Promise.resolve();\n  }\n}\n\nmodule.exports = new Events();\n","/**\n * JSONWebToken Model.\n *\n * Contains logic to create and verify JWT tokens.\n *\n * This file contains the logic to generate public/private key pairs and return\n * them in the format openssl/crypto expects.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst {v4: uuidv4} = require('uuid');\nconst jwt = require('jsonwebtoken');\nconst assert = require('assert');\n\nconst ec = require('../ec-crypto');\nconst Database = require('../db');\nconst Settings = require('./settings');\n\nconst ROLE_USER_TOKEN = 'user_token';\n\nclass JSONWebToken {\n\n  /**\n   * Verify a JWT by it's signature.\n   *\n   * @return {JSONWebToken|bool} false when invalid JSONWebToken when valid.\n   */\n  static async verifyJWT(sig) {\n    const decoded = jwt.decode(sig, {\n      complete: true,\n    });\n\n    if (!decoded || !decoded.header || !decoded.header.kid) {\n      return false;\n    }\n\n    const {kid} = decoded.header;\n\n    const tokenData = await Database.getJSONWebTokenByKeyId(kid);\n    if (!tokenData) {\n      return false;\n    }\n\n    const token = new JSONWebToken(tokenData);\n    token.payload = token.verify(sig);\n    if (token.payload) {\n      return token;\n    }\n\n    return false;\n  }\n\n  /**\n   * Issue a JWT token and store it in the database.\n   *\n   * @param {User} user to issue token for.\n   * @return {string} the JWT token signature.\n   */\n  static async issueToken(user) {\n    const {sig, token} = await this.create(user);\n    await Database.createJSONWebToken(token);\n    return sig;\n  }\n\n  /**\n   * Issue a JWT token for an OAuth2 client and store it in the\n   * database.\n   *\n   * @param {ClientRegistry} client to issue token for.\n   * @param {number} user user id associated with token\n   * @param {{role: String, scope: String}} payload of token\n   * @return {string} the JWT token signature.\n   */\n  static async issueOAuthToken(client, user, payload) {\n    const {sig, token} = await this.create(user, Object.assign({\n      client_id: client.id,\n    }, payload));\n    await Database.createJSONWebToken(token);\n    return sig;\n  }\n\n  /**\n   * Remove a JWT token from the database by it's key id.\n   *\n   * @param {string} keyId of the record to remove.\n   * @return bool true when a record was deleted.\n   */\n  static async revokeToken(keyId) {\n    assert(typeof keyId === 'string');\n    return Database.deleteJSONWebTokenByKeyId(keyId);\n  }\n\n  /**\n   * @param number user id of the user to create a token for.\n   * @return {Object} containing .sig (the jwt signature) and .token\n   *  for storage in the database.\n   */\n  static async create(user, payload = {role: ROLE_USER_TOKEN}) {\n    const pair = ec.generateKeyPair();\n\n    const keyId = uuidv4();\n    const tunnelInfo = await Settings.getTunnelInfo();\n    const issuer = tunnelInfo.tunnelDomain;\n    const options = {\n      algorithm: ec.JWT_ALGORITHM,\n      keyid: keyId,\n    };\n    if (issuer) {\n      options.issuer = issuer;\n    }\n\n    const sig = jwt.sign(payload, pair.private, options);\n\n    const token = {\n      user,\n      issuedAt: new Date(),\n      publicKey: pair.public,\n      keyId,\n      payload,\n    };\n\n    return {sig, token};\n  }\n\n  constructor(obj) {\n    const {user, issuedAt, publicKey, keyId} = obj;\n    assert(typeof user === 'number');\n    assert(issuedAt);\n    assert(typeof publicKey === 'string');\n    assert(typeof keyId === 'string');\n    this.user = user;\n    this.issuedAt = issuedAt;\n    this.publicKey = publicKey;\n    this.keyId = keyId;\n    this.payload = {};\n  }\n\n  /**\n   * Verify that the given JWT matches this token.\n   *\n   * @param string sig jwt token.\n   * @returns {Object|false} jwt payload if signature matches.\n   */\n  verify(sig) {\n    try {\n      return jwt.verify(sig, this.publicKey, {\n        algorithms: [ec.JWT_ALGORITHM],\n      });\n    } catch (err) {\n      // If this error is thrown we know the token is invalid.\n      if (err.name === 'JsonWebTokenError') {\n        return false;\n      }\n      throw err;\n    }\n  }\n\n}\n\nmodule.exports = JSONWebToken;\n","const config = require('config');\nconst fs = require('fs');\nconst path = require('path');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst AddonManager = require('../addon-manager');\nconst Constants = require('../constants');\nconst UserProfile = require('../user-profile');\n\nconst METRICS_NUMBER = 'metricsNumber';\nconst METRICS_BOOLEAN = 'metricsBoolean';\nconst METRICS_OTHER = 'metricsOther';\n\nclass Logs {\n  constructor() {\n    this.db = null;\n    this.idToDescr = {};\n    this.descrToId = {};\n    this.onPropertyChanged = this.onPropertyChanged.bind(this);\n    this.clearOldMetrics = this.clearOldMetrics.bind(this);\n\n    AddonManager.on(Constants.PROPERTY_CHANGED, this.onPropertyChanged);\n\n    // Clear out old metrics every hour\n    this.clearOldMetricsInterval =\n      setInterval(this.clearOldMetrics, 60 * 60 * 1000);\n  }\n\n  clear() {\n    this.idToDescr = {};\n    this.descrToId = {};\n    return Promise.all([\n      METRICS_NUMBER,\n      METRICS_BOOLEAN,\n      METRICS_OTHER,\n      'metricIds',\n    ].map((table) => {\n      return this.run(`DELETE FROM ${table}`);\n    }));\n  }\n\n  close() {\n    if (this.db) {\n      this.db.close();\n      this.db = null;\n    }\n\n    AddonManager.removeListener(Constants.PROPERTY_CHANGED,\n                                this.onPropertyChanged);\n    clearInterval(this.clearOldMetricsInterval);\n  }\n\n  open() {\n    // Get all things, create table if not exists\n    // If the database is already open, just return.\n    if (this.db) {\n      return;\n    }\n\n    const filename = path.join(UserProfile.logDir, 'logs.sqlite3');\n\n    let exists = fs.existsSync(filename);\n    const removeBeforeOpen = config.get('database.removeBeforeOpen');\n    if (exists && removeBeforeOpen) {\n      fs.unlinkSync(filename);\n      exists = false;\n    }\n\n    console.log(exists ? 'Opening' : 'Creating', 'database:', filename);\n    // Open database or create it if it doesn't exist\n    this.db = new sqlite3.Database(filename);\n\n    // Set a timeout in case the database is locked. 10 seconds is a bit long,\n    // but it's better than crashing.\n    this.db.configure('busyTimeout', 10000);\n\n    this.createTables().then(() => {\n      this.loadKnownMetrics();\n    });\n  }\n\n  createTables() {\n    return Promise.all([\n      this.createMetricTable(METRICS_NUMBER, typeof 0),\n      this.createMetricTable(METRICS_BOOLEAN, typeof false),\n      this.createMetricTable(METRICS_OTHER, typeof {}),\n      this.createIdTable(),\n    ]);\n  }\n\n  createIdTable() {\n    // We use a version of sqlite which doesn't support foreign keys so id is\n    // an integer referenced by the metric tables\n    return this.run(`CREATE TABLE IF NOT EXISTS metricIds (\n      id INTEGER PRIMARY KEY ASC,\n      descr TEXT,\n      maxAge INTEGER\n    );`, []);\n  }\n\n  createMetricTable(id, type) {\n    const table = id;\n    let sqlType = 'TEXT';\n\n    switch (type) {\n      case 'number':\n        sqlType = 'REAL';\n        break;\n      case 'boolean':\n        sqlType = 'INTEGER';\n        break;\n    }\n\n    return this.run(`CREATE TABLE IF NOT EXISTS ${table} (\n      id INTEGER,\n      date DATE,\n      value ${sqlType}\n    );`, []);\n  }\n\n  async loadKnownMetrics() {\n    const rows = await this.all('SELECT id, descr, maxAge FROM metricIds');\n    for (const row of rows) {\n      this.idToDescr[row.id] = JSON.parse(row.descr);\n      this.idToDescr[row.id].maxAge = row.maxAge;\n      this.descrToId[row.descr] = row.id;\n    }\n  }\n\n  propertyDescr(thingId, propId) {\n    return {\n      type: 'property',\n      thing: thingId,\n      property: propId,\n    };\n  }\n\n  actionDescr(thingId, actionId) {\n    return {\n      type: 'action',\n      thing: thingId,\n      action: actionId,\n    };\n  }\n\n  eventDescr(thingId, eventId) {\n    return {\n      type: 'event',\n      thing: thingId,\n      event: eventId,\n    };\n  }\n\n  /**\n   * @param {Object} rawDescr\n   * @param {number} maxAge\n   */\n  async registerMetric(rawDescr, maxAge) {\n    const descr = JSON.stringify(rawDescr);\n    if (this.descrToId.hasOwnProperty(descr)) {\n      return;\n    }\n    const result = await this.run(\n      'INSERT INTO metricIds (descr, maxAge) VALUES (?, ?)',\n      [descr, maxAge]\n    );\n    const id = result.lastID;\n    this.idToDescr[id] = Object.assign({maxAge}, rawDescr);\n    this.descrToId[descr] = id;\n    return id;\n  }\n\n  /**\n   * @param {Object} rawDescr\n   * @param {any} rawValue\n   * @param {Date} date\n   */\n  async insertMetric(rawDescr, rawValue, date) {\n    const descr = JSON.stringify(rawDescr);\n    if (!this.descrToId.hasOwnProperty(descr)) {\n      return;\n    }\n    const id = this.descrToId[descr];\n\n    let table = METRICS_OTHER;\n    let value = rawValue;\n\n    switch (typeof rawValue) {\n      case 'boolean':\n        table = METRICS_BOOLEAN;\n        break;\n      case 'number':\n        table = METRICS_NUMBER;\n        break;\n      default:\n        value = JSON.stringify(rawValue);\n        break;\n    }\n\n    await this.run(\n      `INSERT INTO ${table} (id, date, value) VALUES (?, ?, ?)`,\n      [id, date, value]\n    );\n  }\n\n  /**\n   * Remove a metric with all its associated data\n   * @param {Object} rawDescr\n   */\n  async unregisterMetric(rawDescr) {\n    const descr = JSON.stringify(rawDescr);\n    const id = this.descrToId[descr];\n    await Promise.all([\n      'metricIds',\n      METRICS_NUMBER,\n      METRICS_BOOLEAN,\n      METRICS_OTHER,\n    ].map((table) => {\n      return this.run(`DELETE FROM ${table} WHERE id = ?`,\n                      [id]);\n    }));\n    delete this.descrToId[descr];\n    delete this.idToDescr[id];\n  }\n\n  onPropertyChanged(property) {\n    const thingId = property.device.id;\n    const descr = this.propertyDescr(thingId, property.name);\n    this.insertMetric(descr, property.value, new Date());\n  }\n\n  onEvent() {\n  }\n\n  onAction() {\n  }\n\n  buildQuery(table, id, start, end, limit) {\n    const conditions = [];\n    const params = [];\n    if (typeof id === 'number') {\n      conditions.push('id = ?');\n      params.push(id);\n    }\n    if (start || start === 0) {\n      conditions.push('date > ?');\n      params.push(start);\n    }\n    if (end) {\n      conditions.push('date < ?');\n      params.push(end);\n    }\n\n    let query = `SELECT id, value, date FROM ${table}`;\n    if (conditions.length > 0) {\n      query += ' WHERE ';\n      query += conditions.join(' AND ');\n    }\n    if (limit) {\n      query += ` LIMIT ${limit}`;\n    }\n    return {\n      query,\n      params,\n    };\n  }\n\n  async loadMetrics(out, table, transformer, id, start, end) {\n    const {query, params} = this.buildQuery(table, id, start, end);\n    const rows = await this.all(query, params);\n\n    for (const row of rows) {\n      const descr = this.idToDescr[row.id];\n      if (!descr) {\n        console.error('Failed to load row:', row);\n        continue;\n      }\n      if (!out.hasOwnProperty(descr.thing)) {\n        out[descr.thing] = {};\n      }\n      if (!out[descr.thing].hasOwnProperty(descr.property)) {\n        out[descr.thing][descr.property] = [];\n      }\n      const value = transformer ? transformer(row.value) : row.value;\n      out[descr.thing][descr.property].push({\n        value: value,\n        date: row.date,\n      });\n    }\n  }\n\n  async getAll(start, end) {\n    const out = {};\n    await this.loadMetrics(out, METRICS_NUMBER, null, null, start, end);\n    await this.loadMetrics(out, METRICS_BOOLEAN, (value) => !!value, null,\n                           start, end);\n    await this.loadMetrics(out, METRICS_OTHER, (value) => JSON.parse(value),\n                           null, start, end);\n    return out;\n  }\n\n  async get(thingId, start, end) {\n    const all = await this.getAll(start, end);\n    return all[thingId];\n  }\n\n  async getProperty(thingId, propertyName, start, end) {\n    const descr = this.propertyDescr(thingId, propertyName);\n    const out = {};\n    const id = this.descrToId[descr];\n    // TODO determine property type to only do one of these\n    await this.loadMetrics(out, METRICS_NUMBER, null, id, start, end);\n    await this.loadMetrics(out, METRICS_BOOLEAN, (value) => !!value, id, start,\n                           end);\n    await this.loadMetrics(out, METRICS_OTHER, (value) => JSON.parse(value),\n                           id, start, end);\n    return out[thingId][propertyName];\n  }\n\n  async getSchema() {\n    await this.loadKnownMetrics();\n    const schema = [];\n    for (const id in this.idToDescr) {\n      const descr = this.idToDescr[id];\n      schema.push({\n        id,\n        thing: descr.thing,\n        property: descr.property,\n      });\n    }\n    return schema;\n  }\n\n  async streamMetrics(callback, table, transformer, id, start, end) {\n    const MAX_ROWS = 10000;\n    start = start || 0;\n    end = end || Date.now();\n\n    let queryCompleted = false;\n    while (!queryCompleted) {\n      const {query, params} = this.buildQuery(table, id, start, end, MAX_ROWS);\n      const rows = await this.all(query, params);\n      if (rows.length < MAX_ROWS) {\n        queryCompleted = true;\n      }\n      callback(rows.map((row) => {\n        const value = transformer ? transformer(row.value) : row.value;\n        return {\n          id: row.id,\n          value: value,\n          date: row.date,\n        };\n      }));\n      if (!queryCompleted) {\n        const lastRow = rows[rows.length - 1];\n        start = lastRow.date;\n        if (start >= end) {\n          queryCompleted = true;\n        }\n      }\n    }\n  }\n\n  async streamAll(callback, start, end) {\n    // Stream all three in parallel, which should look cool\n    await Promise.all([\n      this.streamMetrics(callback, METRICS_NUMBER, null, null, start, end),\n      this.streamMetrics(callback, METRICS_BOOLEAN,\n                         (value) => !!value, null, start, end),\n      this.streamMetrics(callback, METRICS_OTHER,\n                         (value) => JSON.parse(value), null, start, end),\n    ]);\n  }\n\n  async clearOldMetrics() {\n    await this.loadKnownMetrics();\n    for (const id in this.idToDescr) {\n      const descr = this.idToDescr[id];\n      if (descr.maxAge <= 0) {\n        continue;\n      }\n      const date = new Date(Date.now() - descr.maxAge);\n      await Promise.all([\n        METRICS_NUMBER,\n        METRICS_BOOLEAN,\n        METRICS_OTHER,\n      ].map((table) => {\n        return this.run(`DELETE FROM ${table} WHERE id = ? AND date < ?`,\n                        [id, date]);\n      }));\n    }\n  }\n\n  all(sql, ...params) {\n    return new Promise((accept, reject) => {\n      params.push(function(err, rows) {\n        if (err) {\n          reject(err);\n          return;\n        }\n        accept(rows);\n      });\n\n      try {\n        this.db.all(sql, ...params);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  }\n\n  /**\n   * Run a SQL statement\n   * @param {String} sql\n   * @param {Array<any>} values\n   * @return {Promise<Object>} promise resolved to `this` of statement result\n   */\n  run(sql, values) {\n    return new Promise((accept, reject) => {\n      try {\n        this.db.run(sql, values, function(err) {\n          if (err) {\n            reject(err);\n            return;\n          }\n          // node-sqlite puts results on \"this\" so avoid arrrow fn.\n          accept(this);\n        });\n      } catch (err) {\n        reject(err);\n      }\n    });\n  }\n}\n\nmodule.exports = new Logs();\n\n","'use strict';\n\nimport { URL } from 'url';\nimport {Scope, ClientId, ClientRegistry} from '../oauth-types';\nconst config = require('config');\nconst Database = require('../db');\n\n\nclass OAuthClients {\n  private clients: Map<string, Array<ClientRegistry>> = new Map();\n  constructor() {\n  }\n\n  register(client: ClientRegistry) {\n    if (this.clients.get(client.id)) {\n      this.clients.get(client.id)!.push(client);\n    } else {\n      this.clients.set(client.id, [client]);\n    }\n  }\n\n  get(id: string, redirectUri: URL|undefined): ClientRegistry|undefined {\n    const clients = this.clients.get(id);\n    if (!clients) {\n      return;\n    }\n    if (!redirectUri) {\n      return clients[0];\n    }\n    for (let client of clients) {\n      if (client.redirect_uri.href === redirectUri.href) {\n        return client;\n      }\n    }\n    return clients[0];\n  }\n\n  async getAuthorized(userId: number): Promise<Array<ClientRegistry>> {\n    let jwts = await Database.getJSONWebTokensByUser(userId);\n    let authorized = new Map();\n\n    for (let jwt of jwts) {\n      let payload = JSON.parse(jwt.payload);\n      if (payload.role !== 'access_token') {\n        continue;\n      }\n      if (!this.clients.has(payload.client_id)) {\n        console.warn('Orphaned access_token', jwt);\n        await Database.deleteJSONWebTokenByKeyId(jwt.keyId);\n        continue;\n      }\n      const defaultClient = this.clients.get(payload.client_id)![0];\n      if (!defaultClient) {\n        continue;\n      }\n      authorized.set(payload.client_id, defaultClient);\n    }\n\n    return Array.from(authorized.values());\n  }\n\n  async revokeClientAuthorization(userId: number, clientId: string) {\n    let jwts = await Database.getJSONWebTokensByUser(userId);\n\n    for (let jwt of jwts) {\n      let payload = JSON.parse(jwt.payload);\n      if (payload.client_id === clientId) {\n        await Database.deleteJSONWebTokenByKeyId(jwt.keyId);\n      }\n    }\n  }\n}\n\nlet oauthClients = new OAuthClients();\n\nif (config.get('oauthTestClients')) {\n  oauthClients.register(\n    new ClientRegistry(new URL('http://127.0.0.1:31338/callback'), 'test',\n                       'Test OAuth Client', 'super secret', '/things:readwrite')\n  );\n\n  oauthClients.register(\n    new ClientRegistry(new URL('http://127.0.0.1:31338/bonus-entry'), 'test',\n                       'Test OAuth Client', 'other secret', '/things:readwrite')\n  );\n\n  oauthClients.register(\n    new ClientRegistry(new URL('http://localhost:8888/callback'), 'mycroft',\n                       'Mycroft', 'bDaQN6yDgI0GlvJL2UVcIAb4M8c', '/things:readwrite')\n  );\n}\n\noauthClients.register(\n  new ClientRegistry(new URL('https://gateway.localhost/oauth/local-token-service'), 'local-token',\n                     'Local Token Service', 'super secret',\n                     '/things:readwrite')\n);\n\noauthClients.register(\n  new ClientRegistry(new URL('https://api.mycroft.ai/v1/auth/callback'), 'mycroft',\n                     'Mycroft', 'bDaQN6yDgI0GlvJL2UVcIAb4M8c', '/things:readwrite')\n);\n\noauthClients.register(\n  new ClientRegistry(new URL('https://api-test.mycroft.ai/v1/auth/callback'), 'mycroft',\n                     'Mycroft', 'bDaQN6yDgI0GlvJL2UVcIAb4M8c', '/things:readwrite')\n);\n\nexport default oauthClients;\n","/**\n * Settings Model.\n *\n * Manages the getting and setting of settings\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst config = require('config');\nconst Database = require('../db');\nconst util = require('util');\n\nconst DEBUG = false || (process.env.NODE_ENV === 'test');\n\nconst Settings = {\n\n  /**\n   * Get a setting.\n   *\n   * @param {String} key Key of setting to get.\n   */\n  get: (key) => Database.getSetting(key).catch((e) => {\n    console.error('Failed to get', key);\n    throw e;\n  }),\n\n  /**\n   * Set a setting.\n   *\n   * @param {String} key Key of setting to set.\n   * @param value Value to set key to.\n   */\n  set: (key, value) => Database.setSetting(key, value).then(() => {\n    if (DEBUG) {\n      console.log('Set', key, 'to',\n                  util.inspect(value, {breakLength: Infinity}));\n    }\n    return value;\n  }).catch((e) => {\n    console.error('Failed to set', key, 'to',\n                  util.inspect(value, {breakLength: Infinity}));\n    throw e;\n  }),\n\n  /**\n   * Delete a setting.\n   *\n   * @param {String} key Key of setting to delete.\n   */\n  delete: (key) => Database.deleteSetting(key).catch((e) => {\n    console.error('Failed to delete', key);\n    throw e;\n  }),\n\n  /**\n   * Get an object of all tunnel settings\n   * @return {localDomain, mDNSstate, tunnelDomain}\n   */\n  getTunnelInfo: async () => {\n    // Check to see if we have a tunnel endpoint first\n    const result = await Settings.get('tunneltoken');\n    let localDomain;\n    let mDNSstate;\n    let tunnelEndpoint;\n\n    if (typeof result === 'object') {\n      console.log(`Tunnel domain found. Tunnel name is: ${result.name} and`,\n                  `tunnel domain is: ${config.get('ssltunnel.domain')}`);\n      tunnelEndpoint =\n        `https://${result.name}.${config.get('ssltunnel.domain')}`;\n    } else {\n      tunnelEndpoint = 'Not set.';\n    }\n\n    // Find out our default local DNS name Check for a previous name in the\n    // DB, if that does not exist use the default.\n    try {\n      mDNSstate = await Settings.get('multicastDNSstate');\n      localDomain = await Settings.get('localDNSname');\n      // If our DB is empty use defaults\n      if (typeof mDNSstate === 'undefined') {\n        mDNSstate = config.get('settings.defaults.mdns.enabled');\n      }\n      if (typeof localDomain === 'undefined') {\n        localDomain = config.get('settings.defaults.mdns.domain');\n      }\n    } catch (err) {\n      // Catch this DB error. Since we don't know what state the mDNS process\n      // should be in make sure it's off\n      console.error(`Error getting DB entry for multicast from the DB: ${err}`);\n      localDomain = config.get('settings.defaults.mdns.domain');\n    }\n\n    console.log(`Tunnel name is set to: ${tunnelEndpoint}`);\n    console.log(`Local mDNS Service Domain Name is: ${localDomain}`);\n    return {\n      localDomain,\n      mDNSstate,\n      tunnelDomain: tunnelEndpoint,\n    };\n  },\n};\n\nmodule.exports = Settings;\n","/**\n * Thing Model.\n *\n * Represents a Web Thing.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Constants = require('../constants');\nconst Database = require('../db');\nconst EventEmitter = require('events');\nconst Router = require('../router');\nconst UserProfile = require('../user-profile');\nconst fs = require('fs');\nconst path = require('path');\nconst tmp = require('tmp');\n\nclass Thing {\n  /**\n   * Thing constructor.\n   *\n   * Create a Thing object from an id and a valid Thing description.\n   *\n   * @param {String} id Unique ID.\n   * @param {Object} description Thing description.\n   */\n  constructor(id, description) {\n    if (!id || !description) {\n      console.error('id and description needed to create new Thing');\n      return;\n    }\n    // Parse the Thing Description\n    this.id = id;\n    this.title = description.title || description.name || '';\n    this['@context'] =\n      description['@context'] || 'https://iot.mozilla.org/schemas';\n    this['@type'] = description['@type'] || [];\n    this.description = description.description || '';\n    this.href = `${Constants.THINGS_PATH}/${encodeURIComponent(this.id)}`;\n    this.properties = {};\n    this.actions = description.actions || {};\n    this.events = description.events || {};\n    this.connected = false;\n    this.eventsDispatched = [];\n    this.emitter = new EventEmitter();\n    if (description.properties) {\n      for (const propertyName in description.properties) {\n        const property = description.properties[propertyName];\n\n        if (property.hasOwnProperty('href')) {\n          delete property.href;\n        }\n\n        if (property.hasOwnProperty('links')) {\n          property.links = property.links.filter((link) => {\n            return link.rel && link.rel !== 'property';\n          }).map((link) => {\n            if (link.proxy) {\n              delete link.proxy;\n              link.href = `${Constants.PROXY_PATH}/${encodeURIComponent(this.id)}${link.href}`;\n            }\n\n            return link;\n          });\n        } else {\n          property.links = [];\n        }\n\n        // Give the property a URL\n        property.links.push({\n          rel: 'property',\n          href: `${this.href}${Constants.PROPERTIES_PATH}/${encodeURIComponent(propertyName)}`,\n        });\n\n        this.properties[propertyName] = property;\n      }\n    }\n    this.floorplanX = description.floorplanX;\n    this.floorplanY = description.floorplanY;\n    this.layoutIndex = description.layoutIndex;\n    this.selectedCapability = description.selectedCapability;\n    this.links = [\n      {\n        rel: 'properties',\n        href: `${this.href}/properties`,\n      },\n      {\n        rel: 'actions',\n        href: `${this.href}/actions`,\n      },\n      {\n        rel: 'events',\n        href: `${this.href}/events`,\n      },\n    ];\n\n    const uiLink = {\n      rel: 'alternate',\n      mediaType: 'text/html',\n      href: this.href,\n    };\n\n    if (description.hasOwnProperty('baseHref') && description.baseHref) {\n      Router.addProxyServer(this.id, description.baseHref);\n    }\n\n    if (description.hasOwnProperty('links')) {\n      for (const link of description.links) {\n        if (['properties', 'actions', 'events'].includes(link.rel)) {\n          continue;\n        }\n\n        if (link.rel === 'alternate' && link.mediaType === 'text/html') {\n          if (link.proxy) {\n            delete link.proxy;\n            uiLink.href = `${Constants.PROXY_PATH}/${encodeURIComponent(this.id)}${link.href}`;\n          } else {\n            uiLink.href = link.href;\n          }\n        } else {\n          if (link.proxy) {\n            delete link.proxy;\n            link.href = `${Constants.PROXY_PATH}/${encodeURIComponent(this.id)}${link.href}`;\n          }\n\n          this.links.push(link);\n        }\n      }\n    }\n\n    this.links.push(uiLink);\n\n    for (const actionName in this.actions) {\n      const action = this.actions[actionName];\n\n      if (action.hasOwnProperty('href')) {\n        delete action.href;\n      }\n\n      if (action.hasOwnProperty('links')) {\n        action.links = action.links.filter((link) => {\n          return link.rel && link.rel !== 'action';\n        }).map((link) => {\n          if (link.proxy) {\n            delete link.proxy;\n            link.href = `${Constants.PROXY_PATH}/${encodeURIComponent(this.id)}${link.href}`;\n          }\n\n          return link;\n        });\n      } else {\n        action.links = [];\n      }\n\n      // Give the action a URL\n      action.links.push({\n        rel: 'action',\n        href: `${this.href}${Constants.ACTIONS_PATH}/${encodeURIComponent(actionName)}`,\n      });\n    }\n\n    for (const eventName in this.events) {\n      const event = this.events[eventName];\n\n      if (event.hasOwnProperty('href')) {\n        delete event.href;\n      }\n\n      if (event.hasOwnProperty('links')) {\n        event.links = event.links.filter((link) => {\n          return link.rel && link.rel !== 'event';\n        }).map((link) => {\n          if (link.proxy) {\n            delete link.proxy;\n            link.href = `${Constants.PROXY_PATH}/${encodeURIComponent(this.id)}${link.href}`;\n          }\n\n          return link;\n        });\n      } else {\n        event.links = [];\n      }\n\n      // Give the event a URL\n      event.links.push({\n        rel: 'event',\n        href: `${this.href}${Constants.EVENTS_PATH}/${encodeURIComponent(eventName)}`,\n      });\n    }\n\n    this.iconHref = null;\n    if (description.iconHref) {\n      this.iconHref = description.iconHref;\n    } else if (description.iconData) {\n      this.setIcon(description.iconData, false);\n    }\n  }\n\n  /**\n   * Set the x and y co-ordinates for a Thing on the floorplan.\n   *\n   * @param {number} x The x co-ordinate on floorplan (0-100).\n   * @param {number} y The y co-ordinate on floorplan (0-100).\n   * @return {Promise} A promise which resolves with the description set.\n   */\n  setCoordinates(x, y) {\n    this.floorplanX = x;\n    this.floorplanY = y;\n    return Database.updateThing(this.id, this.getDescription())\n      .then((descr) => {\n        this.emitter.emit(Constants.MODIFIED);\n        return descr;\n      });\n  }\n\n  /**\n   * Set the layout index for a Thing.\n   *\n   * @param {number} index The new layout index.\n   * @return {Promise} A promise which resolves with the description set.\n   */\n  setLayoutIndex(index) {\n    this.layoutIndex = index;\n    return Database.updateThing(this.id, this.getDescription())\n      .then((descr) => {\n        this.emitter.emit(Constants.MODIFIED);\n        return descr;\n      });\n  }\n\n  /**\n   * Set the title of this Thing.\n   *\n   * @param {String} title The new title\n   * @return {Promise} A promise which resolves with the description set.\n   */\n  setTitle(title) {\n    this.title = title;\n    return Database.updateThing(this.id, this.getDescription())\n      .then((descr) => {\n        this.emitter.emit(Constants.MODIFIED);\n        return descr;\n      });\n  }\n\n  /**\n   * Set the custom icon for this Thing.\n   *\n   * @param {Object} iconData Base64-encoded icon and its mime-type.\n   * @param {Boolean} updateDatabase Whether or not to update the database after\n   *                                 setting.\n   */\n  setIcon(iconData, updateDatabase) {\n    if (!iconData.data ||\n        !['image/jpeg', 'image/png', 'image/svg+xml'].includes(iconData.mime)) {\n      console.error('Invalid icon data:', iconData);\n      return;\n    }\n\n    if (this.iconHref) {\n      try {\n        fs.unlinkSync(path.join(UserProfile.baseDir, this.iconHref));\n      } catch (e) {\n        console.error('Failed to remove old icon:', e);\n        // continue\n      }\n\n      this.iconHref = null;\n    }\n\n    let extension;\n    switch (iconData.mime) {\n      case 'image/jpeg':\n        extension = '.jpg';\n        break;\n      case 'image/png':\n        extension = '.png';\n        break;\n      case 'image/svg+xml':\n        extension = '.svg';\n        break;\n    }\n\n    let tempfile;\n    try {\n      tempfile = tmp.fileSync({\n        mode: parseInt('0644', 8),\n        template: path.join(UserProfile.uploadsDir, `XXXXXX${extension}`),\n        detachDescriptor: true,\n        keep: true,\n      });\n\n      const data = Buffer.from(iconData.data, 'base64');\n      fs.writeFileSync(tempfile.fd, data);\n    } catch (e) {\n      console.error('Failed to write icon:', e);\n      if (tempfile) {\n        try {\n          fs.unlinkSync(tempfile.fd);\n        } catch (e) {\n          // pass\n        }\n      }\n\n      return;\n    }\n\n    this.iconHref = path.join('/uploads', path.basename(tempfile.name));\n\n    if (updateDatabase) {\n      return Database.updateThing(this.id, this.getDescription())\n        .then((descr) => {\n          this.emitter.emit(Constants.MODIFIED);\n          return descr;\n        });\n    }\n  }\n\n  /**\n   * Set the selected capability of this Thing.\n   *\n   * @param {String} capability The selected capability\n   * @return {Promise} A promise which resolves with the description set.\n   */\n  setSelectedCapability(capability) {\n    this.selectedCapability = capability;\n    return Database.updateThing(this.id, this.getDescription())\n      .then((descr) => {\n        this.emitter.emit(Constants.MODIFIED);\n        return descr;\n      });\n  }\n\n  /**\n   * Dispatch an event to all listeners subscribed to the Thing\n   * @param {Event} event\n   */\n  dispatchEvent(event) {\n    if (!event.thingId) {\n      event.thingId = this.id;\n    }\n    this.eventsDispatched.push(event);\n    this.emitter.emit(Constants.EVENT, event);\n  }\n\n  /**\n   * Add a subscription to the Thing's events\n   * @param {Function} callback\n   */\n  addEventSubscription(callback) {\n    this.emitter.on(Constants.EVENT, callback);\n  }\n\n  /**\n   * Remove a subscription to the Thing's events\n   * @param {Function} callback\n   */\n  removeEventSubscription(callback) {\n    this.emitter.removeListener(Constants.EVENT, callback);\n  }\n\n  /**\n   * Add a subscription to the Thing's connected state\n   * @param {Function} callback\n   */\n  addConnectedSubscription(callback) {\n    this.emitter.on(Constants.CONNECTED, callback);\n    callback(this.connected);\n  }\n\n  /**\n   * Remove a subscription to the Thing's connected state\n   * @param {Function} callback\n   */\n  removeConnectedSubscription(callback) {\n    this.emitter.removeListener(Constants.CONNECTED, callback);\n  }\n\n  /**\n   * Add a subscription to the Thing's modified state\n   * @param {Function} callback\n   */\n  addModifiedSubscription(callback) {\n    this.emitter.on(Constants.MODIFIED, callback);\n  }\n\n  /**\n   * Remove a subscription to the Thing's modified state\n   * @param {Function} callback\n   */\n  removeModifiedSubscription(callback) {\n    this.emitter.removeListener(Constants.MODIFIED, callback);\n  }\n\n  /**\n   * Add a subscription to the Thing's removed state\n   * @param {Function} callback\n   */\n  addRemovedSubscription(callback) {\n    this.emitter.on(Constants.REMOVED, callback);\n  }\n\n  /**\n   * Remove a subscription to the Thing's removed state\n   * @param {Function} callback\n   */\n  removeRemovedSubscription(callback) {\n    this.emitter.removeListener(Constants.REMOVED, callback);\n  }\n\n\n  /**\n   * Get a JSON Thing Description for this Thing.\n   *\n   * @param {String} reqHost request host, if coming via HTTP\n   * @param {Boolean} reqSecure whether or not the request is secure, i.e. TLS\n   */\n  getDescription(reqHost, reqSecure) {\n    const desc = {\n      title: this.title,\n      '@context': this['@context'],\n      '@type': this['@type'],\n      description: this.description,\n      href: this.href,\n      properties: this.properties,\n      actions: this.actions,\n      events: this.events,\n      links: JSON.parse(JSON.stringify(this.links)),\n      floorplanX: this.floorplanX,\n      floorplanY: this.floorplanY,\n      layoutIndex: this.layoutIndex,\n      selectedCapability: this.selectedCapability,\n      iconHref: this.iconHref,\n    };\n\n    if (typeof reqHost !== 'undefined') {\n      const wsLink = {\n        rel: 'alternate',\n        href: `${reqSecure ? 'wss' : 'ws'}://${reqHost}${this.href}`,\n      };\n\n      desc.links.push(wsLink);\n\n      desc.id = `${reqSecure ? 'https' : 'http'}://${reqHost}${this.href}`;\n      desc.base = `${reqSecure ? 'https' : 'http'}://${reqHost}/`;\n      desc.securityDefinitions = {\n        oauth2_sc: {\n          scheme: 'oauth2',\n          flow: 'code',\n          authorization: `${reqSecure ? 'https' : 'http'}://${reqHost}${Constants.OAUTH_PATH}/authorize`,\n          token: `${reqSecure ? 'https' : 'http'}://${reqHost}${Constants.OAUTH_PATH}/token`,\n          scopes: [\n            `${this.href}:readwrite`,\n            this.href,\n            `${Constants.THINGS_PATH}:readwrite`,\n            Constants.THINGS_PATH,\n          ],\n        },\n      };\n      desc.security = 'oauth2_sc';\n    }\n\n    return desc;\n  }\n\n  /**\n   * Remove and clean up the Thing\n   */\n  remove() {\n    if (this.iconHref) {\n      try {\n        fs.unlinkSync(path.join(UserProfile.baseDir, this.iconHref));\n      } catch (e) {\n        console.error('Failed to remove old icon:', e);\n        // continue\n      }\n\n      this.iconHref = null;\n    }\n\n    this.emitter.emit(Constants.REMOVED, true);\n  }\n\n  /**\n   * Add an action\n   * @param {Action} action\n   * @return {boolean} Whether a known action\n   */\n  addAction(action) {\n    return this.actions.hasOwnProperty(action.name);\n  }\n\n  /**\n   * Remove an action\n   * @param {Action} action\n   * @return {boolean} Whether a known action\n   */\n  removeAction(action) {\n    return this.actions.hasOwnProperty(action.name);\n  }\n\n  /**\n   * Update a thing from a description.\n   *\n   * Thing descriptions can change as new capabilities are developed, so this\n   * method allows us to update the stored thing description.\n   *\n   * @param {Object} description Thing description.\n   * @return {Promise} A promise which resolves with the description set.\n   */\n  updateFromDescription(description) {\n    const oldDescription = JSON.stringify(this.getDescription());\n\n    // Update @context\n    this['@context'] =\n      description['@context'] || 'https://iot.mozilla.org/schemas';\n\n    // Update @type\n    this['@type'] = description['@type'] || [];\n\n    // Update description\n    this.description = description.description || '';\n\n    // Update properties\n    this.properties = {};\n    if (description.properties) {\n      for (const propertyName in description.properties) {\n        const property = description.properties[propertyName];\n\n        if (property.hasOwnProperty('href')) {\n          delete property.href;\n        }\n\n        if (property.hasOwnProperty('links')) {\n          property.links = property.links.filter((link) => {\n            return link.rel && link.rel !== 'property';\n          }).map((link) => {\n            if (link.proxy) {\n              delete link.proxy;\n              link.href = `${Constants.PROXY_PATH}/${encodeURIComponent(this.id)}${link.href}`;\n            }\n\n            return link;\n          });\n        } else {\n          property.links = [];\n        }\n\n        // Give the property a URL\n        property.links.push({\n          rel: 'property',\n          href: `${this.href}${Constants.PROPERTIES_PATH}/${encodeURIComponent(propertyName)}`,\n        });\n        this.properties[propertyName] = property;\n      }\n    }\n\n    // Update actions\n    this.actions = description.actions || {};\n    for (const actionName in this.actions) {\n      const action = this.actions[actionName];\n\n      if (action.hasOwnProperty('href')) {\n        delete action.href;\n      }\n\n      if (action.hasOwnProperty('links')) {\n        action.links = action.links.filter((link) => {\n          return link.rel && link.rel !== 'action';\n        }).map((link) => {\n          if (link.proxy) {\n            delete link.proxy;\n            link.href = `${Constants.PROXY_PATH}/${encodeURIComponent(this.id)}${link.href}`;\n          }\n\n          return link;\n        });\n      } else {\n        action.links = [];\n      }\n\n      // Give the action a URL\n      action.links.push({\n        rel: 'action',\n        href: `${this.href}${Constants.ACTIONS_PATH}/${encodeURIComponent(actionName)}`,\n      });\n    }\n\n    // Update events\n    this.events = description.events || {};\n    for (const eventName in this.events) {\n      const event = this.events[eventName];\n\n      if (event.hasOwnProperty('href')) {\n        delete event.href;\n      }\n\n      if (event.hasOwnProperty('links')) {\n        event.links = event.links.filter((link) => {\n          return link.rel && link.rel !== 'event';\n        }).map((link) => {\n          if (link.proxy) {\n            delete link.proxy;\n            link.href = `${Constants.PROXY_PATH}/${encodeURIComponent(this.id)}${link.href}`;\n          }\n\n          return link;\n        });\n      } else {\n        event.links = [];\n      }\n\n      // Give the event a URL\n      event.links.push({\n        rel: 'event',\n        href: `${this.href}${Constants.EVENTS_PATH}/${encodeURIComponent(eventName)}`,\n      });\n    }\n\n    let uiLink = {\n      rel: 'alternate',\n      mediaType: 'text/html',\n      href: this.href,\n    };\n    for (const link of this.links) {\n      if (link.rel === 'alternate' && link.mediaType === 'text/html') {\n        uiLink = link;\n        break;\n      }\n    }\n\n    if (description.hasOwnProperty('baseHref') && description.baseHref) {\n      Router.addProxyServer(this.id, description.baseHref);\n    }\n\n    // Update the UI href\n    if (description.hasOwnProperty('links')) {\n      for (const link of description.links) {\n        if (['properties', 'actions', 'events'].includes(link.rel)) {\n          continue;\n        }\n\n        if (link.rel === 'alternate' && link.mediaType === 'text/html') {\n          if (link.proxy) {\n            delete link.proxy;\n            uiLink.href = `${Constants.PROXY_PATH}/${encodeURIComponent(this.id)}${link.href}`;\n          } else {\n            uiLink.href = link.href;\n          }\n        } else {\n          if (link.proxy) {\n            delete link.proxy;\n            link.href = `${Constants.PROXY_PATH}/${encodeURIComponent(this.id)}${link.href}`;\n          }\n\n          this.links.push(link);\n        }\n      }\n    }\n\n    // If the previously selected capability is no longer present, reset it.\n    if (this.selectedCapability &&\n        !this['@type'].includes(this.selectedCapability)) {\n      this.selectedCapability = '';\n    }\n\n    return Database.updateThing(this.id, this.getDescription())\n      .then((descr) => {\n        const newDescription = JSON.stringify(this.getDescription());\n        if (newDescription !== oldDescription) {\n          this.emitter.emit(Constants.MODIFIED);\n        }\n\n        return descr;\n      });\n  }\n\n  /**\n   * Set the connected state of this thing.\n   *\n   * @param {boolean} connected - Whether or not the thing is connected\n   */\n  setConnected(connected) {\n    this.connected = connected;\n    this.emitter.emit(Constants.CONNECTED, connected);\n  }\n}\n\nmodule.exports = Thing;\n","/**\n * Things Model.\n *\n * Manages the data model and business logic for a collection of Things.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Ajv = require('ajv');\nconst EventEmitter = require('events');\n\nconst AddonManager = require('../addon-manager');\nconst Database = require('../db');\nconst Router = require('../router');\nconst Thing = require('./thing');\nconst Constants = require('../constants');\n\nconst ajv = new Ajv();\n\nconst Things = {\n\n  /**\n   * A Map of Things in the Things database.\n   */\n  things: new Map(),\n\n  /**\n   * A collection of open websockets listening for new things.\n   */\n  websockets: [],\n\n  /**\n   * The promise object returned by Database.getThings()\n   */\n  getThingsPromise: null,\n\n  /**\n   * An EventEmitter used to bubble up added things\n   *\n   * Note that this differs from AddonManager's THING_ADDED because that thing\n   * added is when the addon discovers a thing, not when the model is\n   * instantiated\n   */\n  emitter: new EventEmitter(),\n\n  /**\n   * Get all Things known to the Gateway, initially loading them from the\n   * database,\n   *\n   * @return {Promise} which resolves with a Map of Thing objects.\n   */\n  getThings: function() {\n    if (this.things.size > 0) {\n      return Promise.resolve(this.things);\n    }\n\n    if (this.getThingsPromise) {\n      // We're still waiting for the database request.\n      return this.getThingsPromise;\n    }\n\n    this.getThingsPromise = Database.getThings().then((things) => {\n      this.getThingsPromise = null;\n\n      // Update the map of Things\n      this.things = new Map();\n      things.forEach((thing, index) => {\n        // This should only happen on the first migration.\n        if (!thing.hasOwnProperty('layoutIndex')) {\n          thing.layoutIndex = index;\n        }\n\n        this.things.set(thing.id, new Thing(thing.id, thing));\n      });\n\n      return this.things;\n    });\n\n    return this.getThingsPromise;\n  },\n\n  /**\n   * Get the titles of all things.\n   *\n   * @return {Promise<Array>} which resolves with a list of all thing titles.\n   */\n  getThingTitles: function() {\n    return this.getThings().then(function(things) {\n      return Array.from(things.values()).map((t) => t.title);\n    });\n  },\n\n  /**\n   * Get Thing Descriptions for all Things stored in the database.\n   *\n   * @param {String} reqHost request host, if coming via HTTP\n   * @param {Boolean} reqSecure whether or not the request is secure, i.e. TLS\n   * @return {Promise} which resolves with a list of Thing Descriptions.\n   */\n  getThingDescriptions: function(reqHost, reqSecure) {\n    return this.getThings().then(function(things) {\n      const descriptions = [];\n      for (const thing of things.values()) {\n        descriptions.push(thing.getDescription(reqHost, reqSecure));\n      }\n      return descriptions;\n    });\n  },\n\n  /**\n   * Get a list of Things by their hrefs.\n   *\n   * {Array} hrefs hrefs of the list of Things to get.\n   * @return {Promise} A promise which resolves with a list of Things.\n   */\n  getListThings: function(hrefs) {\n    return this.getThings().then(function(things) {\n      const listThings = [];\n      for (const href of hrefs) {\n        things.forEach(function(thing) {\n          if (thing.href === href) {\n            listThings.push(thing);\n          }\n        });\n      }\n      return listThings;\n    });\n  },\n\n  /**\n   * Get Thing Descriptions for a list of Things by their hrefs.\n   *\n   * @param {Array} hrefs The hrefs of the list of Things to get\n   *                      descriptions of.\n   * @param {String} reqHost request host, if coming via HTTP.\n   * @param {Boolean} reqSecure whether or not the request is secure, i.e. TLS.\n   * @return {Promise} which resolves with a list of Thing Descriptions.\n   */\n  getListThingDescriptions: function(hrefs, reqHost, reqSecure) {\n    return this.getListThings(hrefs).then(function(listThings) {\n      const descriptions = [];\n      for (const thing of listThings) {\n        descriptions.push(thing.getDescription(reqHost, reqSecure));\n      }\n      return descriptions;\n    });\n  },\n\n  /**\n   * Get a list of things which are connected to adapters but not yet saved\n   * in the gateway database.\n   *\n   * @returns Promise A promise which resolves with a list of Things.\n   */\n  getNewThings: function() {\n    // Get a map of things in the database\n    return this.getThings().then((function(storedThings) {\n      // Get a list of things connected to adapters\n      const connectedThings = AddonManager.getThings();\n      const newThings = [];\n      connectedThings.forEach(function(connectedThing) {\n        if (!storedThings.has(connectedThing.id)) {\n          connectedThing.href =\n           `${Constants.THINGS_PATH}/${encodeURIComponent(connectedThing.id)}`;\n          if (connectedThing.properties) {\n            for (const propertyName in connectedThing.properties) {\n              const property = connectedThing.properties[propertyName];\n              property.href = `${Constants.THINGS_PATH}/${\n                encodeURIComponent(connectedThing.id)}${\n                Constants.PROPERTIES_PATH}/${\n                encodeURIComponent(propertyName)}`;\n            }\n          }\n          newThings.push(connectedThing);\n        }\n      });\n      return newThings;\n    }));\n  },\n\n  /**\n   * Create a new Thing with the given ID and description.\n   *\n   * @param String id ID to give Thing.\n   * @param Object description Thing description.\n   */\n  createThing: function(id, description) {\n    const thing = new Thing(id, description);\n    thing.connected = true;\n    thing.layoutIndex = this.things.size;\n\n    return Database.createThing(thing.id, thing.getDescription())\n      .then((thingDesc) => {\n        this.things.set(thing.id, thing);\n        this.emitter.emit(Constants.THING_ADDED, thing);\n        return thingDesc;\n      });\n  },\n\n  /**\n   * Handle a new Thing having been discovered.\n   *\n   * @param {Object} newThing - New Thing description\n   */\n  handleNewThing: function(newThing) {\n    this.getThing(newThing.id).then((thing) => {\n      thing.setConnected(true);\n      return thing.updateFromDescription(newThing);\n    }).catch(() => {\n      // If we don't already know about this thing, notify each open websocket\n      this.websockets.forEach(function(socket) {\n        socket.send(JSON.stringify(newThing));\n      });\n    });\n  },\n\n  /**\n   * Handle a thing being removed by an adapter.\n   *\n   * @param {Object} thing - Thing which was removed\n   */\n  handleThingRemoved: function(thing) {\n    this.getThing(thing.id).then((thing) => {\n      thing.setConnected(false);\n    }).catch(() => {});\n  },\n\n  /**\n   * Handle a thing's connectivity state change.\n   *\n   * @param {string} thingId - ID of thing\n   * @param {boolean} connected - New connectivity state\n   */\n  handleConnected: function(thingId, connected) {\n    this.getThing(thingId).then((thing) => {\n      thing.setConnected(connected);\n    }).catch(() => {});\n  },\n\n  /**\n   * Add a websocket to the list of new Thing subscribers.\n   *\n   * @param {Websocket} websocket A websocket instance.\n   */\n  registerWebsocket: function(websocket) {\n    this.websockets.push(websocket);\n    websocket.on('close', () => {\n      const index = this.websockets.indexOf(websocket);\n      this.websockets.splice(index, 1);\n    });\n  },\n\n  /**\n   * Get a Thing by its ID.\n   *\n   * @param {String} id The ID of the Thing to get.\n   * @return {Promise<Thing>} A Thing object.\n   */\n  getThing: function(id) {\n    return this.getThings().then(function(things) {\n      if (things.has(id)) {\n        return things.get(id);\n      } else {\n        throw new Error(`Unable to find thing with id: ${id}`);\n      }\n    });\n  },\n\n  /**\n   * Get a Thing by its title.\n   *\n   * @param {String} title The title of the Thing to get.\n   * @return {Promise<Thing>} A Thing object.\n   */\n  getThingByTitle: function(title) {\n    title = title.toLowerCase();\n\n    return this.getThings().then(function(things) {\n      for (const thing of things.values()) {\n        if (thing.title.toLowerCase() === title) {\n          return thing;\n        }\n      }\n\n      throw new Error(`Unable to find thing with title: ${title}`);\n    }).catch((e) => {\n      console.warn('Unexpected thing retrieval error', e);\n      return null;\n    });\n  },\n\n  /**\n   * Get a Thing description for a thing by its ID.\n   *\n   * @param {String} id The ID of the Thing to get a description of.\n   * @param {String} reqHost request host, if coming via HTTP\n   * @param {Boolean} reqSecure whether or not the request is secure, i.e. TLS\n   * @return {Promise<ThingDescription>} A Thing description object.\n   */\n  getThingDescription: function(id, reqHost, reqSecure) {\n    return this.getThing(id).then((thing) => {\n      return thing.getDescription(reqHost, reqSecure);\n    });\n  },\n\n  /**\n   * Remove a Thing.\n   *\n   * @param String id ID to give Thing.\n   */\n  removeThing: function(id) {\n    Router.removeProxyServer(id);\n    return Database.removeThing(id).then(() => {\n      const thing = this.things.get(id);\n      if (!thing) {\n        return;\n      }\n\n      const index = thing.layoutIndex;\n\n      thing.remove();\n      this.things.delete(id);\n\n      this.things.forEach((t) => {\n        if (t.layoutIndex > index) {\n          t.setLayoutIndex(t.layoutIndex - 1);\n        }\n      });\n    });\n  },\n\n  /**\n   * @param {String} thingId\n   * @param {String} propertyName\n   * @return {Promise<any>} resolves to value of property\n   */\n  getThingProperty: async function(thingId, propertyName) {\n    try {\n      return await AddonManager.getProperty(thingId, propertyName);\n    } catch (error) {\n      console.error('Error getting value for thingId:', thingId,\n                    'property:', propertyName);\n      console.error(error);\n      throw {\n        code: 500,\n        message: error,\n      };\n    }\n  },\n\n  /**\n   * @param {String} thingId\n   * @param {String} propertyName\n   * @param {any} value\n   * @return {Promise<any>} resolves to new value\n   */\n  setThingProperty: async function(thingId, propertyName, value) {\n    let thing;\n    try {\n      thing = await Things.getThingDescription(thingId, 'localhost', true);\n    } catch (e) {\n      throw {\n        code: 404,\n        message: 'Thing not found',\n      };\n    }\n\n    if (!thing.properties.hasOwnProperty(propertyName)) {\n      throw {\n        code: 404,\n        message: 'Property not found',\n      };\n    }\n\n    if (thing.properties[propertyName].readOnly) {\n      throw {\n        code: 400,\n        message: 'Read-only property',\n      };\n    }\n\n    const valid = ajv.validate(thing.properties[propertyName], value);\n    if (!valid) {\n      throw {\n        code: 400,\n        message: 'Invalid property value',\n      };\n    }\n\n    try {\n      const updatedValue = await AddonManager.setProperty(thingId,\n                                                          propertyName, value);\n      // Note: it's possible that updatedValue doesn't match value.\n      return updatedValue;\n    } catch (e) {\n      console.error('Error setting value for thingId:', thingId,\n                    'property:', propertyName,\n                    'value:', value);\n      throw {\n        code: 500,\n        message: e,\n      };\n    }\n  },\n\n  on: function(name, listener) {\n    this.emitter.on(name, listener);\n  },\n\n  removeListener: function(name, listener) {\n    this.emitter.removeListener(name, listener);\n  },\n\n  clearState: function() {\n    this.websockets = [];\n    this.things = new Map();\n    this.emitter.removeAllListeners();\n  },\n};\n\nAddonManager.on(Constants.THING_ADDED, (thing) => {\n  Things.handleNewThing(thing);\n});\n\nAddonManager.on(Constants.THING_REMOVED, (thing) => {\n  Things.handleThingRemoved(thing);\n});\n\nAddonManager.on(Constants.CONNECTED, ({device, connected}) => {\n  Things.handleConnected(device.id, connected);\n});\n\nmodule.exports = Things;\n","/**\n * User Model.\n *\n * Represents a user.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst crypto = require('crypto');\nconst Database = require('../db');\nconst Passwords = require('../passwords');\nconst speakeasy = require('speakeasy');\n\nclass User {\n  constructor(id, email, password, name, mfaSharedSecret, mfaEnrolled,\n              mfaBackupCodes) {\n    this.id = id;\n    this.email = email;\n    this.password = password; // Hashed\n    this.mfaSharedSecret = mfaSharedSecret;\n    this.mfaEnrolled =\n      typeof mfaEnrolled === 'number' ? mfaEnrolled === 1 : mfaEnrolled;\n    this.mfaBackupCodes = mfaBackupCodes ? JSON.parse(mfaBackupCodes) : [];\n    this.name = name;\n  }\n\n  static async generate(email, rawPassword, name) {\n    const hash = await Passwords.hash(rawPassword);\n    return new User(null, email, hash, name, '', false, '');\n  }\n\n  /**\n   * Get a JSON description for this user.\n   *\n   * @return {Object} JSON description of user.\n   */\n  getDescription() {\n    return {\n      id: this.id,\n      email: this.email,\n      name: this.name,\n      mfaEnrolled: this.mfaEnrolled,\n    };\n  }\n\n  async generateMfaParams() {\n    const secret = speakeasy.generateSecret({\n      issuer: 'WebThings Gateway',\n      name: `WebThings:${this.email}`,\n      length: 64,\n    });\n\n    this.mfaSharedSecret = secret.base32;\n    await Database.editUser(this);\n\n    return {\n      secret: this.mfaSharedSecret,\n      url: secret.otpauth_url,\n    };\n  }\n\n  async generateMfaBackupCodes() {\n    const codes = new Set();\n    while (codes.size !== 10) {\n      codes.add(crypto.randomBytes(6).toString('hex'));\n    }\n\n    this.mfaBackupCodes = [];\n    for (const code of codes) {\n      this.mfaBackupCodes.push(await Passwords.hash(code));\n    }\n\n    await Database.editUser(this);\n\n    return Array.from(codes);\n  }\n}\n\nmodule.exports = User;\n","/**\n * User Manager.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst User = require('./user');\nconst Database = require('../db');\n\nconst Users = {\n  /**\n   * Get a user from the database.\n   *\n   * @param {String} email Email address of user to look up.\n   * @return {Promise} Promise which resolves to user object\n   *   or false if user doesn't exist.\n   */\n  getUser: (email) => Database.getUser(email).then((result) => {\n    if (!result) {\n      return false;\n    }\n    return new User(\n      result.id,\n      result.email,\n      result.password,\n      result.name,\n      result.mfaSharedSecret,\n      result.mfaEnrolled,\n      result.mfaBackupCodes\n    );\n  }),\n\n  getCount: () => Database.getUserCount(),\n\n  /**\n   * Get a user from the database.\n   *\n   * @param {number} id primary key.\n   * @return {Promise} Promise which resolves to user object\n   *   or false if user doesn't exist.\n   */\n  getUserById: async (id) => {\n    if (typeof id !== 'number') {\n      id = parseInt(id, 10);\n      if (isNaN(id)) {\n        return Promise.reject('Invalid user ID');\n      }\n    }\n\n    const row = await Database.getUserById(id);\n    if (!row) {\n      return row;\n    }\n    return new User(\n      row.id,\n      row.email,\n      row.password,\n      row.name,\n      row.mfaSharedSecret,\n      row.mfaEnrolled,\n      row.mfaBackupCodes\n    );\n  },\n\n  /**\n   * Get all Users stored in the database\n   * @return {Promise<Array<User>>}\n   */\n  getUsers: () => Database.getUsers().then((userRows) => {\n    return userRows.map((row) => {\n      return new User(\n        row.id,\n        row.email,\n        row.password,\n        row.name,\n        row.mfaSharedSecret,\n        row.mfaEnrolled,\n        row.mfaBackupCodes\n      );\n    });\n  }),\n\n  /**\n   * Create a new User\n   * @param {String} email\n   * @param {String} password\n   * @param {String?} name - optional name of user\n   * @return {User} user object.\n   */\n  createUser: async (email, password, name) => {\n    const user =\n      new User(null, email.toLowerCase(), password, name, '', false, '');\n    user.id = await Database.createUser(user);\n    return user;\n  },\n\n  /**\n   * Edit an existing User\n   * @param {User} user to edit\n   * @return {Promise} Promise which resolves when operation is complete.\n   */\n  editUser: async (user) => {\n    user.email = user.email.toLowerCase();\n    await Database.editUser(user);\n  },\n\n  /**\n   * Delete an existing User\n   * @param {Number} userId\n   * @return {Promise} Promise which resolves when operation is complete.\n   */\n  deleteUser: async (userId) => {\n    if (typeof userId !== 'number') {\n      userId = parseInt(userId, 10);\n      if (isNaN(userId)) {\n        return Promise.reject('Invalid user ID');\n      }\n    }\n\n    await Database.deleteUser(userId);\n  },\n};\n\nmodule.exports = Users;\n","'use strict';\n\nimport { URL } from 'url';\nimport * as Constants from './constants';\n\ntype Read = 'read';\ntype ReadWrite = 'readwrite';\nexport type ScopeAccess = Read|ReadWrite;\nexport type Scope = {[path: string]: ScopeAccess};\n\nexport type ScopeRaw = string;\nexport type ClientId = string;\n\nexport class ClientRegistry {\n  constructor(public redirect_uri: URL, public id: ClientId, public name: string,\n              public secret: string, public scope: ScopeRaw) {\n  }\n\n  getDescription() {\n    return {\n      id: this.id,\n      name: this.name,\n      redirect_uri: this.redirect_uri,\n      scope: this.scope\n    };\n  }\n}\n\nfunction stringToScope(scopeRaw: ScopeRaw): Scope {\n  let scope: Scope = {};\n  let scopeParts = scopeRaw.split(' ');\n  for (let scopePart of scopeParts) {\n    let parts = scopePart.split(':');\n    let path = parts[0];\n    let readwrite = parts[1];\n    if (readwrite !== 'read' && readwrite !== 'readwrite') {\n      readwrite = 'read';\n    }\n    scope[path] = readwrite as 'read'|'readwrite';\n  }\n\n  return scope;\n}\n\nexport function scopeValidSubset(clientScopeRaw: ScopeRaw, requestScopeRaw: ScopeRaw): boolean {\n  if (clientScopeRaw === requestScopeRaw) {\n    return true;\n  }\n  let clientScope = stringToScope(clientScopeRaw);\n  let requestScope = stringToScope(requestScopeRaw);\n\n  if (!clientScope || !requestScope) {\n    return false;\n  }\n\n  for (let requestPath in requestScope) {\n    if (!requestPath.startsWith(Constants.THINGS_PATH)) {\n      console.warn('Invalid request for out-of-bounds scope', requestScopeRaw);\n      return false;\n    }\n    let requestAccess = requestScope[requestPath];\n    let access: ScopeAccess|undefined;\n    if (clientScope[requestPath]) {\n      access = clientScope[requestPath];\n    } else {\n      access = clientScope[Constants.THINGS_PATH];\n    }\n\n    if (!access) {\n      return false;\n    }\n\n    if (requestAccess === 'readwrite') {\n      if (access !== 'readwrite') {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n","/**\n * Password utilities.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst bcrypt = require('bcryptjs');\nconst config = require('config');\nconst speakeasy = require('speakeasy');\n\nlet rounds;\nif (config.has('bcryptRounds')) {\n  rounds = config.get('bcryptRounds');\n}\n\nmodule.exports = {\n  /**\n   * Hash a password asynchronously\n   * @param {String} password\n   * @return {Promise<String>} hashed password\n   */\n  hash: (password) => bcrypt.hash(password, rounds),\n\n  /**\n   * Hash a password synchronously.\n   * WARNING: This will block for a very long time\n   *\n   * @param {String} password\n   * @return {String} hashed password\n   */\n  hashSync: (password) => bcrypt.hashSync(password, rounds),\n\n  /**\n   * Compare two password hashes asynchronously\n   * @param {String} passwordText - a plain text password\n   * @param {String} passwordHash - the expected hash\n   * @return {Promise<boolean>} If the hashes are equal\n   */\n  // eslint-disable-next-line max-len\n  compare: (passwordText, passwordHash) => bcrypt.compare(passwordText, passwordHash),\n\n  /**\n   * Compare two password hashes\n   * @param {String} passwordText - a plain text password\n   * @param {String} passwordHash - the expected hash\n   * @return {boolean} If the hashes are equal\n   */\n  // eslint-disable-next-line max-len\n  compareSync: (passwordText, passwordHash) => bcrypt.compareSync(passwordText, passwordHash),\n\n  /**\n   * Verify a TOTP token\n   * @param {string} sharedSecret - the MFA shared secret\n   * @param {object} token - an MFA token, must contain a totp member\n   * @return {boolean} If the token has been verified\n   */\n  verifyMfaToken: (sharedSecret, token) => {\n    // only supporting TOTP for now\n    if (token.totp) {\n      return speakeasy.totp.verify({\n        secret: sharedSecret,\n        encoding: 'base32',\n        window: 1,\n        token: token.totp,\n      });\n    }\n\n    return false;\n  },\n};\n","/**\n * Platform-specific utilities.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst child_process = require('child_process');\nconst dynamicRequire = require('./dynamic-require');\nconst fs = require('fs');\nconst path = require('path');\nconst process = require('process');\n\n/**\n * Error to indicate that a method was not implemented for a platform.\n */\nclass NotImplementedError extends Error {\n  constructor(fn) {\n    super(`Method not implemented for platform: ${fn}`);\n  }\n}\n\n/**\n * Get the OS the gateway is running on.\n *\n * @returns {string|null} String describing OS. Currently, one of:\n *                        * aix\n *                        * android\n *                        * darwin\n *                        * freebsd\n *                        * openbsd\n *                        * sunos\n *                        * win32\n *                        * linux-arch\n *                        * linux-debian\n *                        * linux-openwrt\n *                        * linux-raspbian\n *                        * linux-ubuntu\n *                        * linux-unknown\n */\nfunction getOS() {\n  const platform = process.platform;\n  if (platform !== 'linux') {\n    return platform;\n  }\n\n  const proc = child_process.spawnSync('lsb_release', ['-i', '-s']);\n  if (proc.status === 0) {\n    const lsb_release = proc.stdout.toString().trim();\n    switch (lsb_release) {\n      case 'Arch':\n        return 'linux-arch';\n      case 'Debian':\n        return 'linux-debian';\n      case 'Raspbian':\n        return 'linux-raspbian';\n      case 'Ubuntu':\n        return 'linux-ubuntu';\n      default:\n        break;\n    }\n  }\n\n  if (fs.existsSync('/etc/openwrt_release')) {\n    return 'linux-openwrt';\n  }\n\n  return 'linux-unknown';\n}\n\n/**\n * Get the current architecture as \"os-machine\", i.e. darwin-x64.\n */\nfunction getArchitecture() {\n  const defaultArchitecture = `${process.platform}-${process.arch}`;\n  try {\n    return platform.getPlatformArchitecture(defaultArchitecture);\n  } catch (e) {\n    return defaultArchitecture;\n  }\n}\n\n/**\n * Determine whether or not we're running inside Docker.\n */\nfunction isDocker() {\n  return fs.existsSync('/.dockerenv') ||\n    (fs.existsSync('/proc/1/cgroup') &&\n     fs.readFileSync('/proc/1/cgroup').indexOf(':/docker/') >= 0) ||\n    fs.existsSync('/pantavisor');\n}\n\n/**\n * Get the current node version.\n */\nfunction getNodeVersion() {\n  return process.config.variables.node_module_version;\n}\n\n/**\n * Get a list of installed Python versions.\n */\nfunction getPythonVersions() {\n  const versions = new Set();\n  const parse = (output) => {\n    const parts = output.split(' ');\n    if (parts.length === 2) {\n      const match = parts[1].match(/^\\d+\\.\\d+/);\n      if (match) {\n        versions.add(match[0]);\n      }\n    }\n  };\n\n  for (const bin of ['python', 'python2', 'python3']) {\n    const proc = child_process.spawnSync(\n      bin,\n      ['--version'],\n      {encoding: 'utf8'}\n    );\n\n    if (proc.status === 0) {\n      const output = proc.stdout || proc.stderr;\n      parse(output);\n    }\n  }\n\n  return Array.from(versions).sort();\n}\n\n// Basic exports\nmodule.exports = {\n  getArchitecture,\n  getNodeVersion,\n  getOS,\n  getPythonVersions,\n  isDocker,\n  NotImplementedError,\n};\n\n// Wrap platform-specific methods\nfunction wrapPlatform(platform, fn) {\n  return (...params) => {\n    if (platform === null) {\n      throw new NotImplementedError(fn);\n    }\n\n    if (!platform.hasOwnProperty(fn)) {\n      throw new NotImplementedError(fn);\n    }\n\n    return platform[fn](...params);\n  };\n}\n\nlet platform;\ntry {\n  platform = dynamicRequire(path.resolve(path.join(__dirname,\n                                                   'platforms',\n                                                   getOS())));\n} catch (_) {\n  console.log(\n    `Failed to import platform utilities for ${getOS()}.`,\n    'Network and system configuration features will be disabled.'\n  );\n  platform = null;\n}\n\nconst wrappedMethods = [\n  'getPlatformArchitecture',\n  'getCaptivePortalStatus',\n  'setCaptivePortalStatus',\n  'getDhcpServerStatus',\n  'setDhcpServerStatus',\n  'getHostname',\n  'setHostname',\n  'getLanMode',\n  'setLanMode',\n  'getMacAddress',\n  'getMdnsServerStatus',\n  'setMdnsServerStatus',\n  'getNetworkAddresses',\n  'getSshServerStatus',\n  'setSshServerStatus',\n  'getWanMode',\n  'setWanMode',\n  'getWirelessMode',\n  'setWirelessMode',\n  'checkConnection',\n  'restartGateway',\n  'restartSystem',\n  'scanWirelessNetworks',\n  'getSelfUpdateStatus',\n  'setSelfUpdateStatus',\n  'getValidTimezones',\n  'getTimezone',\n  'setTimezone',\n  'getValidWirelessCountries',\n  'getWirelessCountry',\n  'setWirelessCountry',\n  'getNtpStatus',\n  'restartNtpSync',\n];\n\nfor (const method of wrappedMethods) {\n  module.exports[method] = wrapPlatform(platform, method);\n}\n\nmodule.exports.implemented = (fn) => platform && platform.hasOwnProperty(fn);\n","/**\n * @module AdapterProxy base class.\n *\n * Manages Adapter data model and business logic.\n */\n/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst {Adapter} = require('gateway-addon');\nconst Deferred = require('../deferred');\nconst DeviceProxy = require('./device-proxy');\nconst {MessageType} = require('gateway-addon').Constants;\n\nconst DEBUG = false;\n\n/**\n * Class used to describe an adapter from the perspective\n * of the gateway.\n */\nclass AdapterProxy extends Adapter {\n\n  constructor(addonManager, adapterId, name, packageName, plugin) {\n    super(addonManager, adapterId, packageName);\n    this.name = name;\n    this.plugin = plugin;\n    this.deferredMock = null;\n    this.unloadCompletedPromise = null;\n    this.eventHandlers = {};\n  }\n\n  startPairing(timeoutSeconds) {\n    DEBUG && console.log('AdapterProxy: startPairing',\n                         this.name, 'id', this.id);\n    this.sendMsg(\n      MessageType.ADAPTER_START_PAIRING_COMMAND,\n      {\n        timeout: timeoutSeconds,\n      }\n    );\n  }\n\n  cancelPairing() {\n    DEBUG && console.log('AdapterProxy: cancelPairing',\n                         this.name, 'id', this.id);\n    this.sendMsg(MessageType.ADAPTER_CANCEL_PAIRING_COMMAND, {});\n  }\n\n  removeThing(device) {\n    DEBUG && console.log('AdapterProxy:', this.name, 'id', this.id,\n                         'removeThing:', device.id);\n    this.sendMsg(\n      MessageType.ADAPTER_REMOVE_DEVICE_REQUEST,\n      {\n        deviceId: device.id,\n      }\n    );\n  }\n\n  cancelRemoveThing(device) {\n    DEBUG && console.log('AdapterProxy:', this.name, 'id', this.id,\n                         'cancelRemoveThing:', device.id);\n    this.sendMsg(\n      MessageType.ADAPTER_CANCEL_REMOVE_DEVICE_COMMAND,\n      {\n        deviceId: device.id,\n      }\n    );\n  }\n\n  sendMsg(methodType, data, deferred) {\n    data.adapterId = this.id;\n    return this.plugin.sendMsg(methodType, data, deferred);\n  }\n\n  /**\n   * Unloads an adapter.\n   *\n   * @returns a promise which resolves when the adapter has\n   *          finished unloading.\n   */\n  unload() {\n    if (this.unloadCompletedPromise) {\n      console.error('AdapterProxy: unload already in progress');\n      return Promise.reject();\n    }\n    this.unloadCompletedPromise = new Deferred();\n    this.sendMsg(\n      MessageType.ADAPTER_UNLOAD_REQUEST,\n      {\n        adapterId: this.id,\n      }\n    );\n    return this.unloadCompletedPromise.promise;\n  }\n\n  /**\n   * Set the PIN for the given device.\n   *\n   * @param {String} deviceId ID of the device\n   * @param {String} pin PIN to set\n   *\n   * @returns a promise which resolves when the PIN has been set.\n   */\n  setPin(deviceId, pin) {\n    return new Promise((resolve, reject) => {\n      console.log('AdapterProxy: setPin:', pin, 'for:', deviceId);\n\n      const device = this.getDevice(deviceId);\n      if (!device) {\n        reject('Device not found');\n        return;\n      }\n\n      const deferredSet = new Deferred();\n\n      deferredSet.promise.then((device) => {\n        resolve(device);\n      }).catch(() => {\n        reject();\n      });\n\n      this.sendMsg(\n        MessageType.DEVICE_SET_PIN_REQUEST,\n        {\n          deviceId,\n          pin,\n        },\n        deferredSet\n      );\n    });\n  }\n\n  /**\n   * Set the credentials for the given device.\n   *\n   * @param {String} deviceId ID of the device\n   * @param {String} username Username to set\n   * @param {String} password Password to set\n   *\n   * @returns a promise which resolves when the credentials have been set.\n   */\n  setCredentials(deviceId, username, password) {\n    return new Promise((resolve, reject) => {\n      console.log('AdapterProxy: setCredentials:', username, password, 'for:',\n                  deviceId);\n\n      const device = this.getDevice(deviceId);\n      if (!device) {\n        reject('Device not found');\n        return;\n      }\n\n      const deferredSet = new Deferred();\n\n      deferredSet.promise.then((device) => {\n        resolve(device);\n      }).catch(() => {\n        reject();\n      });\n\n      this.sendMsg(\n        MessageType.DEVICE_SET_CREDENTIALS_REQUEST,\n        {\n          deviceId,\n          username,\n          password,\n        },\n        deferredSet\n      );\n    });\n  }\n\n  // The following methods are added to support using the\n  // MockAdapter as a plugin.\n\n  clearState() {\n    if (this.deferredMock) {\n      const err = 'clearState: deferredMock already in progress';\n      console.error(err);\n      return Promise.reject(err);\n    }\n    this.deferredMock = new Deferred();\n    this.sendMsg(\n      MessageType.MOCK_ADAPTER_CLEAR_STATE_REQUEST,\n      {\n        adapterId: this.id,\n      }\n    );\n    return this.deferredMock.promise;\n  }\n\n  addDevice(deviceId, deviceDescription) {\n    if (this.deferredMock) {\n      const err = 'addDevice: deferredMock already in progress';\n      console.error(err);\n      return Promise.reject(err);\n    }\n\n    // For the MockDevice we create the device now, so that we can\n    // deliver the propertyChanged notifications that show up before\n    // the handleDeviceAdded notification comes in. The device we\n    // create now will be replaced when the handleDeviceAdded\n    // notification shows up.\n\n    this.devices[deviceId] = new DeviceProxy(this, deviceDescription);\n\n    this.deferredMock = new Deferred();\n    this.sendMsg(\n      MessageType.MOCK_ADAPTER_ADD_DEVICE_REQUEST,\n      {\n        deviceId: deviceId,\n        deviceDescr: deviceDescription,\n      }\n    );\n    return this.deferredMock.promise;\n  }\n\n  removeDevice(deviceId) {\n    if (this.deferredMock) {\n      const err = 'removeDevice: deferredMock already in progress';\n      console.error(err);\n      return Promise.reject(err);\n    }\n    this.deferredMock = new Deferred();\n\n    // We need the actual device object when we resolve the promise\n    // so we stash it here since it gets removed under our feet.\n    this.deferredMock.device = this.getDevice(deviceId);\n    this.sendMsg(\n      MessageType.MOCK_ADAPTER_REMOVE_DEVICE_REQUEST,\n      {\n        deviceId: deviceId,\n      }\n    );\n    return this.deferredMock.promise;\n  }\n\n  pairDevice(deviceId, deviceDescription) {\n    this.sendMsg(\n      MessageType.MOCK_ADAPTER_PAIR_DEVICE_COMMAND,\n      {\n        deviceId: deviceId,\n        deviceDescr: deviceDescription,\n      }\n    );\n  }\n\n  unpairDevice(deviceId) {\n    this.sendMsg(\n      MessageType.MOCK_ADAPTER_UNPAIR_DEVICE_COMMAND,\n      {\n        deviceId: deviceId,\n      }\n    );\n  }\n}\n\nmodule.exports = AdapterProxy;\n","/**\n * @module APIHandlerProxy base class.\n *\n * Manages API handler data model and business logic.\n */\n/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst {APIHandler} = require('gateway-addon');\nconst Deferred = require('../deferred');\nconst {MessageType} = require('gateway-addon').Constants;\n\n/**\n * Class used to describe an API handler from the perspective of the gateway.\n */\nclass APIHandlerProxy extends APIHandler {\n\n  constructor(addonManager, packageName, plugin) {\n    super(addonManager, packageName);\n    this.plugin = plugin;\n    this.unloadCompletedPromise = null;\n  }\n\n  sendMsg(methodType, data, deferred) {\n    data.packageName = this.packageName;\n    return this.plugin.sendMsg(methodType, data, deferred);\n  }\n\n  handleRequest(request) {\n    return new Promise((resolve, reject) => {\n      const deferred = new Deferred();\n      deferred.promise.then((response) => {\n        resolve(response);\n      }).catch(() => {\n        reject();\n      });\n\n      this.sendMsg(\n        MessageType.API_HANDLER_API_REQUEST,\n        {\n          packageName: this.packageName,\n          request,\n        },\n        deferred\n      );\n    });\n  }\n\n  /**\n   * Unloads the handler.\n   *\n   * @returns a promise which resolves when the handler has finished unloading.\n   */\n  unload() {\n    if (this.unloadCompletedPromise) {\n      console.error('APIHandlerProxy: unload already in progress');\n      return Promise.reject();\n    }\n    this.unloadCompletedPromise = new Deferred();\n    this.sendMsg(MessageType.API_HANDLER_UNLOAD_REQUEST, {});\n    return this.unloadCompletedPromise.promise;\n  }\n}\n\nmodule.exports = APIHandlerProxy;\n","/**\n * DeviceProxy - Gateway side representation of a device when using\n *               an adapter plugin.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Actions = require('../models/actions');\nconst Constants = require('../constants');\nconst {Device, Deferred} = require('gateway-addon');\nconst Event = require('../models/event');\nconst Events = require('../models/events');\nconst {MessageType} = require('gateway-addon').Constants;\nconst PropertyProxy = require('./property-proxy');\n\nclass DeviceProxy extends Device {\n\n  constructor(adapter, deviceDict) {\n    super(adapter, deviceDict.id);\n\n    this.title = deviceDict.title;\n    this['@context'] =\n      deviceDict['@context'] || 'https://iot.mozilla.org/schemas';\n    this['@type'] = deviceDict['@type'] || [];\n    this.description = deviceDict.description || '';\n    this.links = deviceDict.links || [];\n    this.baseHref = deviceDict.baseHref || null;\n\n    if (deviceDict.hasOwnProperty('pin')) {\n      this.pinRequired = deviceDict.pin.required;\n      this.pinPattern = deviceDict.pin.pattern;\n    } else {\n      this.pinRequired = false;\n      this.pinPattern = null;\n    }\n\n    this.credentialsRequired = !!deviceDict.credentialsRequired;\n\n    for (const propertyName in deviceDict.properties) {\n      const propertyDict = deviceDict.properties[propertyName];\n      const propertyProxy =\n        new PropertyProxy(this, propertyName, propertyDict);\n      this.properties.set(propertyName, propertyProxy);\n    }\n\n    // Copy over any extra device fields which might be useful for debugging.\n    this.deviceDict = {};\n    for (const field in deviceDict) {\n      if (['id', 'title', 'description', 'properties', 'actions',\n           'events', '@type', '@context', 'links'].includes(field)) {\n        continue;\n      }\n      this.deviceDict[field] = deviceDict[field];\n    }\n\n    if (deviceDict.actions) {\n      for (const actionName in deviceDict.actions) {\n        const dict = deviceDict.actions[actionName];\n        this.actions.set(actionName, dict);\n      }\n    }\n\n    if (deviceDict.events) {\n      for (const eventName in deviceDict.events) {\n        const dict = deviceDict.events[eventName];\n        this.events.set(eventName, dict);\n      }\n    }\n  }\n\n  asDict() {\n    return Object.assign({}, this.deviceDict, super.asDict());\n  }\n\n  debugCmd(cmd, params) {\n    this.adapter.sendMsg(\n      MessageType.DEVICE_DEBUG_COMMAND,\n      {\n        deviceId: this.id,\n        cmd: cmd,\n        params: params,\n      }\n    );\n  }\n\n  /**\n   * @method requestAction\n   */\n  requestAction(actionId, actionName, input) {\n    return new Promise((resolve, reject) => {\n      if (!this.actions.has(actionName)) {\n        reject(`Action \"${actionName}\" not found`);\n        return;\n      }\n\n      console.log('DeviceProxy: requestAction:', actionName,\n                  'for:', this.id);\n\n      const deferredSet = new Deferred();\n\n      deferredSet.promise.then(() => {\n        resolve();\n      }).catch(() => {\n        reject();\n      });\n\n      this.adapter.sendMsg(\n        MessageType.DEVICE_REQUEST_ACTION_REQUEST,\n        {\n          deviceId: this.id,\n          actionName,\n          actionId,\n          input,\n        },\n        deferredSet\n      );\n    });\n  }\n\n  /**\n   * @method removeAction\n   */\n  removeAction(actionId, actionName) {\n    return new Promise((resolve, reject) => {\n      if (!this.actions.has(actionName)) {\n        reject(`Action \"${actionName}\" not found`);\n        return;\n      }\n\n      console.log('DeviceProxy: removeAction:', actionName,\n                  'for:', this.id);\n\n      const deferredSet = new Deferred();\n\n      deferredSet.promise.then(() => {\n        resolve();\n      }).catch(() => {\n        reject();\n      });\n\n      this.adapter.sendMsg(\n        MessageType.DEVICE_REMOVE_ACTION_REQUEST,\n        {\n          deviceId: this.id,\n          actionName,\n          actionId,\n        },\n        deferredSet\n      );\n    });\n  }\n\n  notifyPropertyChanged(property) {\n    this.adapter.manager.emit(Constants.PROPERTY_CHANGED, property);\n  }\n\n  actionNotify(action) {\n    const a = Actions.get(action.id);\n    if (a) {\n      a.update(action);\n    }\n    this.adapter.manager.emit(Constants.ACTION_STATUS, action);\n  }\n\n  eventNotify(event) {\n    Events.add(new Event(event.name, event.data, this.id, event.timestamp));\n    this.adapter.manager.emit(Constants.EVENT, event);\n  }\n\n  connectedNotify(connected) {\n    this.adapter.manager.emit(Constants.CONNECTED, {device: this, connected});\n  }\n}\n\nmodule.exports = DeviceProxy;\n","/**\n * @module NotifierProxy base class.\n *\n * Manages Notifier data model and business logic.\n */\n/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Deferred = require('../deferred');\nconst {MessageType} = require('gateway-addon').Constants;\nconst {Notifier} = require('gateway-addon');\nconst OutletProxy = require('./outlet-proxy');\n\n/**\n * Class used to describe a notifier from the perspective of the gateway.\n */\nclass NotifierProxy extends Notifier {\n\n  constructor(addonManager, notifierId, name, packageName, plugin) {\n    super(addonManager, notifierId, packageName);\n    this.name = name;\n    this.plugin = plugin;\n    this.unloadCompletedPromise = null;\n  }\n\n  sendMsg(methodType, data, deferred) {\n    data.notifierId = this.id;\n    return this.plugin.sendMsg(methodType, data, deferred);\n  }\n\n  /**\n   * Unloads a notifier.\n   *\n   * @returns a promise which resolves when the notifier has finished unloading.\n   */\n  unload() {\n    if (this.unloadCompletedPromise) {\n      console.error('NotifierProxy: unload already in progress');\n      return Promise.reject();\n    }\n    this.unloadCompletedPromise = new Deferred();\n    this.sendMsg(MessageType.NOTIFIER_UNLOAD_REQUEST, {});\n    return this.unloadCompletedPromise.promise;\n  }\n\n  addOutlet(outletId, outletDescription) {\n    this.outlets[outletId] = new OutletProxy(this, outletDescription);\n  }\n}\n\nmodule.exports = NotifierProxy;\n","/**\n * OutletProxy - Gateway side representation of an outlet when using\n *               a notifier plugin.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst {MessageType} = require('gateway-addon').Constants;\nconst {Outlet, Deferred} = require('gateway-addon');\n\nclass OutletProxy extends Outlet {\n  constructor(notifier, outletDict) {\n    super(notifier, outletDict.id);\n\n    this.name = outletDict.name;\n  }\n\n  notify(title, message, level) {\n    return new Promise((resolve, reject) => {\n      console.log('OutletProxy: notify title:', title, 'message:', message,\n                  'level:', level, 'for:', this.id);\n\n      const deferredSet = new Deferred();\n\n      deferredSet.promise.then(() => {\n        resolve();\n      }).catch(() => {\n        reject();\n      });\n\n      this.notifier.sendMsg(\n        MessageType.OUTLET_NOTIFY_REQUEST,\n        {\n          outletId: this.id,\n          title,\n          message,\n          level,\n        },\n        deferredSet\n      );\n    });\n  }\n}\n\nmodule.exports = OutletProxy;\n","/**\n * @module PluginServer\n *\n * Takes care of the gateway side of adapter plugins. There is\n * only a single instance of the PluginServer for the entire gateway.\n * There will be an AdapterProxy instance for each adapter plugin.\n */\n/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst config = require('config');\nconst EventEmitter = require('events');\nconst {IpcSocket} = require('gateway-addon');\nconst {MessageType} = require('gateway-addon').Constants;\nconst Plugin = require('./plugin');\nconst pkg = require('../../package.json');\nconst Settings = require('../models/settings');\nconst UserProfile = require('../user-profile');\n\nclass PluginServer extends EventEmitter {\n  constructor(addonManager, {verbose} = {}) {\n    super();\n    this.manager = addonManager;\n\n    this.verbose = verbose;\n    this.plugins = new Map();\n\n    this.ipcSocket = new IpcSocket(\n      true,\n      config.get('ports.ipc'),\n      this.onMsg.bind(this),\n      'IpcSocket(plugin-server)',\n      {verbose: this.verbose}\n    );\n    this.verbose &&\n      console.log('Server bound to', this.ipcSocket.ipcAddr);\n  }\n\n  /**\n   * @method addAdapter\n   *\n   * Tells the add-on manager about new adapters added via a plugin.\n   */\n  addAdapter(adapter) {\n    this.manager.addAdapter(adapter);\n  }\n\n  /**\n   * @method addNotifier\n   *\n   * Tells the add-on manager about new notifiers added via a plugin.\n   */\n  addNotifier(notifier) {\n    this.manager.addNotifier(notifier);\n  }\n\n  /**\n   * @method addAPIHandler\n   *\n   * Tells the add-on manager about new API handlers added via a plugin.\n   */\n  addAPIHandler(handler) {\n    this.manager.addAPIHandler(handler);\n  }\n\n  /**\n   * @method onMsg\n   *\n   * Called when the plugin server receives an adapter manager IPC message\n   * from a plugin. This particular IPC channel is only used to register\n   * plugins. Each plugin will get its own IPC channel once its registered.\n   */\n  onMsg(msg, ws) {\n    this.verbose &&\n      console.log('PluginServer: Rcvd:', msg);\n\n    if (msg.messageType === MessageType.PLUGIN_REGISTER_REQUEST) {\n      const plugin = this.registerPlugin(msg.data.pluginId);\n      plugin.ws = ws;\n      let language = 'en-US';\n      const units = {\n        temperature: 'degree celsius',\n      };\n      Settings.get('localization.language').then((lang) => {\n        if (lang) {\n          language = lang;\n        }\n\n        return Settings.get('localization.units.temperature');\n      }).then((temp) => {\n        if (temp) {\n          units.temperature = temp;\n        }\n\n        return Promise.resolve();\n      }).catch(() => {\n        return Promise.resolve();\n      }).then(() => {\n        ws.send(JSON.stringify({\n          messageType: MessageType.PLUGIN_REGISTER_RESPONSE,\n          data: {\n            pluginId: msg.data.pluginId,\n            gatewayVersion: pkg.version,\n            userProfile: {\n              addonsDir: UserProfile.addonsDir,\n              baseDir: UserProfile.baseDir,\n              configDir: UserProfile.configDir,\n              dataDir: UserProfile.dataDir,\n              mediaDir: UserProfile.mediaDir,\n              logDir: UserProfile.logDir,\n              gatewayDir: UserProfile.gatewayDir,\n            },\n            preferences: {\n              language,\n              units,\n            },\n          },\n        }));\n      });\n    } else if (msg.data.pluginId) {\n      const plugin = this.getPlugin(msg.data.pluginId);\n      if (plugin) {\n        plugin.onMsg(msg);\n      }\n    }\n  }\n\n  /**\n   * @method getPlugin\n   *\n   * Returns a previously loaded plugin instance.\n   */\n  getPlugin(pluginId) {\n    return this.plugins.get(pluginId);\n  }\n\n  /**\n   * @method loadPlugin\n   *\n   * Loads a plugin by launching a separate process.\n   */\n  loadPlugin(pluginPath, manifest) {\n    const plugin = this.registerPlugin(manifest.name);\n    plugin.exec = manifest.moziot.exec;\n    plugin.execPath = pluginPath;\n    plugin.start();\n  }\n\n  /**\n   * @method registerPlugin\n   *\n   * Called when the plugin server receives a register plugin message\n   * via IPC.\n   */\n  registerPlugin(pluginId) {\n    let plugin = this.plugins.get(pluginId);\n    if (plugin) {\n      // This is a plugin that we already know about.\n    } else {\n      // We haven't seen this plugin before.\n      plugin = new Plugin(pluginId, this);\n      this.plugins.set(pluginId, plugin);\n    }\n    return plugin;\n  }\n\n  /**\n   * @method unregisterPlugin\n   *\n   * Called when the plugin sends a plugin-unloaded message.\n   */\n  unregisterPlugin(pluginId) {\n    this.plugins.delete(pluginId);\n  }\n\n  shutdown() {\n    this.ipcSocket.close();\n  }\n}\n\nmodule.exports = PluginServer;\n","/**\n * @module Plugin\n *\n * Object created for each plugin that the gateway talks to.\n */\n/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst AdapterProxy = require('./adapter-proxy');\nconst APIHandlerProxy = require('./api-handler-proxy');\nconst Constants = require('../constants');\nconst db = require('../db');\nconst Deferred = require('../deferred');\nconst DeviceProxy = require('./device-proxy');\nconst format = require('string-format');\nconst {LogSeverity} = require('../constants');\nconst NotifierProxy = require('./notifier-proxy');\nconst OutletProxy = require('./outlet-proxy');\nconst path = require('path');\nconst readline = require('readline');\nconst Settings = require('../models/settings');\nconst spawn = require('child_process').spawn;\nconst Things = require('../models/things');\nconst UserProfile = require('../user-profile');\nconst {\n  DONT_RESTART_EXIT_CODE,\n  MessageType,\n} = require('gateway-addon').Constants;\n\nconst DEBUG = false;\n\ndb.open();\n\nclass Plugin {\n\n  constructor(pluginId, pluginServer, forceEnable = false) {\n    this.pluginId = pluginId;\n    this.pluginServer = pluginServer;\n    this.logPrefix = pluginId;\n\n    this.adapters = new Map();\n    this.notifiers = new Map();\n    this.apiHandlers = new Map();\n\n    this.exec = '';\n    this.execPath = '.';\n    this.forceEnable = forceEnable;\n    this.startPromise = null;\n\n    // Make this a nested object such that if the Plugin object is reused,\n    // i.e. the plugin is disabled and quickly re-enabled, the gateway process\n    // can maintain a proper reference to the process object.\n    this.process = {p: null};\n\n    this.restart = true;\n    this.restartDelay = 0;\n    this.lastRestart = 0;\n    this.pendingRestart = null;\n    this.unloadCompletedPromise = null;\n    this.unloadedRcvdPromise = null;\n\n    this.nextId = 0;\n    this.requestActionPromises = new Map();\n    this.removeActionPromises = new Map();\n    this.setPinPromises = new Map();\n    this.setCredentialsPromises = new Map();\n    this.notifyPromises = new Map();\n    this.apiRequestPromises = new Map();\n  }\n\n  asDict() {\n    let pid = 'not running';\n    if (this.process.p) {\n      pid = this.process.p.pid;\n    }\n    return {\n      pluginId: this.pluginId,\n      adapters: Array.from(this.adapters.values()).map((adapter) => {\n        return adapter.asDict();\n      }),\n      notifiers: Array.from(this.notifiers.values()).map((notifier) => {\n        return notifier.asDict();\n      }),\n      exec: this.exec,\n      pid,\n    };\n  }\n\n  onMsg(msg) {\n    DEBUG && console.log('Plugin: Rcvd Msg', msg);\n\n    // The first switch manages action method resolved or rejected messages.\n    switch (msg.messageType) {\n      case MessageType.DEVICE_REQUEST_ACTION_RESPONSE: {\n        const actionId = msg.data.actionId;\n        const deferred = this.requestActionPromises.get(actionId);\n        if (typeof actionId === 'undefined' ||\n            typeof deferred === 'undefined') {\n          console.error('Plugin:', this.pluginId,\n                        'Unrecognized action id:', actionId,\n                        'Ignoring msg:', msg);\n          return;\n        }\n\n        if (msg.data.success) {\n          deferred.resolve();\n        } else {\n          deferred.reject();\n        }\n\n        this.requestActionPromises.delete(actionId);\n        return;\n      }\n      case MessageType.DEVICE_REMOVE_ACTION_RESPONSE: {\n        const messageId = msg.data.messageId;\n        const deferred = this.removeActionPromises.get(messageId);\n        if (typeof messageId === 'undefined' ||\n            typeof deferred === 'undefined') {\n          console.error('Plugin:', this.pluginId,\n                        'Unrecognized message id:', messageId,\n                        'Ignoring msg:', msg);\n          return;\n        }\n\n        if (msg.data.success) {\n          deferred.resolve();\n        } else {\n          deferred.reject();\n        }\n\n        this.removeActionPromises.delete(messageId);\n        return;\n      }\n      case MessageType.OUTLET_NOTIFY_RESPONSE: {\n        const messageId = msg.data.messageId;\n        const deferred = this.notifyPromises.get(messageId);\n        if (typeof messageId === 'undefined' ||\n            typeof deferred === 'undefined') {\n          console.error('Plugin:', this.pluginId,\n                        'Unrecognized message id:', messageId,\n                        'Ignoring msg:', msg);\n          return;\n        }\n\n        if (msg.data.success) {\n          deferred.resolve();\n        } else {\n          deferred.reject();\n        }\n\n        this.notifyPromises.delete(messageId);\n        return;\n      }\n      case MessageType.DEVICE_SET_PIN_RESPONSE: {\n        const messageId = msg.data.messageId;\n        const deferred = this.setPinPromises.get(messageId);\n        if (typeof messageId === 'undefined' ||\n            typeof deferred === 'undefined') {\n          console.error('Plugin:', this.pluginId,\n                        'Unrecognized message id:', messageId,\n                        'Ignoring msg:', msg);\n          return;\n        }\n\n        if (msg.data.success) {\n          const adapter = this.adapters.get(msg.data.adapterId);\n          const deviceId = msg.data.device.id;\n          const device = new DeviceProxy(adapter, msg.data.device);\n          adapter.devices[deviceId] = device;\n          adapter.manager.devices[deviceId] = device;\n          deferred.resolve(msg.data.device);\n        } else {\n          deferred.reject();\n        }\n\n        this.setPinPromises.delete(messageId);\n        return;\n      }\n      case MessageType.DEVICE_SET_CREDENTIALS_RESPONSE: {\n        const messageId = msg.data.messageId;\n        const deferred = this.setCredentialsPromises.get(messageId);\n        if (typeof messageId === 'undefined' ||\n            typeof deferred === 'undefined') {\n          console.error('Plugin:', this.pluginId,\n                        'Unrecognized message id:', messageId,\n                        'Ignoring msg:', msg);\n          return;\n        }\n\n        if (msg.data.success) {\n          const adapter = this.adapters.get(msg.data.adapterId);\n          const deviceId = msg.data.device.id;\n          const device = new DeviceProxy(adapter, msg.data.device);\n          adapter.devices[deviceId] = device;\n          adapter.manager.devices[deviceId] = device;\n          deferred.resolve(msg.data.device);\n        } else {\n          deferred.reject();\n        }\n\n        this.setCredentialsPromises.delete(messageId);\n        return;\n      }\n      case MessageType.API_HANDLER_API_RESPONSE: {\n        const messageId = msg.data.messageId;\n        const deferred = this.apiRequestPromises.get(messageId);\n        if (typeof messageId === 'undefined' ||\n            typeof deferred === 'undefined') {\n          console.error('Plugin:', this.pluginId,\n                        'Unrecognized message id:', messageId,\n                        'Ignoring msg:', msg);\n          return;\n        }\n        deferred.resolve(msg.data.response);\n        this.apiRequestPromises.delete(messageId);\n        return;\n      }\n    }\n\n    const adapterId = msg.data.adapterId;\n    const notifierId = msg.data.notifierId;\n    let adapter, notifier, apiHandler;\n\n    // The second switch manages plugin level messages.\n    switch (msg.messageType) {\n      case MessageType.ADAPTER_ADDED_NOTIFICATION: {\n        adapter = new AdapterProxy(this.pluginServer.manager,\n                                   adapterId,\n                                   msg.data.name,\n                                   msg.data.packageName,\n                                   this);\n        this.adapters.set(adapterId, adapter);\n        this.pluginServer.addAdapter(adapter);\n\n        // Tell the adapter about all saved things\n        const send = (thing) => {\n          adapter.sendMsg(\n            MessageType.DEVICE_SAVED_NOTIFICATION,\n            {\n              deviceId: thing.id,\n              device: thing.getDescription(),\n            }\n          );\n        };\n\n        adapter.eventHandlers[Constants.THING_ADDED] = send;\n\n        Things.getThings().then((things) => {\n          things.forEach(send);\n        });\n        Things.on(Constants.THING_ADDED, send);\n        return;\n      }\n      case MessageType.NOTIFIER_ADDED_NOTIFICATION:\n        notifier = new NotifierProxy(this.pluginServer.manager,\n                                     notifierId,\n                                     msg.data.name,\n                                     msg.data.packageName,\n                                     this);\n        this.notifiers.set(notifierId, notifier);\n        this.pluginServer.addNotifier(notifier);\n        return;\n\n      case MessageType.API_HANDLER_ADDED_NOTIFICATION:\n        apiHandler = new APIHandlerProxy(this.pluginServer.manager,\n                                         msg.data.packageName,\n                                         this);\n        this.apiHandlers.set(msg.data.packageName, apiHandler);\n        this.pluginServer.addAPIHandler(apiHandler);\n        return;\n\n      case MessageType.API_HANDLER_UNLOAD_RESPONSE: {\n        const packageName = msg.data.packageName;\n        const handler = this.apiHandlers.get(packageName);\n\n        if (!handler) {\n          console.error('Plugin:', this.pluginId,\n                        'Unrecognized API handler:', packageName,\n                        'Ignoring msg:', msg);\n          return;\n        }\n\n        this.apiHandlers.delete(packageName);\n        if (this.adapters.size === 0 &&\n            this.notifiers.size === 0 &&\n            this.apiHandlers.size === 0) {\n          // We've unloaded everything for the plugin, now unload the plugin.\n          this.unload();\n          this.unloadCompletedPromise = handler.unloadCompletedPromise;\n          handler.unloadCompletedPromise = null;\n        } else if (handler.unloadCompletedPromise) {\n          handler.unloadCompletedPromise.resolve();\n          handler.unloadCompletedPromise = null;\n        }\n\n        return;\n      }\n      case MessageType.PLUGIN_UNLOAD_RESPONSE:\n        this.shutdown();\n        this.pluginServer.unregisterPlugin(msg.data.pluginId);\n        if (this.unloadedRcvdPromise) {\n          if (this.unloadCompletedPromise) {\n            this.unloadCompletedPromise.resolve();\n            this.unloadCompletedPromise = null;\n          }\n        }\n        return;\n\n      case MessageType.PLUGIN_ERROR_NOTIFICATION:\n        this.pluginServer.emit('log', {\n          severity: LogSeverity.ERROR,\n          message: msg.data.message,\n        });\n        return;\n    }\n\n    // The next switch deals with adapter level messages\n\n    adapter = this.adapters.get(adapterId);\n    if (adapterId && !adapter) {\n      console.error('Plugin:', this.pluginId,\n                    'Unrecognized adapter:', adapterId,\n                    'Ignoring msg:', msg);\n      return;\n    }\n\n    notifier = this.notifiers.get(notifierId);\n    if (notifierId && !notifier) {\n      console.error('Plugin:', this.pluginId,\n                    'Unrecognized notifier:', notifierId,\n                    'Ignoring msg:', msg);\n      return;\n    }\n\n    let device;\n    let outlet;\n    let property;\n    let deferredMock;\n\n    switch (msg.messageType) {\n\n      case MessageType.ADAPTER_UNLOAD_RESPONSE: {\n        const handler = adapter.eventHandlers[Constants.THING_ADDED];\n        if (handler) {\n          Things.removeListener(Constants.THING_ADDED, handler);\n        }\n\n        this.adapters.delete(adapterId);\n        if (this.adapters.size === 0 &&\n            this.notifiers.size === 0 &&\n            this.apiHandlers.size === 0) {\n          // We've unloaded everything for the plugin, now unload the plugin.\n\n          // We may need to reevaluate this, and only auto-unload\n          // the plugin for the MockAdapter. For plugins which\n          // support hot-swappable dongles (like zwave/zigbee) it makes\n          // sense to have a plugin loaded with no adapters present.\n          this.unload();\n          this.unloadCompletedPromise = adapter.unloadCompletedPromise;\n          adapter.unloadCompletedPromise = null;\n        } else if (adapter.unloadCompletedPromise) {\n          adapter.unloadCompletedPromise.resolve();\n          adapter.unloadCompletedPromise = null;\n        }\n        break;\n      }\n      case MessageType.NOTIFIER_UNLOAD_RESPONSE:\n        this.notifiers.delete(notifierId);\n        if (this.adapters.size === 0 &&\n            this.notifiers.size === 0 &&\n            this.apiHandlers.size === 0) {\n          // We've unloaded everything for the plugin, now unload the plugin.\n          this.unload();\n          this.unloadCompletedPromise = notifier.unloadCompletedPromise;\n          notifier.unloadCompletedPromise = null;\n        } else if (notifier.unloadCompletedPromise) {\n          notifier.unloadCompletedPromise.resolve();\n          notifier.unloadCompletedPromise = null;\n        }\n        break;\n\n      case MessageType.DEVICE_ADDED_NOTIFICATION:\n        device = new DeviceProxy(adapter, msg.data.device);\n        adapter.handleDeviceAdded(device);\n        break;\n\n      case MessageType.ADAPTER_REMOVE_DEVICE_RESPONSE:\n        device = adapter.getDevice(msg.data.deviceId);\n        if (device) {\n          adapter.handleDeviceRemoved(device);\n        }\n        break;\n\n      case MessageType.OUTLET_ADDED_NOTIFICATION:\n        outlet = new OutletProxy(notifier, msg.data.outlet);\n        notifier.handleOutletAdded(outlet);\n        break;\n\n      case MessageType.OUTLET_REMOVED_NOTIFICATION:\n        outlet = notifier.getOutlet(msg.data.outletId);\n        if (outlet) {\n          notifier.handleOutletRemoved(outlet);\n        }\n        break;\n\n      case MessageType.DEVICE_PROPERTY_CHANGED_NOTIFICATION:\n        device = adapter.getDevice(msg.data.deviceId);\n        if (device) {\n          property = device.findProperty(msg.data.property.name);\n          if (property) {\n            property.doPropertyChanged(msg.data.property);\n            if (property.isVisible()) {\n              device.notifyPropertyChanged(property);\n            }\n          }\n        }\n        break;\n\n      case MessageType.DEVICE_ACTION_STATUS_NOTIFICATION:\n        device = adapter.getDevice(msg.data.deviceId);\n        if (device) {\n          device.actionNotify(msg.data.action);\n        }\n        break;\n\n      case MessageType.DEVICE_EVENT_NOTIFICATION:\n        device = adapter.getDevice(msg.data.deviceId);\n        if (device) {\n          device.eventNotify(msg.data.event);\n        }\n        break;\n\n      case MessageType.DEVICE_CONNECTED_STATE_NOTIFICATION:\n        device = adapter.getDevice(msg.data.deviceId);\n        if (device) {\n          device.connectedNotify(msg.data.connected);\n        }\n        break;\n\n      case MessageType.ADAPTER_PAIRING_PROMPT_NOTIFICATION: {\n        let message = `${adapter.name}: `;\n        if (msg.data.hasOwnProperty('deviceId')) {\n          device = adapter.getDevice(msg.data.deviceId);\n          message += `(${device.title}): `;\n        }\n\n        message += msg.data.prompt;\n\n        const data = {\n          severity: LogSeverity.PROMPT,\n          message,\n        };\n\n        if (msg.data.hasOwnProperty('url')) {\n          data.url = msg.data.url;\n        }\n\n        this.pluginServer.emit('log', data);\n        return;\n      }\n      case MessageType.ADAPTER_UNPAIRING_PROMPT_NOTIFICATION: {\n        let message = `${adapter.name}`;\n        if (msg.data.hasOwnProperty('deviceId')) {\n          device = adapter.getDevice(msg.data.deviceId);\n          message += ` (${device.title})`;\n        }\n\n        message += `: ${msg.data.prompt}`;\n\n        const data = {\n          severity: LogSeverity.PROMPT,\n          message,\n        };\n\n        if (msg.data.hasOwnProperty('url')) {\n          data.url = msg.data.url;\n        }\n\n        this.pluginServer.emit('log', data);\n        return;\n      }\n      case MessageType.MOCK_ADAPTER_CLEAR_STATE_RESPONSE:\n        deferredMock = adapter.deferredMock;\n        if (!deferredMock) {\n          console.error('mockAdapterStateCleared: No deferredMock');\n        } else {\n          adapter.deferredMock = null;\n          deferredMock.resolve();\n        }\n        break;\n\n      case MessageType.MOCK_ADAPTER_ADD_DEVICE_RESPONSE:\n      case MessageType.MOCK_ADAPTER_REMOVE_DEVICE_RESPONSE:\n        deferredMock = adapter.deferredMock;\n        if (!deferredMock) {\n          console.error('mockDeviceAddedRemoved: No deferredMock');\n        } else if (msg.data.success) {\n          device = deferredMock.device;\n          adapter.deferredMock = null;\n          deferredMock.device = null;\n          deferredMock.resolve(device);\n        } else {\n          adapter.deferredMock = null;\n          deferredMock.reject(msg.data.error);\n        }\n        break;\n\n      default:\n        console.error('Plugin: unrecognized msg:', msg);\n        break;\n    }\n  }\n\n  /**\n   * Generate an ID for a message.\n   *\n   * @returns {integer} An id.\n   */\n  generateMsgId() {\n    return ++this.nextId;\n  }\n\n  sendMsg(methodType, data, deferred) {\n    data.pluginId = this.pluginId;\n\n    // Methods which could fail should await result.\n    if (typeof deferred !== 'undefined') {\n      switch (methodType) {\n        case MessageType.DEVICE_REQUEST_ACTION_REQUEST: {\n          this.requestActionPromises.set(data.actionId, deferred);\n          break;\n        }\n        case MessageType.DEVICE_REMOVE_ACTION_REQUEST: {\n          // removeAction needs ID which is per message, because it\n          // can be called while waiting rejected or resolved.\n          data.messageId = this.generateMsgId();\n          this.removeActionPromises.set(data.messageId, deferred);\n          break;\n        }\n        case MessageType.OUTLET_NOTIFY_REQUEST: {\n          data.messageId = this.generateMsgId();\n          this.notifyPromises.set(data.messageId, deferred);\n          break;\n        }\n        case MessageType.DEVICE_SET_PIN_REQUEST: {\n          // removeAction needs ID which is per message, because it\n          // can be called while waiting rejected or resolved.\n          data.messageId = this.generateMsgId();\n          this.setPinPromises.set(data.messageId, deferred);\n          break;\n        }\n        case MessageType.DEVICE_SET_CREDENTIALS_REQUEST: {\n          // removeAction needs ID which is per message, because it\n          // can be called while waiting rejected or resolved.\n          data.messageId = this.generateMsgId();\n          this.setCredentialsPromises.set(data.messageId, deferred);\n          break;\n        }\n        case MessageType.API_HANDLER_API_REQUEST: {\n          data.messageId = this.generateMsgId();\n          this.apiRequestPromises.set(data.messageId, deferred);\n          break;\n        }\n        default:\n          break;\n      }\n    }\n\n    const msg = {\n      messageType: methodType,\n      data: data,\n    };\n    DEBUG && console.log('Plugin: sendMsg:', msg);\n\n    return this.ws.send(JSON.stringify(msg));\n  }\n\n  /**\n   * Does cleanup required to allow the test suite to complete cleanly.\n   */\n  shutdown() {\n    if (this.pendingRestart) {\n      clearTimeout(this.pendingRestart);\n    }\n    this.restart = false;\n    this.requestActionPromises.forEach((promise, key) => {\n      promise.reject();\n      this.requestActionPromises.delete(key);\n    });\n    this.removeActionPromises.forEach((promise, key) => {\n      promise.reject();\n      this.removeActionPromises.delete(key);\n    });\n    this.setPinPromises.forEach((promise, key) => {\n      promise.reject();\n      this.setPinPromises.delete(key);\n    });\n    this.setCredentialsPromises.forEach((promise, key) => {\n      promise.reject();\n      this.setCredentialsPromises.delete(key);\n    });\n    this.notifyPromises.forEach((promise, key) => {\n      promise.reject();\n      this.notifyPromises.delete(key);\n    });\n    this.apiRequestPromises.forEach((promise, key) => {\n      promise.reject();\n      this.apiRequestPromises.delete(key);\n    });\n  }\n\n  start() {\n    const key = `addons.${this.pluginId}`;\n\n    this.startPromise = Settings.get(key).then((savedSettings) => {\n      if (!this.forceEnable &&\n          (!savedSettings || !savedSettings.enabled)) {\n        console.error(`Plugin ${this.pluginId} not enabled, so not starting.`);\n        this.restart = false;\n        this.process.p = null;\n        return;\n      }\n\n      const execArgs = {\n        nodeLoader: `node ${path.join(UserProfile.gatewayDir,\n                                      'src',\n                                      'addon-loader.js')}`,\n        name: this.pluginId,\n        path: this.execPath,\n      };\n      const execCmd = format(this.exec, execArgs);\n\n      DEBUG && console.log('  Launching:', execCmd);\n\n      // If we need embedded spaces, then consider changing to use the npm\n      // module called splitargs\n      this.restart = true;\n      const args = execCmd.split(' ');\n      this.process.p = spawn(\n        args[0],\n        args.slice(1),\n        {\n          env: Object.assign(process.env,\n                             {\n                               MOZIOT_HOME: UserProfile.baseDir,\n                               NODE_PATH: path.join(UserProfile.gatewayDir,\n                                                    'node_modules'),\n                             }),\n        }\n      );\n\n      this.process.p.on('error', (err) => {\n        // We failed to spawn the process. This most likely means that the\n        // exec string is malformed somehow. Report the error but don't try\n        // restarting.\n        this.restart = false;\n        console.error('Failed to start plugin', this.pluginId);\n        console.error('Command:', this.exec);\n        console.error(err);\n      });\n\n      this.stdoutReadline = readline.createInterface({\n        input: this.process.p.stdout,\n      });\n      this.stdoutReadline.on('line', (line) => {\n        console.log(`${this.logPrefix}: ${line}`);\n      });\n\n      this.stderrReadline = readline.createInterface({\n        input: this.process.p.stderr,\n      });\n      this.stderrReadline.on('line', (line) => {\n        console.error(`${this.logPrefix}: ${line}`);\n      });\n\n      this.process.p.on('exit', (code) => {\n        if (this.restart) {\n          if (code == DONT_RESTART_EXIT_CODE) {\n            console.log('Plugin:', this.pluginId, 'died, code =', code,\n                        'NOT restarting...');\n            this.restart = false;\n            this.process.p = null;\n          } else {\n            if (this.pendingRestart) {\n              return;\n            }\n            if (this.restartDelay < 30 * 1000) {\n              this.restartDelay += 1000;\n            }\n            if (this.lastRestart + 60 * 1000 < Date.now()) {\n              this.restartDelay = 0;\n            }\n            if (this.restartDelay > 30000) {\n              // If we've restarted 30 times in a row, this is probably just\n              // not going to work, so bail out.\n              console.log(`Giving up on restarting plugin ${this.pluginId}`);\n              this.restart = false;\n              this.process.p = null;\n              return;\n            }\n            console.log('Plugin:', this.pluginId, 'died, code =', code,\n                        'restarting after', this.restartDelay);\n            const doRestart = () => {\n              if (this.restart) {\n                this.lastRestart = Date.now();\n                this.pendingRestart = null;\n                this.start();\n              } else {\n                this.process.p = null;\n              }\n            };\n            if (this.restartDelay > 0) {\n              this.pendingRestart = setTimeout(doRestart, this.restartDelay);\n            } else {\n              // Restart immediately so that test code can access\n              // process.p\n              doRestart();\n            }\n          }\n        } else {\n          this.process.p = null;\n        }\n      });\n    });\n\n    return this.startPromise;\n  }\n\n  unload() {\n    this.restart = false;\n    this.unloadedRcvdPromise = new Deferred();\n    this.sendMsg(MessageType.PLUGIN_UNLOAD_REQUEST, {});\n  }\n}\n\nmodule.exports = Plugin;\n","/**\n * PropertyProxy - Gateway side representation of a property\n *                 when using an adapter plugin.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Deferred = require('../deferred');\nconst {Property} = require('gateway-addon');\nconst {MessageType} = require('gateway-addon').Constants;\n\nclass PropertyProxy extends Property {\n  constructor(device, propertyName, propertyDict) {\n    super(device, propertyName, propertyDict);\n\n    this.value = propertyDict.value;\n\n    this.propertyChangedPromises = [];\n    this.propertyDict = Object.assign({}, propertyDict);\n  }\n\n  asDict() {\n    return Object.assign({}, this.propertyDict, super.asDict());\n  }\n\n  /**\n   * @method onPropertyChanged\n   * @returns a promise which is resoved when the next\n   * propertyChanged notification is received.\n   */\n  onPropertyChanged() {\n    const deferredChange = new Deferred();\n    this.propertyChangedPromises.push(deferredChange);\n    return deferredChange.promise;\n  }\n\n  /**\n   * @method doPropertyChanged\n   * Called whenever a property changed notification is received\n   * from the adapter.\n   */\n  doPropertyChanged(propertyDict) {\n    this.propertyDict = Object.assign({}, propertyDict);\n    this.setCachedValue(propertyDict.value);\n    if (propertyDict.hasOwnProperty('title')) {\n      this.title = propertyDict.title;\n    }\n    if (propertyDict.hasOwnProperty('type')) {\n      this.type = propertyDict.type;\n    }\n    if (propertyDict.hasOwnProperty('@type')) {\n      this['@type'] = propertyDict['@type'];\n    }\n    if (propertyDict.hasOwnProperty('unit')) {\n      this.unit = propertyDict.unit;\n    }\n    if (propertyDict.hasOwnProperty('description')) {\n      this.description = propertyDict.description;\n    }\n    if (propertyDict.hasOwnProperty('minimum')) {\n      this.minimum = propertyDict.minimum;\n    }\n    if (propertyDict.hasOwnProperty('maximum')) {\n      this.maximum = propertyDict.maximum;\n    }\n    if (propertyDict.hasOwnProperty('multipleOf')) {\n      this.multipleOf = propertyDict.multipleOf;\n    }\n    if (propertyDict.hasOwnProperty('enum')) {\n      this.enum = propertyDict.enum;\n    }\n    if (propertyDict.hasOwnProperty('links')) {\n      this.links = propertyDict.links;\n    }\n    while (this.propertyChangedPromises.length > 0) {\n      const deferredChange = this.propertyChangedPromises.pop();\n      deferredChange.resolve(propertyDict.value);\n    }\n  }\n\n  /**\n   * @returns a promise which resolves to the updated value.\n   *\n   * @note it is possible that the updated value doesn't match\n   * the value passed in.\n   */\n  setValue(value) {\n    return new Promise((resolve, reject) => {\n      this.device.adapter.sendMsg(\n        MessageType.DEVICE_SET_PROPERTY_COMMAND,\n        {\n          deviceId: this.device.id,\n          propertyName: this.name,\n          propertyValue: value,\n        }\n      );\n\n      // TODO: Add a timeout\n\n      this.onPropertyChanged().then((updatedValue) => {\n        resolve(updatedValue);\n      }).catch((error) => {\n        console.error('PropertyProxy: Failed to setProperty',\n                      this.name, 'to', value,\n                      'for device:', this.device.id);\n        console.error(error);\n        reject(error);\n      });\n    });\n  }\n}\n\nmodule.exports = PropertyProxy;\n","/**\n * Push Service.\n *\n * Manage the Push Service for notifications\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst WebPush = require('web-push');\nconst Settings = require('./models/settings');\nconst Database = require('./db');\n\nconst PushService = {\n\n  enabled: false,\n  /**\n   * Initialize the Push Service, generating and storing a VAPID keypair\n   * if necessary.\n   */\n  init: async (tunnelDomain) => {\n    let vapid = await Settings.get('push.vapid');\n    if (!vapid) {\n      vapid = WebPush.generateVAPIDKeys();\n      await Settings.set('push.vapid', vapid);\n    }\n    const {publicKey, privateKey} = vapid;\n\n    WebPush.setVapidDetails(tunnelDomain, publicKey, privateKey);\n\n    this.enabled = true;\n  },\n\n  getVAPIDKeys: async () => {\n    try {\n      const vapid = await Settings.get('push.vapid');\n      return vapid;\n    } catch (err) {\n      // do nothing\n      console.error('vapid still not generated');\n    }\n  },\n\n  createPushSubscription: async (subscription) => {\n    return await Database.createPushSubscription(subscription);\n  },\n\n  broadcastNotification: async (message) => {\n    if (!this.enabled) {\n      return;\n    }\n    const subscriptions = await Database.getPushSubscriptions();\n    for (const subscription of subscriptions) {\n      WebPush.sendNotification(subscription, message).catch((err) => {\n        console.warn('Push API error', err);\n        Database.deletePushSubscription(subscription.id);\n      });\n    }\n  },\n};\n\nmodule.exports = PushService;\n","'use strict';\n\nconst bodyParser = require('body-parser');\nconst config = require('config');\nconst Constants = require('./constants');\nconst express = require('express');\nconst expressHandlebars = require('express-handlebars');\nconst mDNSserver = require('./mdns-server');\nconst platform = require('./platform');\nconst Settings = require('./models/settings');\nconst sleep = require('./sleep');\n\nconst DEBUG = false;\n\nconst hbs = expressHandlebars.create({\n  helpers: {\n    escapeQuotes: (str) => `${str}`.replace(/'/, '\\\\\\''),\n  },\n  defaultLayout: undefined, // eslint-disable-line no-undefined\n  layoutsDir: Constants.VIEWS_PATH,\n});\n\n// The express server\nconst app = express();\napp.engine('handlebars', hbs.engine);\napp.set('view engine', 'handlebars');\napp.set('views', Constants.VIEWS_PATH);\n\n// When we get POSTs, handle the body like this\napp.use(bodyParser.urlencoded({extended: false}));\n\n// Define the handler methods for the various URLs we handle\napp.get('/*', handleCaptive);\napp.get('/', handleRoot);\napp.get('/router-setup', handleRouterSetup);\napp.post('/creating', handleCreating);\napp.use(express.static(Constants.BUILD_STATIC_PATH));\n\nconst RouterSetupApp = {\n  onRequest: app,\n};\n\n/**\n * Handle captive portal requests.\n */\nfunction handleCaptive(request, response, next) {\n  console.log('router-setup: handleCaptive:', request.path);\n\n  switch (request.path) {\n    case '/hotspot.html': {\n      // WISPr XML response\n      const ssid = getHotspotSsid();\n      response.render(\n        'hotspot',\n        {\n          ap_ssid: ssid,\n          ap_ip: config.get('wifi.ap.ipaddr'),\n        }\n      );\n      break;\n    }\n    case '/hotspot-detect.html':        // iOS/macOS\n    case '/library/test/success.html':  // iOS/macOS\n    case '/connecttest.txt': {          // Windows\n      const ua = request.get('User-Agent');\n\n      // These 2 user-agents expect a WISPr XML response\n      if (ua.includes('CaptiveNetworkSupport') ||\n          ua.includes('Microsoft NCSI')) {\n        response.redirect(\n          302,\n          `http://${config.get('wifi.ap.ipaddr')}/hotspot.html`\n        );\n        break;\n      }\n\n      // otherwise, fall through\n    }\n    // eslint-disable-next-line no-fallthrough\n    case '/kindle-wifi/wifistub.html':  // Kindle\n    case '/generate_204':               // Android, Chrome\n    case '/fwlink/':                    // Windows\n    case '/redirect':                   // Windows\n    case '/success.txt':                // Firefox\n      // Redirect to the router setup page\n      response.redirect(\n        302,\n        `http://${config.get('wifi.ap.ipaddr')}/router-setup`\n      );\n      break;\n    default:\n      console.log('router-setup: handleCaptive: unknown path, skipping.');\n      next();\n      break;\n  }\n}\n\n/**\n * Handle requests to the root URL. We display a different page depending on\n * what stage of setup we're at.\n */\nfunction handleRoot(request, response) {\n  // We don't have the router configured yet, display the router setup page\n  console.log(\n    'router-setup: handleRoot: router unconfigured; redirecting to ' +\n    'router-setup'\n  );\n  response.redirect('/router-setup');\n}\n\n/**\n * Handle requests to /router-setup.\n */\nfunction handleRouterSetup(request, response) {\n  DEBUG && console.log('router-setup: handleRouterSetup:', request.path);\n  const ssid = getHotspotSsid();\n  response.render('router-setup', {ssid});\n}\n\n/**\n * Handle requests to /creating.\n */\nfunction handleCreating(request, response) {\n  DEBUG && console.log('router-setup: handleCreating:', request.path);\n  mDNSserver.getmDNSdomain().then((domain) => {\n    const ssid = request.body.ssid.trim();\n    const password = request.body.password.trim();\n\n    if (ssid.length < 1 || ssid.length > 32 || password.length < 8) {\n      response.status(400).send('Invalid parameters.');\n      return;\n    }\n\n    response.render(\n      'creating',\n      {\n        domain,\n        ap_ip: config.get('wifi.ap.ipaddr'),\n        ap_ssid: ssid,\n      }\n    );\n\n    // Wait before switching networks to make sure the response gets through.\n    // And also wait to be sure that the access point is fully down before\n    // defining the new network.\n    sleep(2000)\n      .then(() => {\n        stopCaptivePortal();\n        return sleep(5000);\n      })\n      .then(() => {\n        return defineNetwork(ssid, password);\n      })\n      .then((success) => {\n        if (!success) {\n          console.error(\n            'router-setup: handleCreating: failed to define network'\n          );\n        } else {\n          return waitForWiFi(20, 3000).then(() => {\n            DEBUG && console.log('router-setup: setup complete');\n            RouterSetupApp.onConnection();\n          });\n        }\n      })\n      .catch((error) => {\n        if (error) {\n          console.error('router-setup: handleCreating: general error:', error);\n        }\n      });\n  });\n}\n\n/**\n * Get the SSID of the hotspot.\n *\n * @returns {string} SSID\n */\nfunction getHotspotSsid() {\n  const base = config.get('wifi.ap.ssid_base');\n  const mac = platform.getMacAddress('wlan0');\n  if (!mac) {\n    DEBUG && console.log('router-setup: getHotSpotSsid: returning', base);\n    return base;\n  }\n\n  // Get the last 2 octets of the MAC and create a simple string, e.g. 9E28\n  const id = mac.split(':').slice(4).join('').toUpperCase();\n\n  DEBUG && console.log('router-setup: getHotSpotSsid: returning', `${base} ${id}`);\n  return `${base} ${id}`;\n}\n\n/**\n * Enable an access point that users can connect to to configure the device.\n *\n * This requires that hostapd and udhcpd are installed on the system but not\n * enabled, so that they do not automatically run when the device boots up.\n * This also requires that hostapd and udhcpd have appropriate config files\n * that define the SSID for the wifi network to be created, for example.\n * Also, the udhcpd config file should be set up to work with the IP address\n * of the device.\n *\n * @param {string} ipaddr - IP address of AP\n * @returns {boolean} Boolean indicating success of the command.\n */\nfunction startCaptivePortal(ipaddr) {\n  console.log('router-setup: startCaptivePortal: ipaddr:', ipaddr);\n  const ssid = getHotspotSsid();\n\n  // Set the WAN mode to be DHCP. By doing this here, it allows us to get\n  // an IP address and allows NTP to set the time by the time we get to\n  // registering the tunnel.\n\n  const wanMode = platform.getWanMode();\n  if (wanMode.mode != 'dhcp') {\n    platform.setWanMode('dhcp');\n  }\n\n  // We need the LAN to be configured to have a static IP address,\n  // and run dnsmasq (DHCP server and DNS server).\n\n  const ifname = null;\n  const netmask = '255.255.255.0';\n\n  if (!platform.setLanMode('static', {ipaddr, ifname, netmask})) {\n    console.error('router-setup: startCaptivePortal: setLanMode failed');\n    return false;\n  }\n  if (!platform.setCaptivePortalStatus(true, {ipaddr, restart: false})) {\n    console.error('router-setup: startCaptivePortal:',\n                  'setCaptivePortalStatus failed');\n    return false;\n  }\n  if (!platform.setDhcpServerStatus(true, {ipaddr})) {\n    console.error('router-setup: startCaptivePortal:',\n                  'setDhcpServerStatus failed');\n    return false;\n  }\n  const encryption = 'none';\n  if (!platform.setWirelessMode(true, 'ap', {ssid, encryption})) {\n    console.error('router-setup: startCaptivePortal: setWirelessMode failed');\n    return false;\n  }\n  return true;\n}\n\n/**\n * Stop the running access point.\n *\n * @returns {boolean} Boolean indicating success of the command.\n */\nfunction stopCaptivePortal() {\n  console.log('router-setup: stopCaptivePortal');\n  let result = platform.setCaptivePortalStatus(false, {restart: true});\n  result &= platform.setWirelessMode(false, 'ap');\n  return result;\n}\n\n/**\n * Define a new network.\n *\n * @param {string} ssid - SSID to configure\n * @param {string?} password - PSK to configure\n * @returns {Promise} Promise which resolves to a boolean indicating success of\n *                    the command.\n */\nfunction defineNetwork(ssid, password) {\n  console.log('router-setup: defineNetwork: ssid:', ssid);\n\n  const wanMode = platform.getWanMode();\n  if (wanMode.mode != 'dhcp') {\n    platform.setWanMode('dhcp');\n  }\n\n  return Settings.set('router.configured', true).then(() => {\n    return platform.setWirelessMode(\n      true,\n      'ap',\n      {\n        ssid,\n        key: password,\n        encryption: 'psk2',\n      }\n    );\n  }).catch((e) => {\n    console.error('router-setup: Error defining network:', e);\n    return false;\n  });\n}\n\n/**\n * Determine whether or not we already have a connection.\n *\n * @returns {Promise} Promise which resolves to true/false, indicating whether\n *                    or not we have a connection.\n */\nfunction checkConnection() {\n  return Settings.get('router.configured')\n    .catch(() => false)\n    .then((configured) => {\n      if (configured) {\n        return platform.checkConnection();\n      }\n\n      if (!startCaptivePortal(config.get('wifi.ap.ipaddr'))) {\n        console.error('router-setup: checkConnection:',\n                      'failed to start Captive Portal');\n      }\n      return false;\n    });\n}\n\n/**\n * Wait for a wifi connection.\n *\n * @param {number} maxAttempts - Maximum number of attempts\n * @param {number} interval - Interval at which to check, in milliseconds\n * @returns {Promise} Promise which resolves when we're connected. If we\n *                    aren't connected after maxAttempts attempts, then the\n *                    promise is rejected.\n */\nfunction waitForWiFi(maxAttempts, interval) {\n  return new Promise((resolve, reject) => {\n    let attempts = 0;\n    check();\n\n    function check() {\n      attempts++;\n      const status = platform.getWirelessMode();\n      if (status.enabled && status.mode === 'ap') {\n        console.log('router-setup: waitForWifi: connection found');\n\n        // For the traditional router setup, we have a statically assigned\n        // address so we can skip checking for the address.\n        // checkForAddress();\n        resolve();\n      } else {\n        console.log(\n          'router-setup: waitForWifi: No wifi connection on attempt', attempts\n        );\n        retryOrGiveUp();\n      }\n    }\n\n    /*\n     * We'll eventually want this function back for supporting DHCP client\n     *\n    function checkForAddress() {\n      const ifaces = os.networkInterfaces();\n\n      if (ifaces.hasOwnProperty('wlan0')) {\n        for (const addr of ifaces.wlan0) {\n          if (addr.family !== 'IPv4' || addr.internal) {\n            continue;\n          }\n\n          resolve();\n          return;\n        }\n      }\n\n      retryOrGiveUp();\n    }\n    */\n\n    function retryOrGiveUp() {\n      if (attempts >= maxAttempts) {\n        console.error(\n          'router-setup: waitForWiFi: No wifi available, giving up.'\n        );\n        reject();\n      } else {\n        setTimeout(check, interval);\n      }\n    }\n  });\n}\n\nmodule.exports = {\n  RouterSetupApp,\n  isRouterConfigured: checkConnection,\n};\n","/**\n * Router.\n *\n * Configure web app routes.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst config = require('config');\nconst compression = require('compression');\nconst Constants = require('./constants');\nconst express = require('express');\nconst jwtMiddleware = require('./jwt-middleware');\nconst nocache = require('nocache')();\nconst UserProfile = require('./user-profile');\n\nconst auth = jwtMiddleware.middleware();\n\nconst API_PREFIX = '/api'; // A pseudo path to use for API requests\nconst APP_PREFIX = '/app'; // A pseudo path to use for front end requests\n\n/**\n * Router.\n */\nconst Router = {\n  /**\n   * Configure web app routes.\n   */\n  configure: function(app, options) {\n    this.proxyController = require('./controllers/proxy_controller');\n\n    // Compress all responses larger than 1kb\n    app.use(compression());\n\n    app.use((request, response, next) => {\n      // Enable HSTS\n      if (request.protocol === 'https') {\n        response.set('Strict-Transport-Security',\n                     'max-age=31536000; includeSubDomains');\n      }\n\n      // Disable embedding\n      /*\n      response.set('Content-Security-Policy',\n                   config.get('oauthPostToken') ?\n                     'frame-ancestors filesystem:' :\n                     'frame-ancestors \\'none\\''\n      );\n       */\n\n      next();\n    });\n\n    // First look for a static file\n    const staticHandler = express.static(Constants.BUILD_STATIC_PATH);\n    app.use(Constants.UPLOADS_PATH, express.static(UserProfile.uploadsDir));\n    app.use(Constants.EXTENSIONS_PATH, nocache,\n            require('./controllers/extensions_controller'));\n    app.use((request, response, next) => {\n      if (request.path === '/' && request.accepts('html')) {\n        // We need this to hit RootController.\n        next();\n      } else {\n        staticHandler(request, response, next);\n      }\n    });\n\n    // Content negotiation middleware\n    app.use((request, response, next) => {\n      // Inform the browser that content negotiation is taking place\n      response.setHeader('Vary', 'Accept');\n\n      // Enable CORS for all requests\n      response.setHeader('Access-Control-Allow-Origin', '*');\n      response.setHeader(\n        'Access-Control-Allow-Headers',\n        'Origin, X-Requested-With, Content-Type, Accept, Authorization');\n      response.setHeader('Access-Control-Allow-Methods',\n                         'GET,HEAD,PUT,PATCH,POST,DELETE');\n\n      // If this is a proxy request, skip everything and go straight there.\n      if (request.path.startsWith(Constants.PROXY_PATH)) {\n        request.url = APP_PREFIX + request.url;\n        next();\n\n      // If request won't accept HTML but will accept JSON,\n      // or is a WebSocket request, or is multipart/form-data\n      // treat it as an API request\n      } else if (!request.accepts('html') && request.accepts('json') ||\n                 request.headers['content-type'] === 'application/json' ||\n                 request.get('Upgrade') === 'websocket' ||\n                 request.is('multipart/form-data') ||\n                 request.path.startsWith(Constants.ADDONS_PATH) ||\n                 request.path.startsWith(Constants.INTERNAL_LOGS_PATH)) {\n        request.url = API_PREFIX + request.url;\n        next();\n\n      // Otherwise treat it as an app request\n      } else {\n        request.url = APP_PREFIX + request.url;\n        next();\n      }\n    });\n\n    // Handle proxied resources\n    app.use(APP_PREFIX + Constants.PROXY_PATH, nocache, auth,\n            this.proxyController);\n\n    // Let OAuth handle its own rendering\n    app.use(APP_PREFIX + Constants.OAUTH_PATH, nocache,\n            require('./controllers/oauth_controller').default);\n\n    // Handle static media files before other static content. These must be\n    // authenticated.\n    app.use(APP_PREFIX + Constants.MEDIA_PATH, nocache, auth,\n            express.static(UserProfile.mediaDir));\n\n    // Web app routes - send index.html and fall back to client side URL router\n    app.use(`${APP_PREFIX}/*`, require('./controllers/root_controller'));\n\n    // Unauthenticated API routes\n    app.use(API_PREFIX + Constants.LOGIN_PATH, nocache,\n            require('./controllers/login_controller'));\n    app.use(API_PREFIX + Constants.SETTINGS_PATH, nocache,\n            require('./controllers/settings_controller'));\n    app.use(API_PREFIX + Constants.USERS_PATH, nocache,\n            require('./controllers/users_controller'));\n    app.use(API_PREFIX + Constants.PING_PATH, nocache,\n            require('./controllers/ping_controller'));\n    if (options.debug) {\n      app.use(API_PREFIX + Constants.DEBUG_PATH, nocache,\n              require('./controllers/debug_controller'));\n    }\n\n    // Authenticated API routes\n    app.use(API_PREFIX + Constants.THINGS_PATH, nocache, auth,\n            require('./controllers/things_controller'));\n    app.use(API_PREFIX + Constants.NEW_THINGS_PATH, nocache, auth,\n            require('./controllers/new_things_controller'));\n    app.use(API_PREFIX + Constants.ADAPTERS_PATH, nocache, auth,\n            require('./controllers/adapters_controller'));\n    app.use(API_PREFIX + Constants.ACTIONS_PATH, nocache, auth,\n            require('./controllers/actions_controller'));\n    app.use(API_PREFIX + Constants.EVENTS_PATH, nocache, auth,\n            require('./controllers/events_controller'));\n    app.use(API_PREFIX + Constants.LOG_OUT_PATH, nocache, auth,\n            require('./controllers/log_out_controller'));\n    app.use(API_PREFIX + Constants.UPLOADS_PATH, nocache, auth,\n            require('./controllers/uploads_controller'));\n    app.use(API_PREFIX + Constants.UPDATES_PATH, nocache, auth,\n            require('./controllers/updates_controller'));\n    app.use(API_PREFIX + Constants.ADDONS_PATH, nocache, auth,\n            require('./controllers/addons_controller'));\n    app.use(API_PREFIX + Constants.RULES_PATH, nocache, auth,\n            require('./rules-engine/index'));\n    app.use(API_PREFIX + Constants.INTERNAL_LOGS_PATH, nocache, auth,\n            require('./controllers/internal_logs_controller'));\n    app.use(API_PREFIX + Constants.PUSH_PATH, nocache, auth,\n            require('./controllers/push_controller'));\n    app.use(API_PREFIX + Constants.LOGS_PATH, nocache, auth,\n            require('./controllers/logs_controller'));\n    app.use(API_PREFIX + Constants.NOTIFIERS_PATH, nocache, auth,\n            require('./controllers/notifiers_controller'));\n\n    app.use(API_PREFIX + Constants.OAUTH_PATH, nocache,\n            require('./controllers/oauth_controller').default);\n    app.use(API_PREFIX + Constants.OAUTHCLIENTS_PATH, nocache, auth,\n            require('./controllers/oauthclients_controller').default);\n  },\n\n  addProxyServer(thingId, server) {\n    this.proxyController.addProxyServer(thingId, server);\n  },\n\n  removeProxyServer(thingId) {\n    this.proxyController.removeProxyServer(thingId);\n  },\n};\n\nmodule.exports = Router;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\n/**\n * A simple helper class for sending JSON-formatted errors to clients\n */\nclass APIError extends Error {\n  constructor(message, originalError) {\n    super(message);\n    if (originalError) {\n      this.message += `: ${originalError.message}`;\n    }\n    console.error(`new API Error: ${this.message}`);\n  }\n\n  toString() {\n    return JSON.stringify({error: true, message: this.message});\n  }\n}\n\nmodule.exports = APIError;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst db = require('../db');\nconst DatabaseMigrate = require('./DatabaseMigrate');\n\nclass Database {\n  constructor() {\n    if (!db.db) {\n      db.open();\n    }\n    this.open();\n  }\n\n  /**\n   * Open the database\n   */\n  open() {\n    const rulesTableSQL = `CREATE TABLE IF NOT EXISTS rules (\n      id INTEGER PRIMARY KEY,\n      description TEXT\n    );`;\n    return db.run(rulesTableSQL, []);\n  }\n\n  /**\n   * Get all rules\n   * @return {Promise<Map<number, RuleDescription>>} resolves to a map of rule\n   * id to rule\n   */\n  getRules() {\n    return new Promise((resolve, reject) => {\n      db.db.all(\n        'SELECT id, description FROM rules',\n        [],\n        (err, rows) => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          const rules = {};\n          const updatePromises = [];\n          for (const row of rows) {\n            let desc = JSON.parse(row.description);\n            const updatedDesc = DatabaseMigrate.migrate(desc);\n            if (updatedDesc) {\n              desc = updatedDesc;\n              updatePromises.push(this.updateRule(row.id, desc));\n            }\n            rules[row.id] = desc;\n          }\n          Promise.all(updatePromises).then(() => {\n            resolve(rules);\n          });\n        }\n      );\n    });\n  }\n\n  /**\n   * Create a new rule\n   * @param {RuleDescription} desc\n   * @return {Promise<number>} resolves to rule id\n   */\n  createRule(desc) {\n    return db.run(\n      'INSERT INTO rules (description) VALUES (?)',\n      [JSON.stringify(desc)]\n    ).then((res) => {\n      return parseInt(res.lastID);\n    });\n  }\n\n  /**\n   * Update an existing rule\n   * @param {number} id\n   * @param {RuleDescription} desc\n   * @return {Promise}\n   */\n  updateRule(id, desc) {\n    return db.run(\n      'UPDATE rules SET description = ? WHERE id = ?',\n      [JSON.stringify(desc), id]\n    );\n  }\n\n  /**\n   * Delete an existing rule\n   * @param {number} id\n   * @return {Promise}\n   */\n  deleteRule(id) {\n    return db.run('DELETE FROM rules WHERE id = ?', [id]);\n  }\n}\n\nmodule.exports = new Database();\n","'use strict';\n\nfunction extractProperty(href) {\n  return href.match(/properties\\/([^/]+)/)[1];\n}\n\nfunction extractThing(href) {\n  return href.match(/things\\/([^/]+)/)[1];\n}\n\nfunction migrateTimeTrigger(trigger) {\n  if (trigger.localized) {\n    return;\n  }\n\n  // If the time trigger has not been localized, it's still in UTC time\n  const parts = trigger.time.split(':');\n  let hours = parseInt(parts[0], 10);\n  let minutes = parseInt(parts[1], 10);\n\n  // Convert from UTC to local\n  const oldTime = new Date();\n  const offset = oldTime.getTimezoneOffset();\n  oldTime.setUTCHours(hours, minutes, 0, 0);\n  const newTime = new Date(oldTime + (offset * 60 * 1000));\n\n  hours = newTime.getHours().toString().padStart(2, '0');\n  minutes = newTime.getMinutes().toString().padStart(2, '0');\n\n  return {\n    type: 'TimeTrigger',\n    time: `${hours}:${minutes}`,\n    localized: true,\n  };\n}\n\nfunction migrateProperty(prop) {\n  if (!prop.href) {\n    return;\n  }\n  const base = Object.assign({}, prop);\n  delete base.href;\n  return Object.assign(base, {\n    id: extractProperty(prop.href),\n    thing: extractThing(prop.href),\n  });\n}\n\nfunction migrateThing(thing) {\n  console.log('migrateThing', thing);\n  if (typeof thing !== 'object') {\n    return;\n  }\n  if (!thing.href) {\n    return;\n  }\n  return extractThing(thing.href);\n}\n\nfunction migratePart(part) {\n  let changed = false;\n  const newPart = Object.assign({}, part);\n  if (part.triggers) {\n    newPart.triggers = part.triggers.map((child) => {\n      const newChild = migratePart(child);\n      if (newChild) {\n        changed = true;\n      }\n      return newChild || child;\n    });\n  }\n\n  if (part.effects) {\n    newPart.effects = part.effects.map((child) => {\n      const newChild = migratePart(child);\n      if (newChild) {\n        changed = true;\n      }\n      return newChild || child;\n    });\n  }\n\n  if (part.type === 'TimeTrigger') {\n    const newTrigger = migrateTimeTrigger(part);\n    if (newTrigger) {\n      changed = true;\n      Object.assign(newPart, newTrigger);\n    }\n  } else if (part.property) {\n    const newProp = migrateProperty(part.property);\n    if (newProp) {\n      changed = true;\n    }\n    newPart.property = newProp || part.property;\n  } else if (part.thing) {\n    const newThing = migrateThing(part.thing);\n    if (newThing) {\n      changed = true;\n    }\n    newPart.thing = newThing || part.thing;\n  }\n\n  if (!changed) {\n    return;\n  }\n\n  return newPart;\n}\n\nfunction migrate(oldRule) {\n  const newRule = Object.assign({}, oldRule);\n  const newTrigger = migratePart(oldRule.trigger);\n  let changed = false;\n  if (newTrigger) {\n    changed = true;\n    newRule.trigger = newTrigger;\n  }\n  const newEffect = migratePart(oldRule.effect);\n  if (newEffect) {\n    changed = true;\n    newRule.effect = newEffect;\n  }\n\n  if (!changed) {\n    return;\n  }\n  return newRule;\n}\n\nmodule.exports = {\n  migrate,\n};\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Database = require('./Database');\nconst Rule = require('./Rule');\n\n/**\n * An engine for running and managing list of rules\n */\nclass Engine {\n  /**\n   * Get a list of all current rules\n   * @return {Promise<Array<Rule>>} rules\n   */\n  getRules() {\n    let rulesPromise = Promise.resolve(this.rules);\n\n    if (!this.rules) {\n      rulesPromise = Database.getRules().then(async (ruleDescs) => {\n        this.rules = {};\n        for (const ruleId in ruleDescs) {\n          ruleDescs[ruleId].id = parseInt(ruleId);\n          this.rules[ruleId] = Rule.fromDescription(ruleDescs[ruleId]);\n          await this.rules[ruleId].start();\n        }\n        return this.rules;\n      });\n    }\n\n    return rulesPromise.then((rules) => {\n      return Object.keys(rules).map((ruleId) => {\n        return rules[ruleId];\n      });\n    });\n  }\n\n  /**\n   * Get a rule by id\n   * @param {number} id\n   * @return {Promise<Rule>}\n   */\n  getRule(id) {\n    const rule = this.rules[id];\n    if (!rule) {\n      return Promise.reject(new Error(`Rule ${id} does not exist`));\n    }\n    return Promise.resolve(rule);\n  }\n\n  /**\n   * Add a new rule to the engine's list\n   * @param {Rule} rule\n   * @return {Promise<number>} rule id\n   */\n  async addRule(rule) {\n    const id = await Database.createRule(rule.toDescription());\n    // eslint-disable-next-line require-atomic-updates\n    rule.id = id;\n    this.rules[id] = rule;\n    await rule.start();\n    return id;\n  }\n\n  /**\n   * Update an existing rule\n   * @param {number} rule id\n   * @param {Rule} rule\n   * @return {Promise}\n   */\n  async updateRule(ruleId, rule) {\n    if (!this.rules[ruleId]) {\n      return Promise.reject(new Error(`Rule ${ruleId} does not exist`));\n    }\n    rule.id = ruleId;\n    await Database.updateRule(ruleId, rule.toDescription());\n\n    this.rules[ruleId].stop();\n    this.rules[ruleId] = rule;\n    await rule.start();\n  }\n\n  /**\n   * Delete an existing rule\n   * @param {number} rule id\n   * @return {Promise}\n   */\n  deleteRule(ruleId) {\n    if (!this.rules[ruleId]) {\n      return Promise.reject(\n        new Error(`Rule ${ruleId} does not exist`));\n    }\n    return Database.deleteRule(ruleId).then(() => {\n      this.rules[ruleId].stop();\n      delete this.rules[ruleId];\n    });\n  }\n}\n\nmodule.exports = Engine;\n","/**\n * List of event types\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nmodule.exports = {\n  // Sent by a trigger to a rule to notify effects\n  STATE_CHANGED: 'state-changed',\n  // Sent by a property to a trigger to potentially change state\n  VALUE_CHANGED: 'value-changed',\n};\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst AddonManager = require('../addon-manager');\nconst Constants = require('../constants');\nconst Things = require('../models/things');\nconst EventEmitter = require('events').EventEmitter;\nconst Events = require('./Events');\n\n/**\n * Utility to support operations on Thing's properties\n */\nclass Property extends EventEmitter {\n  /**\n   * Create a Property from a descriptor returned by the WoT API\n   * @param {PropertyDescription} desc\n   */\n  constructor(desc) {\n    super();\n\n    assert(desc.type);\n    assert(desc.thing);\n    assert(desc.id);\n\n    this.type = desc.type;\n    this.thing = desc.thing;\n    this.id = desc.id;\n\n    if (desc.unit) {\n      this.unit = desc.unit;\n    }\n    if (desc.description) {\n      this.description = desc.description;\n    }\n\n    this.onPropertyChanged = this.onPropertyChanged.bind(this);\n    this.onThingAdded = this.onThingAdded.bind(this);\n  }\n\n  /**\n   * @return {PropertyDescription}\n   */\n  toDescription() {\n    const desc = {\n      type: this.type,\n      thing: this.thing,\n      id: this.id,\n    };\n    if (this.unit) {\n      desc.unit = this.unit;\n    }\n    if (this.description) {\n      desc.description = this.description;\n    }\n    return desc;\n  }\n\n  /**\n   * @return {Promise} resolves to property's value or undefined if not found\n   */\n  async get() {\n    try {\n      return await Things.getThingProperty(this.thing, this.id);\n    } catch (e) {\n      console.warn('Rule get failed', e);\n    }\n  }\n\n  /**\n   * @param {any} value\n   * @return {Promise} resolves when set is done\n   */\n  set(value) {\n    return Things.setThingProperty(this.thing, this.id, value).catch((e) => {\n      console.warn('Rule set failed, retrying once', e);\n      return Things.setThingProperty(this.thing, this.id, value);\n    }).catch((e) => {\n      console.warn('Rule set failed completely', e);\n    });\n  }\n\n  async start() {\n    AddonManager.on(Constants.PROPERTY_CHANGED, this.onPropertyChanged);\n\n    try {\n      await this.getInitialValue();\n    } catch (_e) {\n      AddonManager.on(Constants.THING_ADDED, this.onThingAdded);\n    }\n  }\n\n  async getInitialValue() {\n    const initialValue = await this.get();\n    if (typeof initialValue === 'undefined') {\n      throw new Error('Did not get a real value');\n    }\n    this.emit(Events.VALUE_CHANGED, initialValue);\n  }\n\n  /**\n   * Listener for AddonManager's THING_ADDED event\n   * @param {String} thing - thing id\n   */\n  onThingAdded(thing) {\n    if (thing.id !== this.thing) {\n      return;\n    }\n    this.getInitialValue().catch((e) => {\n      console.warn('Rule property unable to get initial value:', e.message);\n    });\n  }\n\n  onPropertyChanged(property) {\n    if (property.device.id !== this.thing) {\n      return;\n    }\n    if (property.name !== this.id) {\n      return;\n    }\n    this.emit(Events.VALUE_CHANGED, property.value);\n  }\n\n  stop() {\n    AddonManager.removeListener(Constants.PROPERTY_CHANGED,\n                                this.onPropertyChanged);\n    AddonManager.removeListener(Constants.THING_ADDED,\n                                this.onThingAdded);\n  }\n}\n\nmodule.exports = Property;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst effects = require('./effects');\nconst triggers = require('./triggers');\nconst Events = require('./Events');\n\nconst DEBUG = false || (process.env.NODE_ENV === 'test');\n\nclass Rule {\n  /**\n   * @param {boolean} enabled\n   * @param {Trigger} trigger\n   * @param {Effect} effect\n   */\n  constructor(enabled, trigger, effect) {\n    this.enabled = enabled;\n    this.trigger = trigger;\n    this.effect = effect;\n\n    this.onTriggerStateChanged = this.onTriggerStateChanged.bind(this);\n  }\n\n  /**\n   * Begin executing the rule\n   */\n  async start() {\n    this.trigger.on(Events.STATE_CHANGED, this.onTriggerStateChanged);\n    await this.trigger.start();\n    if (DEBUG) {\n      console.debug('Rule.start', this.name);\n    }\n  }\n\n  /**\n   * On a state changed event, pass the state forward to the rule's effect\n   * @param {State} state\n   */\n  onTriggerStateChanged(state) {\n    if (!this.enabled) {\n      return;\n    }\n    if (DEBUG) {\n      console.debug('Rule.onTriggerStateChanged', this.name, state);\n    }\n    this.effect.setState(state);\n  }\n\n  /**\n   * @return {RuleDescription}\n   */\n  toDescription() {\n    const desc = {\n      enabled: this.enabled,\n      trigger: this.trigger.toDescription(),\n      effect: this.effect.toDescription(),\n    };\n    if (this.hasOwnProperty('id')) {\n      desc.id = this.id;\n    }\n    if (this.hasOwnProperty('name')) {\n      desc.name = this.name;\n    }\n    return desc;\n  }\n\n  /**\n   * Stop executing the rule\n   */\n  stop() {\n    this.trigger.removeListener(Events.STATE_CHANGED,\n                                this.onTriggerStateChanged);\n    this.trigger.stop();\n    if (DEBUG) {\n      console.debug('Rule.stop', this.name);\n    }\n  }\n}\n\n/**\n * Create a rule from a serialized description\n * @param {RuleDescription} desc\n * @return {Rule}\n */\nRule.fromDescription = (desc) => {\n  const trigger = triggers.fromDescription(desc.trigger);\n  const effect = effects.fromDescription(desc.effect);\n  const rule = new Rule(desc.enabled, trigger, effect);\n  if (desc.hasOwnProperty('id')) {\n    rule.id = desc.id;\n  }\n  if (desc.hasOwnProperty('name')) {\n    rule.name = desc.name;\n  }\n  return rule;\n};\n\nmodule.exports = Rule;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst assert = require('assert');\n\nconst Action = require('../../models/action');\nconst Actions = require('../../models/actions');\nconst AddonManager = require('../../addon-manager');\nconst Effect = require('./Effect');\nconst Things = require('../../models/things');\n\n/**\n * An Effect which creates an action\n */\nclass ActionEffect extends Effect {\n  /**\n   * @param {EffectDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n\n    assert(desc.thing);\n    assert(desc.action);\n\n    this.thing = desc.thing;\n    this.action = desc.action;\n    this.parameters = desc.parameters || {};\n  }\n\n  /**\n   * @return {EffectDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {\n        thing: this.thing,\n        action: this.action,\n        parameters: this.parameters,\n      }\n    );\n  }\n\n  /**\n   * @param {State} state\n   */\n  setState(state) {\n    if (!state.on) {\n      return;\n    }\n\n    this.createAction();\n  }\n\n  async createAction() {\n    try {\n      const thing = await Things.getThing(this.thing);\n\n      const action = new Action(this.action, this.parameters, thing);\n      await Actions.add(action);\n      await AddonManager.requestAction(this.thing, action.id, this.action,\n                                       this.parameters);\n    } catch (e) {\n      console.warn('Unable to dispatch action', e);\n    }\n  }\n}\n\nmodule.exports = ActionEffect;\n\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\n/**\n * Effect - The outcome of a Rule once triggered\n */\nclass Effect {\n  /**\n   * Create an Effect based on a wire-format description with a property\n   * @param {EffectDescription} desc\n   */\n  constructor(desc) {\n    this.type = this.constructor.name;\n    this.label = desc.label;\n  }\n\n  /**\n   * @return {EffectDescription}\n   */\n  toDescription() {\n    return {\n      type: this.type,\n      label: this.label,\n    };\n  }\n\n  /**\n   * Set the state of Effect based on a trigger\n   * @param {State} _state\n   */\n  setState(_state) {\n    throw new Error('Unimplemented');\n  }\n}\n\nmodule.exports = Effect;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Effect = require('./Effect');\n\n/**\n * MultiEffect - The outcome of a Rule involving multiple effects\n */\nclass MultiEffect extends Effect {\n  /**\n   * @param {MultiEffectDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n    const fromDescription = require('./index').fromDescription;\n\n    this.effects = desc.effects.map(function(effect) {\n      return fromDescription(effect);\n    });\n  }\n\n  /**\n   * @return {EffectDescription}\n   */\n  toDescription() {\n    return Object.assign(super.toDescription(), {\n      effects: this.effects.map((effect) => effect.toDescription()),\n    });\n  }\n\n  /**\n   * @param {State} state\n   */\n  setState(state) {\n    for (const effect of this.effects) {\n      effect.setState(state);\n    }\n  }\n}\n\nmodule.exports = MultiEffect;\n\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst Effect = require('./Effect');\nconst PushService = require('../../push-service');\n\n/**\n * An Effect which creates a notification\n */\nclass NotificationEffect extends Effect {\n  /**\n   * @param {EffectDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n\n    assert(desc.hasOwnProperty('message'));\n\n    this.message = desc.message;\n  }\n\n  /**\n   * @return {EffectDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {\n        message: this.message,\n      }\n    );\n  }\n\n  /**\n   * @param {State} state\n   */\n  setState(state) {\n    if (!state.on) {\n      return;\n    }\n\n    PushService.broadcastNotification(this.message);\n  }\n}\n\nmodule.exports = NotificationEffect;\n\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst Effect = require('./Effect');\nconst AddonManager = require('../../addon-manager');\n\n/**\n * An Effect which calls notify on a notifier's outlet\n */\nclass NotifierOutletEffect extends Effect {\n  /**\n   * @param {EffectDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n\n    assert(desc.hasOwnProperty('notifier'));\n    assert(desc.hasOwnProperty('outlet'));\n    assert(desc.hasOwnProperty('title'));\n    assert(desc.hasOwnProperty('message'));\n    assert(desc.hasOwnProperty('level'));\n\n    this.notifier = desc.notifier;\n    this.outlet = desc.outlet;\n    this.title = desc.title;\n    this.message = desc.message;\n    this.level = desc.level;\n  }\n\n  /**\n   * @return {EffectDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {\n        notifier: this.notifier,\n        outlet: this.outlet,\n        title: this.title,\n        message: this.message,\n        level: this.level,\n      }\n    );\n  }\n\n  /**\n   * @param {State} state\n   */\n  setState(state) {\n    if (!state.on) {\n      return;\n    }\n\n    const notifier = AddonManager.getNotifier(this.notifier);\n    if (!notifier) {\n      console.warn(`Notifier \"${this.notifier}\" not found, unable to notify`);\n      return;\n    }\n    const outlet = notifier.getOutlet(this.outlet);\n    if (!outlet) {\n      console.warn(`Outlet \"${this.outlet}\" of notifier \"${this.notifier}\" not found, unable to notify`);\n      return;\n    }\n\n    outlet.notify(this.title, this.message, this.level).catch((e) => {\n      console.warn(`Outlet \"${this.outlet}\" of notifier \"${this.notifier}\" unable to notify`, e);\n    });\n  }\n}\n\nmodule.exports = NotifierOutletEffect;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Property = require('../Property');\nconst Effect = require('./Effect');\n\n/**\n * PropertyEffect - The outcome of a Rule involving a property\n */\nclass PropertyEffect extends Effect {\n  /**\n   * Create an Effect based on a wire-format description with a property\n   * @param {PropertyEffectDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n    this.property = new Property(desc.property);\n  }\n\n  /**\n   * @return {EffectDescription}\n   */\n  toDescription() {\n    return Object.assign(super.toDescription(), {\n      property: this.property.toDescription(),\n    });\n  }\n}\n\nmodule.exports = PropertyEffect;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst PropertyEffect = require('./PropertyEffect');\n\n/**\n * An Effect which temporarily sets the target property to\n * a value before restoring its original value\n */\nclass PulseEffect extends PropertyEffect {\n  /**\n   * @param {EffectDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n    this.value = desc.value;\n    if (typeof this.value === 'number') {\n      assert(this.property.type === 'number' ||\n             this.property.type === 'integer',\n             'setpoint and property must be compatible types');\n    } else {\n      assert(typeof this.value === this.property.type,\n             'setpoint and property must be same type');\n    }\n\n    this.on = false;\n    this.oldValue = null;\n  }\n\n  /**\n   * @return {EffectDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {value: this.value}\n    );\n  }\n\n  /**\n   * @param {State} state\n   */\n  setState(state) {\n    if (state.on) {\n      // If we're already active, just perform the effect again\n      if (this.on) {\n        return this.property.set(this.value);\n      }\n      // Activate the effect and save our current state to revert to upon\n      // deactivation\n      this.property.get().then((value) => {\n        this.oldValue = value;\n        // Always set to the opposite (always toggle)\n        if (typeof value === 'boolean') {\n          this.oldValue = !this.value;\n        }\n        this.on = true;\n        return this.property.set(this.value);\n      });\n    } else if (this.on) {\n      // Revert to our original value if we pulsed to a new value\n      this.on = false;\n      if (this.oldValue !== null) {\n        return this.property.set(this.oldValue);\n      }\n    }\n  }\n}\n\nmodule.exports = PulseEffect;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst PropertyEffect = require('./PropertyEffect');\n\n/**\n * An Effect which permanently sets the target property to\n * a value when triggered\n */\nclass SetEffect extends PropertyEffect {\n  /**\n   * @param {EffectDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n    this.value = desc.value;\n    if (typeof this.value === 'number') {\n      assert(this.property.type === 'number' ||\n             this.property.type === 'integer',\n             'setpoint and property must be compatible types');\n    } else {\n      assert(typeof this.value === this.property.type,\n             'setpoint and property must be same type');\n    }\n    this.on = false;\n  }\n\n  /**\n   * @return {EffectDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {value: this.value}\n    );\n  }\n\n  /**\n   * @return {State}\n   */\n  setState(state) {\n    if (!this.on && state.on) {\n      this.on = true;\n      return this.property.set(this.value);\n    }\n    if (this.on && !state.on) {\n      this.on = false;\n      return Promise.resolve();\n    }\n  }\n}\n\nmodule.exports = SetEffect;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst effects = {\n  Effect: require('./Effect'),\n  ActionEffect: require('./ActionEffect'),\n  MultiEffect: require('./MultiEffect'),\n  NotificationEffect: require('./NotificationEffect'),\n  NotifierOutletEffect: require('./NotifierOutletEffect'),\n  SetEffect: require('./SetEffect'),\n  PulseEffect: require('./PulseEffect'),\n};\n\n/**\n * Produce an effect from a serialized effect description. Throws if `desc` is\n * invalid\n * @param {EffectDescription} desc\n * @return {Effect}\n */\nfunction fromDescription(desc) {\n  const EffectClass = effects[desc.type];\n  if (!EffectClass) {\n    throw new Error(`Unsupported or invalid effect type:${desc.type}`);\n  }\n  return new EffectClass(desc);\n}\n\nmodule.exports = {\n  effects: effects,\n  fromDescription: fromDescription,\n};\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst PromiseRouter = require('express-promise-router');\n\nconst APIError = require('./APIError');\nconst Database = require('./Database');\nconst Engine = require('./Engine');\nconst Rule = require('./Rule');\n\nconst index = PromiseRouter();\nconst engine = new Engine();\n\n/**\n * Express middleware for extracting rules from the bodies of requests\n * @param {express.Request} req\n * @param {express.Response} res\n * @param {Function} next\n */\nfunction parseRuleFromBody(req, res, next) {\n  if (!req.body.trigger) {\n    res.status(400).send(new APIError('No trigger provided').toString());\n    return;\n  }\n  if (!req.body.effect) {\n    res.status(400).send(new APIError('No effect provided').toString());\n    return;\n  }\n\n  let rule = null;\n  try {\n    rule = Rule.fromDescription(req.body);\n  } catch (e) {\n    res.status(400).send(new APIError('Invalid rule', e).toString());\n    return;\n  }\n  req.rule = rule;\n  next();\n}\n\nindex.get('/', async (req, res) => {\n  const rules = await engine.getRules();\n  res.send(rules.map((rule) => {\n    return rule.toDescription();\n  }));\n});\n\n\nindex.get('/:id', async (req, res) => {\n  try {\n    const id = parseInt(req.params.id);\n    const rule = await engine.getRule(id);\n    res.send(rule.toDescription());\n  } catch (e) {\n    res.status(404).send(\n      new APIError('Engine failed to get rule', e).toString());\n  }\n});\n\nindex.post('/', parseRuleFromBody, async (req, res) => {\n  const ruleId = await engine.addRule(req.rule);\n  res.send({id: ruleId});\n});\n\nindex.put('/:id', parseRuleFromBody, async (req, res) => {\n  try {\n    await engine.updateRule(parseInt(req.params.id), req.rule);\n    res.send({});\n  } catch (e) {\n    res.status(404).send(\n      new APIError('Engine failed to update rule', e).toString());\n  }\n});\n\nindex.delete('/:id', async (req, res) => {\n  try {\n    await engine.deleteRule(req.params.id);\n    res.send({});\n  } catch (e) {\n    res.status(404).send(\n      new APIError('Engine failed to delete rule', e).toString());\n  }\n});\n\nindex.configure = async () => {\n  await Database.open();\n  await engine.getRules();\n};\n\nmodule.exports = index;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst Events = require('../Events');\nconst PropertyTrigger = require('./PropertyTrigger');\n\n/**\n * A Trigger which activates when a boolean property is\n * equal to a given value, `onValue`\n */\nclass BooleanTrigger extends PropertyTrigger {\n  /**\n   * @param {TriggerDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n    assert(this.property.type === 'boolean');\n    assert(typeof desc.onValue === 'boolean');\n    this.onValue = desc.onValue;\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {onValue: this.onValue}\n    );\n  }\n\n  /**\n   * @param {boolean} propValue\n   * @return {State}\n   */\n  onValueChanged(propValue) {\n    if (propValue === this.onValue) {\n      this.emit(Events.STATE_CHANGED, {on: true, value: propValue});\n    } else {\n      this.emit(Events.STATE_CHANGED, {on: false, value: propValue});\n    }\n  }\n}\n\nmodule.exports = BooleanTrigger;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Events = require('../Events');\nconst PropertyTrigger = require('./PropertyTrigger');\n\n/**\n * A trigger which activates when a property is equal to a given value\n */\nclass EqualityTrigger extends PropertyTrigger {\n  /**\n   * @param {TriggerDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n\n    this.value = desc.value;\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {\n        value: this.value,\n      }\n    );\n  }\n\n  /**\n   * @param {number} propValue\n   * @return {State}\n   */\n  onValueChanged(propValue) {\n    const on = propValue === this.value;\n\n    this.emit(Events.STATE_CHANGED, {on: on, value: propValue});\n  }\n}\n\nmodule.exports = EqualityTrigger;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst Events = require('../Events');\nconst Things = require('../../models/things');\nconst Trigger = require('./Trigger');\n\n/**\n * A trigger activated when an event occurs\n */\nclass EventTrigger extends Trigger {\n  constructor(desc) {\n    super(desc);\n    assert(desc.thing);\n    this.thing = desc.thing;\n    this.event = desc.event;\n    this.stopped = true;\n    this.onEvent = this.onEvent.bind(this);\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {\n        thing: this.thing,\n        event: this.event,\n      }\n    );\n  }\n\n  async start() {\n    this.stopped = false;\n    const thing = await Things.getThing(this.thing);\n    if (this.stopped) {\n      return;\n    }\n    thing.addEventSubscription(this.onEvent);\n  }\n\n  onEvent(event) {\n    if (this.event !== event.name) {\n      return;\n    }\n\n    this.emit(Events.STATE_CHANGED, {on: true, value: Date.now()});\n    this.emit(Events.STATE_CHANGED, {on: false, value: Date.now()});\n  }\n\n  stop() {\n    this.stopped = true;\n    Things.getThing(this.thing).then((thing) => {\n      thing.removeEventSubscription(this.onEvent);\n    });\n  }\n}\n\nmodule.exports = EventTrigger;\n\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst Events = require('../Events');\nconst PropertyTrigger = require('./PropertyTrigger');\n\nconst LevelTriggerTypes = {\n  LESS: 'LESS',\n  EQUAL: 'EQUAL',\n  GREATER: 'GREATER',\n};\n\n/**\n * A trigger which activates when a numerical property is less or greater than\n * a given level\n */\nclass LevelTrigger extends PropertyTrigger {\n  /**\n   * @param {TriggerDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n    assert(this.property.type === 'number' || this.property.type === 'integer');\n    assert(typeof desc.value === 'number');\n    assert(LevelTriggerTypes[desc.levelType]);\n    if (desc.levelType === 'EQUAL') {\n      assert(this.property.type === 'integer');\n    }\n\n    this.value = desc.value;\n    this.levelType = desc.levelType;\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {\n        value: this.value,\n        levelType: this.levelType,\n      }\n    );\n  }\n\n  /**\n   * @param {number} propValue\n   * @return {State}\n   */\n  onValueChanged(propValue) {\n    let on = false;\n\n    switch (this.levelType) {\n      case LevelTriggerTypes.LESS:\n        if (propValue < this.value) {\n          on = true;\n        }\n        break;\n      case LevelTriggerTypes.EQUAL:\n        if (propValue === this.value) {\n          on = true;\n        }\n        break;\n      case LevelTriggerTypes.GREATER:\n        if (propValue > this.value) {\n          on = true;\n        }\n        break;\n    }\n\n    this.emit(Events.STATE_CHANGED, {on: on, value: propValue});\n  }\n}\n\nLevelTrigger.types = LevelTriggerTypes;\n\nmodule.exports = LevelTrigger;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst Events = require('../Events');\nconst Trigger = require('./Trigger');\n\nconst DEBUG = false || (process.env.NODE_ENV === 'test');\n\nconst ops = {\n  AND: 'AND',\n  OR: 'OR',\n};\n\n/**\n * A Trigger which activates only when a set of triggers are activated\n */\nclass MultiTrigger extends Trigger {\n  /**\n   * @param {TriggerDescription} desc\n   */\n  constructor(desc) {\n    super(desc);\n    assert(desc.op in ops);\n    this.op = desc.op;\n    const fromDescription = require('./index').fromDescription;\n\n    if (DEBUG) {\n      this.id = Math.floor(Math.random() * 1000);\n    }\n    this.triggers = desc.triggers.map((trigger) => {\n      return fromDescription(trigger);\n    });\n\n    this.states = new Array(this.triggers.length);\n    for (let i = 0; i < this.states.length; i++) {\n      this.states[i] = false;\n    }\n    this.state = false;\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return Object.assign(super.toDescription(), {\n      op: this.op,\n      triggers: this.triggers.map((trigger) => trigger.toDescription()),\n    });\n  }\n\n  async start() {\n    const starts = this.triggers.map((trigger, triggerIndex) => {\n      trigger.on(Events.STATE_CHANGED,\n                 this.onStateChanged.bind(this, triggerIndex));\n      return trigger.start();\n    });\n    await Promise.all(starts);\n  }\n\n  stop() {\n    this.triggers.forEach((trigger) => {\n      trigger.removeAllListeners(Events.STATE_CHANGED);\n      trigger.stop();\n    });\n  }\n\n  onStateChanged(triggerIndex, state) {\n    this.states[triggerIndex] = state.on;\n\n    let value = this.states[0];\n    for (let i = 1; i < this.states.length; i++) {\n      if (this.op === ops.AND) {\n        value = value && this.states[i];\n      } else if (this.op === ops.OR) {\n        value = value || this.states[i];\n      }\n    }\n    if (DEBUG) {\n      console.debug(\n        `MultiTrigger(${this.id}).onStateChanged(${triggerIndex}, ${state}) -> ${this.states}`);\n    }\n    if (value !== this.state) {\n      this.state = value;\n      this.emit(Events.STATE_CHANGED, {on: this.state});\n    }\n  }\n}\n\nmodule.exports = MultiTrigger;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Events = require('../Events');\nconst Trigger = require('./Trigger');\nconst Property = require('../Property');\n\n/**\n * An abstract class for triggers whose input is a single property\n */\nclass PropertyTrigger extends Trigger {\n  constructor(desc) {\n    super(desc);\n    this.property = new Property(desc.property);\n    this.onValueChanged = this.onValueChanged.bind(this);\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {property: this.property.toDescription()}\n    );\n  }\n\n  async start() {\n    this.property.on(Events.VALUE_CHANGED, this.onValueChanged);\n    await this.property.start();\n  }\n\n  onValueChanged(_value) {\n  }\n\n  stop() {\n    this.property.removeListener(Events.VALUE_CHANGED, this.onValueChanged);\n    this.property.stop();\n  }\n}\n\nmodule.exports = PropertyTrigger;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst Events = require('../Events');\nconst Trigger = require('./Trigger');\n\n/**\n * An abstract class for triggers whose input is a single property\n */\nclass TimeTrigger extends Trigger {\n  constructor(desc) {\n    super(desc);\n    this.time = desc.time;\n    this.localized = !!desc.localized;\n    this.sendOn = this.sendOn.bind(this);\n    this.sendOff = this.sendOff.bind(this);\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return Object.assign(\n      super.toDescription(),\n      {time: this.time, localized: this.localized}\n    );\n  }\n\n  async start() {\n    this.scheduleNext();\n  }\n\n  scheduleNext() {\n    const parts = this.time.split(':');\n    const hours = parseInt(parts[0], 10);\n    const minutes = parseInt(parts[1], 10);\n\n    // Time is specified in local time\n    const nextTime = new Date();\n    nextTime.setHours(hours, minutes, 0, 0);\n\n    if (nextTime.getTime() < Date.now()) {\n      // NB: this will wrap properly into the next month/year\n      nextTime.setDate(nextTime.getDate() + 1);\n    }\n\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n    }\n    this.timeout = setTimeout(this.sendOn, nextTime.getTime() - Date.now());\n  }\n\n  sendOn() {\n    this.emit(Events.STATE_CHANGED, {on: true, value: Date.now()});\n    this.timeout = setTimeout(this.sendOff, 60 * 1000);\n  }\n\n  sendOff() {\n    this.emit(Events.STATE_CHANGED, {on: false, value: Date.now()});\n    this.scheduleNext();\n  }\n\n  stop() {\n    clearTimeout(this.timeout);\n    this.timeout = null;\n  }\n}\n\nmodule.exports = TimeTrigger;\n\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * The trigger component of a Rule which monitors some state and passes on\n * whether to be active to the Rule's effect\n */\nclass Trigger extends EventEmitter {\n  /**\n   * Create a Trigger based on a wire-format description with a property\n   * @param {TriggerDescription} desc\n   */\n  constructor(desc) {\n    super();\n    this.type = this.constructor.name;\n    this.label = desc.label;\n  }\n\n  /**\n   * @return {TriggerDescription}\n   */\n  toDescription() {\n    return {\n      type: this.type,\n      label: this.label,\n    };\n  }\n}\n\nmodule.exports = Trigger;\n","/**\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst triggers = {\n  BooleanTrigger: require('./BooleanTrigger'),\n  EqualityTrigger: require('./EqualityTrigger'),\n  EventTrigger: require('./EventTrigger'),\n  LevelTrigger: require('./LevelTrigger'),\n  MultiTrigger: require('./MultiTrigger'),\n  PropertyTrigger: require('./PropertyTrigger'),\n  TimeTrigger: require('./TimeTrigger'),\n  Trigger: require('./Trigger'),\n};\n\n/**\n * Produce an trigger from a serialized trigger description. Throws if `desc`\n * is invalid\n * @param {TriggerDescription} desc\n * @return {Trigger}\n */\nfunction fromDescription(desc) {\n  const TriggerClass = triggers[desc.type];\n  if (!TriggerClass) {\n    throw new Error(`Unsupported or invalid trigger type:${desc.type}`);\n  }\n  return new TriggerClass(desc);\n}\n\nmodule.exports = {\n  triggers: triggers,\n  fromDescription: fromDescription,\n};\n","'use strict';\n\nmodule.exports = (ms) => {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n};\n","/**\n * Gateway tunnel service.\n *\n * Manages the tunnel service.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst fs = require('fs');\nconst CertificateManager = require('./certificate-manager');\nconst config = require('config');\nconst Deferred = require('./deferred');\nconst path = require('path');\nconst fetch = require('node-fetch');\nconst spawnSync = require('child_process').spawn;\nconst Settings = require('./models/settings');\nconst UserProfile = require('./user-profile');\nconst PushService = require('./push-service');\n\nconst DEBUG = false || (process.env.NODE_ENV === 'test');\n\nconst TunnelService = {\n\n  pagekiteProcess: null,\n  tunneltoken: null,\n  switchToHttps: null,\n  connected: new Deferred(),\n  pingInterval: null,\n  renewInterval: null,\n  server: null,\n\n  /*\n   * Router middleware to check if we have a ssl tunnel set.\n   *\n   * @param {Object} request Express request object.\n   * @param {Object} response Express response object.\n   * @param {Object} next Next middleware.\n   */\n  isTunnelSet: async function(request, response, next) {\n    // If ssl tunnel is disabled, continue\n    if (!config.get('ssltunnel.enabled')) {\n      return next();\n    } else {\n      let notunnel = await Settings.get('notunnel');\n      if (typeof notunnel !== 'boolean') {\n        notunnel = false;\n      }\n\n      // then we check if we have certificates installed\n      if ((fs.existsSync(path.join(UserProfile.sslDir,\n                                   'certificate.pem')) &&\n           fs.existsSync(path.join(UserProfile.sslDir,\n                                   'privatekey.pem'))) ||\n          notunnel) {\n        // if certs are installed,\n        // then we don't need to do anything and return\n        return next();\n      }\n\n      // if there are no certs installed,\n      // we display the cert setup page to the user\n      response.render('tunnel-setup',\n                      {domain: config.get('ssltunnel.domain')});\n    }\n  },\n\n  // Set a handle for the running https server, used when renewing certificates\n  setServerHandle: function(server) {\n    this.server = server;\n  },\n\n  // method that starts the client if the box has a registered tunnel\n  start: function(response, urlredirect) {\n    Settings.get('tunneltoken').then((result) => {\n      if (typeof result === 'object') {\n        let responseSent = false;\n        this.tunneltoken = result;\n        const endpoint = `${result.name}.${\n          config.get('ssltunnel.domain')}`;\n        this.pagekiteProcess =\n          spawnSync(config.get('ssltunnel.pagekite_cmd'),\n                    ['--clean', `--frontend=${endpoint}:${\n                      config.get('ssltunnel.port')}`,\n                     `--service_on=https:${endpoint\n                     }:localhost:${\n                       config.get('ports.https')}:${\n                       this.tunneltoken.token}`],\n                    {shell: true});\n\n        this.pagekiteProcess.stdout.on('data', (data) => {\n          if (DEBUG) {\n            console.log(`[pagekite] stdout: ${data}`);\n          }\n\n          const needToSend = response && !responseSent;\n\n          if (data.indexOf('err=Error in connect') > -1) {\n            console.error('PageKite failed to connect');\n            this.connected.reject();\n            if (needToSend) {\n              responseSent = true;\n              response.sendStatus(400);\n            }\n          } else if (data.indexOf('connect=') > -1) {\n            console.log('PageKite connected!');\n            this.connected.resolve();\n            if (needToSend) {\n              responseSent = true;\n              response.status(200).json(urlredirect);\n            }\n          }\n        });\n        this.pagekiteProcess.stderr.on('data', (data) => {\n          console.log(`[pagekite] stderr: ${data}`);\n        });\n        this.pagekiteProcess.on('close', (code) => {\n          console.log(`[pagekite] process exited with code ${code}`);\n        });\n\n        this.connected.promise.then(() => {\n          // Ping the registration server every hour.\n          this.pingInterval =\n            setInterval(() => this.pingRegistrationServer(), 60 * 60 * 1000);\n\n          // Enable push service\n          PushService.init(`https://${endpoint}`);\n\n          const renew = () => {\n            return CertificateManager.renew(this.server).catch(() => {});\n          };\n\n          // Try to renew certificates immediately, then daily.\n          renew().then(() => {\n            this.renewInterval = setInterval(renew, 24 * 60 * 60 * 1000);\n          });\n        }).catch(() => {});\n      } else {\n        console.error('tunneltoken not set');\n        if (response) {\n          response.status(400).end();\n        }\n      }\n    }).catch((e) => {\n      console.error('Failed to get tunneltoken setting:', e);\n\n      if (response) {\n        response.status(400).send(e);\n      }\n    });\n  },\n\n  // method to stop pagekite process\n  stop: function() {\n    if (this.pingInterval !== null) {\n      clearInterval(this.pingInterval);\n    }\n\n    if (this.renewInterval !== null) {\n      clearInterval(this.renewInterval);\n    }\n\n    if (this.pagekiteProcess) {\n      this.pagekiteProcess.kill('SIGHUP');\n    }\n  },\n\n  // method to check if the box has certificates\n  hasCertificates: function() {\n    return fs.existsSync(path.join(UserProfile.sslDir, 'certificate.pem')) &&\n      fs.existsSync(path.join(UserProfile.sslDir, 'privatekey.pem'));\n  },\n\n  // method to check if the box has a registered tunnel\n  hasTunnelToken: async function() {\n    const tunneltoken = await Settings.get('tunneltoken');\n    return typeof tunneltoken === 'object';\n  },\n\n  // method to check if user skipped the ssl tunnel setup\n  userSkipped: async function() {\n    const notunnel = await Settings.get('notunnel');\n    if (typeof notunnel === 'boolean' && notunnel) {\n      return true;\n    }\n\n    return false;\n  },\n\n  // method to ping the registration server to track active domains\n  pingRegistrationServer: function() {\n    const url = `${config.get('ssltunnel.registration_endpoint')}` +\n      `/ping?token=${this.tunneltoken.token}`;\n    fetch(url).catch((e) => {\n      console.log('Failed to ping registration server:', e);\n    });\n  },\n};\n\nmodule.exports = TunnelService;\n","/**\n * WebThings Gateway user profile.\n *\n * The user profile lives outside of the source tree to allow for things like\n * data persistence with Docker, as well as the ability to easily switch\n * profiles, if desired.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nprocess.env.ALLOW_CONFIG_MUTATIONS = 'true';\nconst config = require('config');\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\nconst mkdirp = require('mkdirp');\nconst {ncp} = require('ncp');\nconst rimraf = require('rimraf');\n\nconst Profile = {\n  init: function() {\n    this.baseDir = path.resolve(\n      process.env.MOZIOT_HOME || config.get('profileDir')\n    );\n    this.configDir = path.join(this.baseDir, 'config');\n    this.dataDir = path.join(this.baseDir, 'data');\n    this.sslDir = path.join(this.baseDir, 'ssl');\n    this.uploadsDir = path.join(this.baseDir, 'uploads');\n    this.mediaDir = path.join(this.baseDir, 'media');\n    this.logDir = path.join(this.baseDir, 'log');\n    this.gatewayDir = path.resolve(path.join(__dirname, '..'));\n\n    if (process.env.NODE_ENV === 'test') {\n      this.addonsDir = path.join(this.gatewayDir, 'src', 'addons-test');\n    } else {\n      this.addonsDir = path.join(this.baseDir, 'addons');\n    }\n  },\n\n  /**\n   * Manually copy, then unlink, to prevent issues with cross-device renames.\n   */\n  renameFile: (src, dst) => {\n    fs.copyFileSync(src, dst);\n    fs.unlinkSync(src);\n  },\n\n  /**\n   * Manually copy, then remove, to prevent issues with cross-device renames.\n   */\n  renameDir: (src, dst) => new Promise((resolve, reject) => {\n    ncp(src, dst, (e) => {\n      if (e) {\n        reject(e);\n        return;\n      }\n\n      rimraf(src, (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        resolve();\n      });\n    });\n  }),\n\n  /**\n   * Migrate from old locations to new ones\n   * @return {Promise} resolved when migration is complete\n   */\n  migrate: function() {\n    const pending = [];\n    // Create all required profile directories.\n    if (!fs.existsSync(this.configDir)) {\n      mkdirp.sync(this.configDir);\n    }\n    if (!fs.existsSync(this.dataDir)) {\n      mkdirp.sync(this.dataDir);\n    }\n    if (!fs.existsSync(this.sslDir)) {\n      mkdirp.sync(this.sslDir);\n    }\n    if (!fs.existsSync(this.uploadsDir)) {\n      mkdirp.sync(this.uploadsDir);\n    }\n    if (!fs.existsSync(this.logDir)) {\n      mkdirp.sync(this.logDir);\n    }\n    if (!fs.existsSync(this.addonsDir)) {\n      mkdirp.sync(this.addonsDir);\n    }\n\n    // Relocate the database, if necessary, before opening it.\n    const dbPath = path.join(this.configDir, 'db.sqlite3');\n    const oldDbPath = path.join(this.gatewayDir, 'db.sqlite3');\n    if (fs.existsSync(oldDbPath)) {\n      this.renameFile(oldDbPath, dbPath);\n    }\n\n    const db = require('./db');\n    const Settings = require('./models/settings');\n    const Users = require('./models/users');\n\n    // Open the database.\n    db.open();\n\n    // Normalize user email addresses\n    pending.push(\n      Users.getUsers().then((users) => {\n        users.forEach((user) => {\n          // Call editUser with the same user, as it will normalize the email\n          // for us and save it.\n          Users.editUser(user);\n        });\n      })\n    );\n\n    // Move the tunneltoken into the database.\n    const ttPath = path.join(this.gatewayDir, 'tunneltoken');\n    if (fs.existsSync(ttPath)) {\n      const token = JSON.parse(fs.readFileSync(ttPath));\n      pending.push(\n        Settings.set('tunneltoken', token).then(() => {\n          fs.unlinkSync(ttPath);\n        }).catch((e) => {\n          throw e;\n        })\n      );\n    }\n\n    // Move the notunnel setting into the database.\n    const ntPath = path.join(this.gatewayDir, 'notunnel');\n    if (fs.existsSync(ntPath)) {\n      pending.push(\n        Settings.set('notunnel', true).then(() => {\n          fs.unlinkSync(ntPath);\n        }).catch((e) => {\n          throw e;\n        })\n      );\n    }\n\n    // Move the wifiskip setting into the database.\n    const wsPath = path.join(this.configDir, 'wifiskip');\n    if (fs.existsSync(wsPath)) {\n      pending.push(\n        Settings.set('wifiskip', true).then(() => {\n          fs.unlinkSync(wsPath);\n        }).catch((e) => {\n          throw e;\n        })\n      );\n    }\n\n    // Move certificates, if necessary.\n    const pkPath1 = path.join(this.gatewayDir, 'privatekey.pem');\n    const pkPath2 = path.join(this.gatewayDir, 'ssl', 'privatekey.pem');\n    if (fs.existsSync(pkPath1)) {\n      this.renameFile(pkPath1, path.join(this.sslDir, 'privatekey.pem'));\n    } else if (fs.existsSync(pkPath2)) {\n      this.renameFile(pkPath2, path.join(this.sslDir, 'privatekey.pem'));\n    }\n\n    const certPath1 = path.join(this.gatewayDir, 'certificate.pem');\n    const certPath2 = path.join(this.gatewayDir, 'ssl', 'certificate.pem');\n    if (fs.existsSync(certPath1)) {\n      this.renameFile(certPath1, path.join(this.sslDir, 'certificate.pem'));\n    } else if (fs.existsSync(certPath2)) {\n      this.renameFile(certPath2, path.join(this.sslDir, 'certificate.pem'));\n    }\n\n    const chainPath1 = path.join(this.gatewayDir, 'chain.pem');\n    const chainPath2 = path.join(this.gatewayDir, 'ssl', 'chain.pem');\n    if (fs.existsSync(chainPath1)) {\n      this.renameFile(chainPath1, path.join(this.sslDir, 'chain.pem'));\n    } else if (fs.existsSync(chainPath2)) {\n      this.renameFile(chainPath2, path.join(this.sslDir, 'chain.pem'));\n    }\n\n    const csrPath1 = path.join(this.gatewayDir, 'csr.pem');\n    const csrPath2 = path.join(this.gatewayDir, 'ssl', 'csr.pem');\n    if (fs.existsSync(csrPath1)) {\n      this.renameFile(csrPath1, path.join(this.sslDir, 'csr.pem'));\n    } else if (fs.existsSync(csrPath2)) {\n      this.renameFile(csrPath2, path.join(this.sslDir, 'csr.pem'));\n    }\n\n    const oldSslDir = path.join(this.gatewayDir, 'ssl');\n    if (fs.existsSync(oldSslDir)) {\n      rimraf.sync(oldSslDir, (err) => {\n        if (err) {\n          throw err;\n        }\n      });\n    }\n\n    // Move old uploads, if necessary.\n    const oldUploadsDir = path.join(this.gatewayDir, 'static', 'uploads');\n    if (fs.existsSync(oldUploadsDir) &&\n      fs.lstatSync(oldUploadsDir).isDirectory()) {\n      const fnames = fs.readdirSync(oldUploadsDir);\n      for (const fname of fnames) {\n        this.renameFile(\n          path.join(oldUploadsDir, fname), path.join(this.uploadsDir, fname));\n      }\n\n      fs.rmdirSync(oldUploadsDir);\n    }\n\n    // Create a user config if one doesn't exist.\n    const oldUserConfigPath = path.join(this.configDir, 'local.js');\n    const oldLocalConfigPath = path.join(this.gatewayDir, 'config', 'local.js');\n    const userConfigPath = path.join(this.configDir, 'local.json');\n\n    if (!fs.existsSync(userConfigPath)) {\n      if (fs.existsSync(oldUserConfigPath)) {\n        const oldConfig = config.util.parseFile(oldUserConfigPath);\n        fs.writeFileSync(userConfigPath, JSON.stringify(oldConfig, null, 2));\n      } else {\n        fs.writeFileSync(userConfigPath, '{\\n}');\n      }\n    }\n\n    if (fs.existsSync(oldUserConfigPath)) {\n      fs.unlinkSync(oldUserConfigPath);\n    }\n\n    if (fs.existsSync(oldLocalConfigPath)) {\n      fs.unlinkSync(oldLocalConfigPath);\n    }\n\n    // Handle any config migrations\n    if (fs.existsSync(userConfigPath)) {\n      const cfg = JSON.parse(fs.readFileSync(userConfigPath));\n      let changed = false;\n\n      // addonManager.listUrl -> addonManager.listUrls\n      if (cfg.hasOwnProperty('addonManager') &&\n          cfg.addonManager.hasOwnProperty('listUrl')) {\n        if (cfg.addonManager.hasOwnProperty('listUrls')) {\n          cfg.addonManager.listUrls.push(cfg.addonManager.listUrl);\n          cfg.addonManager.listUrls =\n            Array.from(new Set(cfg.addonManager.listUrls));\n        } else {\n          cfg.addonManager.listUrls = [cfg.addonManager.listUrl];\n        }\n\n        delete cfg.addonManager.listUrl;\n        changed = true;\n      }\n\n      if (changed) {\n        fs.writeFileSync(userConfigPath, JSON.stringify(cfg, null, 2));\n      }\n    }\n\n    const localConfig = config.util.parseFile(userConfigPath);\n    if (localConfig) {\n      config.util.extendDeep(config, localConfig);\n    }\n\n    // Move anything that exists in ~/mozilla-iot, such as certbot configs.\n    const oldProfileDir = path.join(os.homedir(), 'mozilla-iot');\n    const oldEtcDir = path.join(oldProfileDir, 'etc');\n    if (fs.existsSync(oldEtcDir) && fs.lstatSync(oldEtcDir).isDirectory()) {\n      pending.push(this.renameDir(oldEtcDir, path.join(this.baseDir, 'etc')));\n    }\n    const oldVarDir = path.join(oldProfileDir, 'var');\n    if (fs.existsSync(oldVarDir) && fs.lstatSync(oldVarDir).isDirectory()) {\n      pending.push(this.renameDir(oldVarDir, path.join(this.baseDir, 'var')));\n    }\n\n    // Move add-ons.\n    if (process.env.NODE_ENV !== 'test') {\n      const oldAddonsDir = path.join(this.gatewayDir, 'build', 'addons');\n      if (fs.existsSync(oldAddonsDir) &&\n        fs.lstatSync(oldAddonsDir).isDirectory()) {\n        const fnames = fs.readdirSync(oldAddonsDir);\n        for (const fname of fnames) {\n          const oldFname = path.join(oldAddonsDir, fname);\n          const newFname = path.join(this.addonsDir, fname);\n          const lstat = fs.lstatSync(oldFname);\n\n          if (fname !== 'plugin' && lstat.isDirectory()) {\n            // Move existing add-ons.\n            pending.push(this.renameDir(oldFname, newFname));\n          }\n        }\n      }\n    }\n    return Promise.all(pending);\n  },\n};\n\nmodule.exports = Profile;\n","/**\n * Various utilities.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n'use strict';\n\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst platform = require('./platform');\nconst pkg = require('../package.json');\n\nmodule.exports = {\n  /**\n   * Compute a SHA-256 checksum of a file.\n   *\n   * @param {String} fname File path\n   * @returns A checksum as a lower case hex string.\n   */\n  hashFile: (fname) => {\n    const hash = crypto.createHash('sha256');\n\n    let fd;\n    try {\n      fd = fs.openSync(fname, 'r');\n      const buffer = new Uint8Array(4096);\n\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const bytes = fs.readSync(fd, buffer, 0, 4096);\n        if (bytes <= 0) {\n          break;\n        }\n        hash.update(buffer.slice(0, bytes));\n      }\n    } catch (e) {\n      console.error(e);\n      return null;\n    } finally {\n      if (fd) {\n        fs.closeSync(fd);\n      }\n    }\n\n    return hash.digest('hex').toLowerCase();\n  },\n\n  /**\n   * Escape text such that it's safe to be placed in HTML.\n   */\n  escapeHtml: (text) => {\n    if (typeof text !== 'string') {\n      text = `${text}`;\n    }\n\n    return text\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#039;');\n  },\n\n  getGatewayUserAgent: () => {\n    const primary = `mozilla-iot-gateway/${pkg.version}`;\n    const secondary = `(${platform.getArchitecture()}; ${platform.getOS()})`;\n    const tertiary = platform.isDocker() ? ' (docker)' : '';\n\n    return `${primary} ${secondary}${tertiary}`;\n  },\n};\n","'use strict';\n\nconst bodyParser = require('body-parser');\nconst config = require('config');\nconst Constants = require('./constants');\nconst express = require('express');\nconst expressHandlebars = require('express-handlebars');\nconst mDNSserver = require('./mdns-server');\nconst os = require('os');\nconst platform = require('./platform');\nconst Settings = require('./models/settings');\nconst sleep = require('./sleep');\n\nconst hbs = expressHandlebars.create({\n  helpers: {\n    escapeQuotes: (str) => `${str}`.replace(/'/, '\\\\\\''),\n  },\n  defaultLayout: undefined, // eslint-disable-line no-undefined\n  layoutsDir: Constants.VIEWS_PATH,\n});\n\n// The express server\nconst app = express();\napp.engine('handlebars', hbs.engine);\napp.set('view engine', 'handlebars');\napp.set('views', Constants.VIEWS_PATH);\n\n// When we get POSTs, handle the body like this\napp.use(bodyParser.urlencoded({extended: false}));\n\n// Define the handler methods for the various URLs we handle\napp.get('/*', handleCaptive);\napp.get('/', handleRoot);\napp.get('/wifi-setup', handleWiFiSetup);\napp.post('/connecting', handleConnecting);\napp.use(express.static(Constants.BUILD_STATIC_PATH));\n\nconst WiFiSetupApp = {\n  onRequest: app,\n};\n\n/**\n * Handle captive portal requests.\n */\nfunction handleCaptive(request, response, next) {\n  console.log('wifi-setup: handleCaptive:', request.path);\n\n  switch (request.path) {\n    case '/hotspot.html': {\n      // WISPr XML response\n      const ssid = getHotspotSsid();\n      response.render(\n        'hotspot',\n        {\n          ap_ssid: ssid,\n          ap_ip: config.get('wifi.ap.ipaddr'),\n        }\n      );\n      break;\n    }\n    case '/hotspot-detect.html':        // iOS/macOS\n    case '/library/test/success.html':  // iOS/macOS\n    case '/connecttest.txt': {          // Windows\n      const ua = request.get('User-Agent');\n\n      // These 2 user-agents expect a WISPr XML response\n      if (ua.includes('CaptiveNetworkSupport') ||\n          ua.includes('Microsoft NCSI')) {\n        response.redirect(\n          302,\n          `http://${config.get('wifi.ap.ipaddr')}/hotspot.html`\n        );\n        break;\n      }\n\n      // otherwise, fall through\n    }\n    // eslint-disable-next-line no-fallthrough\n    case '/kindle-wifi/wifistub.html':  // Kindle\n    case '/generate_204':               // Android, Chrome\n    case '/fwlink/':                    // Windows\n    case '/redirect':                   // Windows\n    case '/success.txt':                // Firefox\n      // Redirect to the wifi setup page\n      response.redirect(\n        302,\n        `http://${config.get('wifi.ap.ipaddr')}/wifi-setup`\n      );\n      break;\n    default:\n      console.log('wifi-setup: handleCaptive: unknown path, skipping.');\n      next();\n      break;\n  }\n}\n\n/**\n * Handle requests to the root URL. We display a different page depending on\n * what stage of setup we're at.\n */\nfunction handleRoot(request, response) {\n  const status = platform.getWirelessMode();\n\n  if (!(status.enabled && status.mode === 'sta')) {\n    // If we don't have a wifi connection yet, display the wifi setup page\n    console.log(\n      'wifi-setup: handleRoot: no wifi connection; redirecting to wifiSetup'\n    );\n    response.redirect('/wifi-setup');\n  } else {\n    // Otherwise, look to see if we have an oauth token yet\n    console.log(\n      'wifi-setup: handleRoot: wifi setup complete; redirecting to /status'\n    );\n    response.redirect('/status');\n  }\n}\n\n/**\n * Handle requests to /wifi-setup.\n */\nfunction handleWiFiSetup(request, response) {\n  scan().then((results) => {\n    // XXX\n    // To handle the case where the user entered a bad password and we are\n    // not connected, we should show the networks we know about, and modify\n    // the template to explain that if the user is seeing it, it means\n    // that the network is down or password is bad. This allows the user\n    // to re-enter a network.  Hopefully wpa_supplicant is smart enough\n    // to do the right thing if there are two entries for the same ssid.\n    // If not, we could modify defineNetwork() to overwrite rather than\n    // just adding.\n    let networks = [];\n    if (results) {\n      networks = results.map((result) => {\n        const icon = result.encryption ? 'wifi-secure.svg' : 'wifi.svg';\n        return {\n          icon: `/images/${icon}`,\n          pwdRequired: result.encryption,\n          ssid: result.ssid,\n        };\n      });\n    }\n\n    response.render('wifi-setup', {networks});\n  });\n}\n\n/**\n * Handle requests to /connecting.\n */\nfunction handleConnecting(request, response) {\n  mDNSserver.getmDNSdomain().then((domain) => {\n    const skip = request.body.skip === '1';\n\n    if (skip) {\n      console.log(\n        'wifi-setup: handleConnecting: wifi setup skipped, stopping the AP.'\n      );\n\n      Settings.set('wifiskip', true).catch((e) => {\n        console.error(\n          'wifi-setup: handleConnecting: failed to store wifiskip:', e\n        );\n      }).then(() => {\n        response.render(\n          'connecting',\n          {\n            skip: `${skip}`,\n            domain,\n          }\n        );\n        stopAP();\n        WiFiSetupApp.onConnection();\n      });\n      return;\n    }\n\n    const ssid = request.body.ssid.trim();\n    const password = request.body.password.trim();\n\n    // XXX\n    // We can come back here from the status page if the user defines\n    // more than one network. We always need to call defineNetwork(), but\n    // only need to call stopAP() if we're actually in ap mode.\n    //\n    // Also, if we're not in AP mode, then we should just redirect to\n    // /status instead of sending the connecting template.\n    response.render(\n      'connecting',\n      {\n        skip: `${skip}`,\n        domain,\n      }\n    );\n\n    // Wait before switching networks to make sure the response gets through.\n    // And also wait to be sure that the access point is fully down before\n    // defining the new network. If I only wait two seconds here, it seems\n    // like the Edison takes a really long time to bring up the new network\n    // but a 5 second wait seems to work better.\n    sleep(2000)\n      .then(() => {\n        stopAP();\n        return sleep(5000);\n      })\n      .then(() => {\n        if (!defineNetwork(ssid, password)) {\n          console.error(\n            'wifi-setup: handleConnecting: failed to define network'\n          );\n        } else {\n          return waitForWiFi(20, 3000).then(() => {\n            WiFiSetupApp.onConnection();\n          });\n        }\n      })\n      .catch((error) => {\n        if (error) {\n          console.error('wifi-setup: handleConnecting: general error:', error);\n        }\n      });\n  });\n}\n\n/**\n * Get the SSID of the hotspot.\n *\n * @returns {string} SSID\n */\nfunction getHotspotSsid() {\n  const base = config.get('wifi.ap.ssid_base');\n  const mac = platform.getMacAddress('wlan0');\n  if (!mac) {\n    return base;\n  }\n\n  // Get the last 2 octets of the MAC and create a simple string, e.g. 9E28\n  const id = mac.split(':').slice(4).join('').toUpperCase();\n\n  return `${base} ${id}`;\n}\n\n/**\n * Scan for available wifi networks.\n *\n * @returns {Promise<Object[]>} Promise which resolves to the list of networks:\n *                              [\n *                                {\n *                                  ssid: '...',\n *                                  quality: ...,\n *                                  encryption: true|false\n *                                },\n *                                ...\n *                              ]\n */\nfunction scan() {\n  const maxAttempts = 5;\n\n  return new Promise(function(resolve) {\n    let attempts = 0;\n\n    function tryScan() {\n      attempts++;\n\n      const results = platform.scanWirelessNetworks();\n      if (results.length > 0) {\n        resolve(results);\n      } else {\n        console.log('wifi-setup: scan: Scan attempt', attempts, 'failed');\n\n        if (attempts >= maxAttempts) {\n          console.error(\n            'wifi-setup: scan: Giving up. No scan results available.'\n          );\n          resolve([]);\n        } else {\n          console.log('wifi-setup: scan: Will try again in 3 seconds.');\n          setTimeout(tryScan, 3000);\n        }\n      }\n    }\n\n    tryScan();\n  });\n}\n\n/**\n * Enable an access point that users can connect to to configure the device.\n *\n * This requires that hostapd and udhcpd are installed on the system but not\n * enabled, so that they do not automatically run when the device boots up.\n * This also requires that hostapd and udhcpd have appropriate config files\n * that define the SSID for the wifi network to be created, for example.\n * Also, the udhcpd config file should be set up to work with the IP address\n * of the device.\n *\n * @param {string} ipaddr - IP address of AP\n * @returns {boolean} Boolean indicating success of the command.\n */\nfunction startAP(ipaddr) {\n  const ssid = getHotspotSsid();\n  if (!platform.setWirelessMode(true, 'ap', {ssid, ipaddr})) {\n    return false;\n  }\n\n  return platform.setDhcpServerStatus(true);\n}\n\n/**\n * Stop the running access point.\n *\n * @returns {boolean} Boolean indicating success of the command.\n */\nfunction stopAP() {\n  if (!platform.setWirelessMode(false, 'ap')) {\n    return false;\n  }\n\n  return platform.setDhcpServerStatus(false);\n}\n\n/**\n * Define a new network and connect to it.\n *\n * @param {string} ssid - SSID to configure\n * @param {string?} password - PSK to configure\n * @returns {boolean} Boolean indicating success of the command.\n */\nfunction defineNetwork(ssid, password) {\n  return platform.setWirelessMode(true, 'sta', {ssid, key: password});\n}\n\n/**\n * Determine whether or not we already have a connection.\n *\n * @returns {Promise} Promise which resolves to true/false, indicating whether\n *                    or not we have a connection.\n */\nfunction checkConnection() {\n  const ensureAPStopped = () => {\n    // If the host seems to be in AP mode (e.g. from a previous run), stop it\n    if (platform.getDhcpServerStatus() ||\n        platform.getWirelessMode().mode === 'ap') {\n      stopAP();\n    }\n  };\n\n  return Settings.get('wifiskip').catch(() => false).then((skipped) => {\n    if (skipped) {\n      ensureAPStopped();\n      return Promise.resolve(true);\n    }\n\n    // If wifi wasn't skipped, but there is an ethernet connection, just move on\n    const addresses = platform.getNetworkAddresses();\n    if (addresses.lan) {\n      ensureAPStopped();\n      return Promise.resolve(true);\n    }\n\n    // Wait until we have a working wifi connection. Retry every 3 seconds up\n    // to 20 times. If we never get a wifi connection, go into AP mode.\n    return waitForWiFi(20, 3000).then(() => {\n      ensureAPStopped();\n      return true;\n    }).catch((err) => {\n      if (err) {\n        console.error('wifi-setup: checkConnection: Error waiting:', err);\n      }\n\n      console.log(\n        'wifi-setup: checkConnection: No wifi connection found, starting AP'\n      );\n\n      if (!startAP(config.get('wifi.ap.ipaddr'))) {\n        console.error('wifi-setup: checkConnection: failed to start AP');\n      }\n\n      return false;\n    });\n  });\n}\n\n/**\n * Wait for a wifi connection.\n *\n * @param {number} maxAttempts - Maximum number of attempts\n * @param {number} interval - Interval at which to check, in milliseconds\n * @returns {Promise} Promise which resolves when we're connected. If we\n *                    aren't connected after maxAttempts attempts, then the\n *                    promise is rejected.\n */\nfunction waitForWiFi(maxAttempts, interval) {\n  return new Promise(function(resolve, reject) {\n    let attempts = 0;\n\n    // first, see if any networks are already configured\n    const status = platform.getWirelessMode();\n    if (status.options && status.options.networks &&\n        status.options.networks.length > 0) {\n      // there's at least one wifi network configured. Let's wait to see if it\n      // will connect.\n      console.log(\n        'wifi-setup: waitForWiFi: networks exist:',\n        status.options.networks\n      );\n      check();\n    } else {\n      // No wifi network configured. Let's skip the wait and start the setup\n      // immediately.\n      reject();\n    }\n\n    function check() {\n      attempts++;\n      const status = platform.getWirelessMode();\n      if (status.enabled && status.mode === 'sta') {\n        console.log('wifi-setup: waitForWifi: connection found');\n        checkForAddress();\n      } else {\n        console.log(\n          'wifi-setup: waitForWifi: No wifi connection on attempt', attempts\n        );\n        retryOrGiveUp();\n      }\n    }\n\n    function checkForAddress() {\n      const ifaces = os.networkInterfaces();\n\n      if (ifaces.hasOwnProperty('wlan0')) {\n        for (const addr of ifaces.wlan0) {\n          if (addr.family !== 'IPv4' || addr.internal) {\n            continue;\n          }\n\n          resolve();\n          return;\n        }\n      }\n\n      retryOrGiveUp();\n    }\n\n    function retryOrGiveUp() {\n      if (attempts >= maxAttempts) {\n        console.error('wifi-setup: waitForWiFi: No wifi available, giving up.');\n        reject();\n      } else {\n        setTimeout(check, interval);\n      }\n    }\n  });\n}\n\nmodule.exports = {\n  WiFiSetupApp,\n  isWiFiConfigured: checkConnection,\n};\n","module.exports = require(\"acme-client\");","module.exports = require(\"ajv\");","module.exports = require(\"archiver\");","module.exports = require(\"asn1.js\");","module.exports = require(\"assert\");","module.exports = require(\"bcryptjs\");","module.exports = require(\"body-parser\");","module.exports = require(\"callsites\");","module.exports = require(\"child_process\");","module.exports = require(\"compression\");","module.exports = require(\"config\");","module.exports = require(\"country-list\");","module.exports = require(\"crypto\");","module.exports = require(\"events\");","module.exports = require(\"express\");","module.exports = require(\"express-fileupload\");","module.exports = require(\"express-handlebars\");","module.exports = require(\"express-promise-router\");","module.exports = require(\"express-rate-limit\");","module.exports = require(\"express-ws\");","module.exports = require(\"find\");","module.exports = require(\"fs\");","module.exports = require(\"gateway-addon\");","module.exports = require(\"glob-to-regexp\");","module.exports = require(\"http\");","module.exports = require(\"http-proxy\");","module.exports = require(\"https\");","module.exports = require(\"ip-regex\");","module.exports = require(\"jsonwebtoken\");","module.exports = require(\"mkdirp\");","module.exports = require(\"ncp\");","module.exports = require(\"nocache\");","module.exports = require(\"node-fetch\");","module.exports = require(\"node-getopt\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"process\");","module.exports = require(\"promisepipe\");","module.exports = require(\"readline\");","module.exports = require(\"rimraf\");","module.exports = require(\"segfault-handler\");","module.exports = require(\"semver\");","module.exports = require(\"speakeasy\");","module.exports = require(\"sqlite3\");","module.exports = require(\"stream\");","module.exports = require(\"string-format\");","module.exports = require(\"tar\");","module.exports = require(\"tmp\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"uuid\");","module.exports = require(\"web-push\");","module.exports = require(\"winston\");","module.exports = require(\"winston-daily-rotate-file\");","module.exports = require(\"ws\");"],"sourceRoot":""}